<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【网络编程】Netty 实现WebSocket 服务</title>
    <link href="/2024/09/13/Java%E7%AC%94%E8%AE%B0/Netty%20%E5%AE%9E%E7%8E%B0WebSocket%20%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/09/13/Java%E7%AC%94%E8%AE%B0/Netty%20%E5%AE%9E%E7%8E%B0WebSocket%20%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1>Netty 实现WebSocket 服务</h1><p>在使用 Netty 实现 WebSocket 服务时，我们需要几个关键步骤来确保服务的正确运行和优化性能。首先，我们需要设置 Netty 服务器，并配置相应的通道初始化器来处理 WebSocket 请求。其次，我们需要实现 WebSocket 处理器来管理连接、消息和关闭事件。</p><ol><li><strong>设置 Netty 服务器</strong>：启动一个 Netty 服务器，监听特定端口并等待 WebSocket 客户端的连接。</li><li><strong>配置通道初始化器</strong>：在通道初始化器中添加必要的处理器，例如 <code>HttpServerCodec</code>、<code>HttpObjectAggregator</code> 和 <code>WebSocketServerProtocolHandler</code>。</li><li><strong>实现 WebSocket 处理器</strong>：编写自定义处理器来处理 WebSocket 的连接、消息和断开事件。确保处理器能够处理文本消息、二进制消息以及心跳检测。</li><li><strong>实现WebSocket握手鉴权</strong>：实际情况服务端需要对客户端的握手请求进行相关判断策略验证，通过才可以连接成功，不通过就认为是非法链接拒绝链接。</li></ol><p>通过以上步骤，我们可以使用 Netty 搭建一个高效的 WebSocket 服务，支持实时通信需求。</p><p>在工作中通常是使用的是将Netty服务当作一个bean交给了spring管理。下面我们开始数据搭建过程</p><h1>一、设置Netty服务器</h1><p><strong>Menservants</strong> 类是spring的一个bean 在初始化的时候，和销毁时自动对WebSocket服务进行启动和关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CAgentServer</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(CAgentServer.class);<br><br><span class="hljs-meta">@Value(&quot;$&#123;server.cagent.listener.port&#125;&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8888</span>;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> CAgentServerInitializer serverInitializer;<br><br><span class="hljs-keyword">private</span> EventLoopGroup bossGroup;<br><span class="hljs-keyword">private</span> EventLoopGroup workerGroup;<br><span class="hljs-keyword">private</span> ChannelFuture channelFuture;<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>log.info(<span class="hljs-string">&quot;Before run server&quot;</span>);<br>bossGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>workerGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">512</span>);<br><br><span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>b.group(bossGroup, workerGroup);<br>b.channel(NioServerSocketChannel.class);<br><span class="hljs-comment">// b.channel(OioServerSocketChannel.class);</span><br>b.childHandler(serverInitializer);<br>b.option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>);<br>b.childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>);<br>channelFuture = b.bind(port).sync();<br>&#125;<br><br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">try</span> &#123;<br>channelFuture.channel().close().sync();<br>log.info(<span class="hljs-string">&quot;after stop server&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>workerGroup.shutdownGracefully();<br>bossGroup.shutdownGracefully();<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这一部分代码基本上没什么变化 ，<code>b.childHandler(serverInitializer);</code>这里设置了一个通道初始化器，这里包含了我们对通道的所有处理逻辑。</p><h1>二、配置通道初始化器</h1><p><strong>ChannelInitializer</strong> 类用于设置 Netty 处理管道，包括处理 HTTP 请求和 WebSocket 协议的处理器。以下是一个示例实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CAgentServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(CAgentServerInitializer.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br><br>        <span class="hljs-comment">// 添加 HTTP 服务端编解码器</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br>        <span class="hljs-comment">// 添加 HTTP 对象聚合器</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpObjectAggregator</span>(<span class="hljs-number">65536</span>));<br>        <span class="hljs-comment">// 添加 WebSocket 协议处理器</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServerProtocolHandler</span>(<span class="hljs-string">&quot;/ws&quot;</span>));<br>        <span class="hljs-comment">// 添加自定义的 WebSocket 处理器</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CAgentWebSocketHandler</span>());<br><br>        log.info(<span class="hljs-string">&quot;WebSocket channel initialized&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过以上步骤，我们可以确保 Netty 服务器能够正确处理 WebSocket 请求，并且可以在必要的情况下进行握手鉴权。</p><h1>三、自定义 WebSocket 处理器</h1><p>自定义的 WebSocket 处理器 <code>CAgentWebSocketHandler</code> 用于处理连接成功事件、消息事件和断开事件。以下是一个示例实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CAgentWebSocketHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(CAgentWebSocketHandler.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.info(<span class="hljs-string">&quot;Client connected: &#123;&#125;&quot;</span>, ctx.channel().id().asLongText());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.info(<span class="hljs-string">&quot;Client disconnected: &#123;&#125;&quot;</span>, ctx.channel().id().asLongText());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> msg.text();<br>        log.info(<span class="hljs-string">&quot;Received message: &#123;&#125;&quot;</span>, request);<br><br>        <span class="hljs-comment">// 处理消息，响应给客户端</span><br>        ctx.channel().writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextWebSocketFrame</span>(<span class="hljs-string">&quot;Server received your message: &quot;</span> + request));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.error(<span class="hljs-string">&quot;Error occurred: &quot;</span>, cause);<br>        ctx.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个处理器中，我们实现了以下方法：</p><ol><li><code>handlerAdded(ChannelHandlerContext ctx)</code>：当客户端成功连接时调用。</li><li><code>handlerRemoved(ChannelHandlerContext ctx)</code>：当客户端断开连接时调用。</li><li><code>channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg)</code>：当服务器接收到客户端发送的消息时调用。</li><li><code>exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</code>：当发生异常时调用，记录错误并关闭连接。</li></ol><h2 id="3-1-ChannelHandler的生命周期与事件处理机制">3.1 <strong>ChannelHandler的生命周期与事件处理机制</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/skr-1008/picgo1@main/img/202408271623376.png" alt="生命周期与事件处理机制"></p><h3 id="概述"><strong>概述</strong></h3><p>Netty的<code>ChannelHandler</code>是处理网络事件（如数据读取、数据写入、连接建立、连接关闭等）的核心组件。</p><p>在Netty中，<code>ChannelHandler</code>的生命周期与<code>Channel</code>的状态紧密相关，主要涉及到以下几个阶段：</p><ol><li><strong>初始化（Initialization）</strong>:<ul><li><code>handlerAdded</code> 方法被调用，这通常发生在<code>ChannelPipeline</code>初始化时，表示一个新的<code>ChannelHandler</code>被加入到<code>ChannelPipeline</code>中。</li></ul></li><li><strong>注册（Registration）</strong>:<ul><li><code>channelRegistered</code> 方法被调用，这表示<code>Channel</code>已经成功注册到它的<code>EventLoop</code>上。</li></ul></li><li><strong>激活（Activation）</strong>:<ul><li><code>channelActive</code> 方法被调用，表示<code>Channel</code>已经成功激活，可以开始接收和发送数据。</li></ul></li><li><strong>读取数据（Read）</strong>:<ul><li><code>channelRead</code> 方法被调用，这表示从<code>Channel</code>中读取到了数据。</li></ul></li><li><strong>读完成（Read Complete）</strong>:<ul><li><code>channelReadComplete</code> 方法被调用，这表示一次读取操作完成。</li></ul></li><li><strong>关闭（Deactivation）</strong>:<ul><li><code>channelInactive</code> 方法被调用，表示<code>Channel</code>与远端主机失去了连接，变成了非激活状态。</li></ul></li><li><strong>注销（Deregistration）</strong>:<ul><li><code>channelUnregistered</code> 方法被调用，表示<code>Channel</code>从它的<code>EventLoop</code>上注销。</li></ul></li><li><strong>移除（Removal）</strong>:<ul><li><code>handlerRemoved</code> 方法被调用，表示<code>ChannelHandler</code>被从<code>ChannelPipeline</code>中移除。</li></ul></li></ol><p>这些方法的调用顺序与<code>Channel</code>的状态转换顺序相对应，形成了一个完整的生命周期。在实际应用中，根据不同的需求，开发者可以重写这些方法来实现自定义的逻辑处理，比如处理超时、心跳保活、数据编解码等。</p><aside>💡 常见用法<p>handlerAdded() 与 handlerRemoved()可以用在一些资源的申请和释放<br>channelActive() 与 channelInActive()可以统计单机的连接数，channelActive() 被调用，连接数加一，channelInActive() 被调用，连接数减一。channelActive() 还可以实现ip黑白名单的过滤</p><p>channelRead()用来拆包读取信息</p><p>channelReadComplete()实现批量刷新的机制，这样channelRead()中只使用write() 方法而不用writeAndFlush()每次都刷新写入到缓存，从而提高性能。</p></aside><p><strong>生命周期Handler Dem</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.artisan.reconnect;<br><br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  handler的生命周期回调接口调用顺序:</span><br><span class="hljs-comment"> *  handlerAdded -&gt; channelRegistered -&gt; channelActive -&gt; channelRead -&gt; channelReadComplete</span><br><span class="hljs-comment"> *  -&gt; channelInactive -&gt; channelUnRegistered -&gt; handlerRemoved</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * handlerAdded: 新建立的连接会按照初始化策略，把handler添加到该channel的pipeline里面，也就是channel.pipeline.addLast(new LifeCycleInBoundHandler)执行完成后的回调；</span><br><span class="hljs-comment"> * channelRegistered: 当该连接分配到具体的worker线程后，该回调会被调用。</span><br><span class="hljs-comment"> * channelActive：channel的准备工作已经完成，所有的pipeline添加完成，并分配到具体的线上上，说明该channel准备就绪，可以使用了。</span><br><span class="hljs-comment"> * channelRead：客户端向服务端发来数据，每次都会回调此方法，表示有数据可读；</span><br><span class="hljs-comment"> * channelReadComplete：服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕；</span><br><span class="hljs-comment"> * channelInactive：当连接断开时，该回调会被调用，说明这时候底层的TCP连接已经被断开了。</span><br><span class="hljs-comment"> * channelUnRegistered: 对应channelRegistered，当连接关闭后，释放绑定的workder线程；</span><br><span class="hljs-comment"> * handlerRemoved： 对应handlerAdded，将handler从该channel的pipeline移除后的回调方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LifeCycleInBoundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span><br>            <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;channelRegistered: channel注册到NioEventLoop&quot;</span>);<br>        <span class="hljs-built_in">super</span>.channelRegistered(ctx);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelUnregistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <br>            <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;channelUnregistered: channel取消和NioEventLoop的绑定&quot;</span>);<br>        <span class="hljs-built_in">super</span>.channelUnregistered(ctx);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <br>            <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;channelActive: channel准备就绪&quot;</span>);<br>        <span class="hljs-built_in">super</span>.channelActive(ctx);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <br>            <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;channelInactive: channel被关闭&quot;</span>);<br>        <span class="hljs-built_in">super</span>.channelInactive(ctx);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <br>            <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;channelRead: channel中有可读的数据&quot;</span> );<br>        <span class="hljs-built_in">super</span>.channelRead(ctx, msg);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <br>            <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;channelReadComplete: channel读数据完成&quot;</span>);<br>        <span class="hljs-built_in">super</span>.channelReadComplete(ctx);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <br>            <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;handlerAdded: handler被添加到channel的pipeline&quot;</span>);<br>        <span class="hljs-built_in">super</span>.handlerAdded(ctx);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <br>            <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;handlerRemoved: handler从channel的pipeline中移除&quot;</span>);<br>        <span class="hljs-built_in">super</span>.handlerRemoved(ctx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>四、心跳超时剔除</h1><p>为了确保 WebSocket 连接的稳定性和及时释放资源，我们可以在服务器中实现心跳检测机制，并在连接超时时剔除不活跃的连接。以下是一个实现心跳检测的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CAgentServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(CAgentServerInitializer.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br><br>        <span class="hljs-comment">// 添加 HTTP 服务端编解码器</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br>        <span class="hljs-comment">// 添加 HTTP 对象聚合器</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpObjectAggregator</span>(<span class="hljs-number">65536</span>));<br>        <span class="hljs-comment">// 添加 WebSocket 协议处理器</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServerProtocolHandler</span>(<span class="hljs-string">&quot;/ws&quot;</span>));<br>        <span class="hljs-comment">// 添加心跳检测处理器（如果超过60秒没有接收到客户端的心跳包，则关闭连接）</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">60</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, TimeUnit.SECONDS));<br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeartbeatHandler</span>());<br>        <span class="hljs-comment">// 添加自定义的 WebSocket 处理器</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CAgentWebSocketHandler</span>());<br><br>        log.info(<span class="hljs-string">&quot;WebSocket channel initialized&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeartbeatHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HeartbeatHandler.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;<br>            <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> (IdleStateEvent) evt;<br>            <span class="hljs-keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;<br>                log.info(<span class="hljs-string">&quot;No heartbeat received from client, closing connection: &#123;&#125;&quot;</span>, ctx.channel().id().asLongText());<br>                ctx.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">super</span>.userEventTriggered(ctx, evt);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在此实现中，我们在 <code>CAgentServerInitializer</code> 中添加了 <code>IdleStateHandler</code> 和 <code>HeartbeatHandler</code> 两个处理器：</p><ol><li><code>IdleStateHandler</code>：用于检测连接的空闲状态。如果在指定时间内（如60秒）没有接收到客户端的任何数据，该处理器会触发 <code>IdleStateEvent</code> 事件。</li><li><code>HeartbeatHandler</code>：继承自 <code>ChannelInboundHandlerAdapter</code>，用于处理 <code>IdleStateEvent</code> 事件。如果检测到读取空闲状态（即超过指定时间没有接收到客户端的心跳包），则关闭该连接。</li></ol><p>通过这种方式，我们可以确保 WebSocket 服务能够及时剔除不活跃的连接，保持连接的健康状态。</p><hr><h2 id="另外一种操作-阅读下源码">另外一种操作,阅读下源码</h2><p><code>IdleStateHandler</code> 内有三个内部类, <code>ReaderIdleTimeoutTask</code>,<code>WriterIdleTimeoutTask ,AllIdleTimeoutTask</code> 里面都会调用  channelIdle 方法  也就是出现超时事件时 都会执行这个方法</p><p><img src="https://cdn.jsdelivr.net/gh/skr-1008/picgo1@main/img/202411071427992.png" alt="IdleStateHandler调用"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Is called when an &#123;<span class="hljs-doctag">@link</span> IdleStateEvent&#125; should be fired. This implementation calls</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ChannelHandlerContext#fireUserEventTriggered(Object)&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelIdle</span><span class="hljs-params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ctx.fireUserEventTriggered(evt);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果出现超时直接关闭channel 其实也可以写一个类继承 <code>IdleStateHandler</code> 直接重写 <code>channelIdle</code> 然后加入判断pipeline内,逻辑就是对应的事件处理,这样也可以做到,而且方法的参数就是IdleStateEvent  不用判断类型,也算是一个骚操作吧 不过这样不是官方设计的用法。官方推荐第一种用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelIdle</span><span class="hljs-params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (evt.state() == IdleState.READER_IDLE) &#123;<br>      log.warn(<span class="hljs-string">&quot;no data received after 60s, channel=&quot;</span> + ctx.channel().remoteAddress().toString()<br>          + <span class="hljs-string">&quot; will close&quot;</span>);<br>      ctx.close();<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">* &lt;pre&gt;<br>* <span class="hljs-comment">// An example that sends a ping message when there is no outbound traffic</span><br>* <span class="hljs-comment">// for 30 seconds.  The connection is closed when there is no inbound traffic</span><br>* <span class="hljs-comment">// for 60 seconds.</span><br>*<br>* <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyChannelInitializer</span> extends &#123;<span class="hljs-meta">@link</span> ChannelInitializer&#125;&amp;lt;&#123;<span class="hljs-meta">@link</span> Channel&#125;&amp;gt; &#123;<br>*     &#123;<span class="hljs-meta">@code</span> <span class="hljs-meta">@Override</span>&#125;<br>*     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(&#123;<span class="hljs-meta">@link</span> Channel&#125; channel)</span> &#123;<br>*         channel.pipeline().addLast(<span class="hljs-string">&quot;idleStateHandler&quot;</span>, <span class="hljs-keyword">new</span> &#123;<span class="hljs-meta">@link</span> IdleStateHandler&#125;(<span class="hljs-number">60</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>));<br>*         channel.pipeline().addLast(<span class="hljs-string">&quot;myHandler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHandler</span>());<br>*     &#125;<br>* &#125;<br>*<br>* <span class="hljs-comment">// Handler should handle the &#123;@link IdleStateEvent&#125; triggered by &#123;@link IdleStateHandler&#125;.</span><br>* <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> extends &#123;<span class="hljs-meta">@link</span> ChannelDuplexHandler&#125; &#123;<br>*     &#123;<span class="hljs-meta">@code</span> <span class="hljs-meta">@Override</span>&#125;<br>*     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(&#123;<span class="hljs-meta">@link</span> ChannelHandlerContext&#125; ctx, &#123;<span class="hljs-meta">@link</span> Object&#125; evt)</span> <span class="hljs-keyword">throws</span> &#123;<span class="hljs-meta">@link</span> Exception&#125; &#123;<br>*         <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> &#123;<span class="hljs-meta">@link</span> IdleStateEvent&#125;) &#123;<br>*             &#123;<span class="hljs-meta">@link</span> IdleStateEvent&#125; e = (&#123;<span class="hljs-meta">@link</span> IdleStateEvent&#125;) evt;<br>*             <span class="hljs-keyword">if</span> (e.state() == &#123;<span class="hljs-meta">@link</span> IdleState&#125;.READER_IDLE) &#123;<br>*                 ctx.close();<br>*             &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.state() == &#123;<span class="hljs-meta">@link</span> IdleState&#125;.WRITER_IDLE) &#123;<br>*                 ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PingMessage</span>());<br>*             &#125;<br>*         &#125;<br>*     &#125;<br>* &#125;<br></code></pre></td></tr></table></figure><p><strong>相关链接</strong></p><p><a href="https://blog.csdn.net/weixin_43935927/article/details/112001309">https://blog.csdn.net/weixin_43935927/article/details/112001309</a></p><p><a href="https://blog.csdn.net/m0_60259116/article/details/137680824">https://blog.csdn.net/m0_60259116/article/details/137680824</a></p><p><a href="https://blog.csdn.net/RisenMyth/article/details/104441155">https://blog.csdn.net/RisenMyth/article/details/104441155</a></p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty学习笔记</title>
    <link href="/2024/07/31/Java%E7%AC%94%E8%AE%B0/Netty%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <url>/2024/07/31/Java%E7%AC%94%E8%AE%B0/Netty%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1>Netty学习手册</h1><p>Netty 是一个基于 Java 的高性能网络开发框架，专门用于快速开发可维护的高并发网络应用程序。它提供了异步事件驱动的网络应用程序框架和工具，支持多种协议（如 HTTP、TCP、UDP 等），并且具有高度的可扩展性和灵活性。Netty 通过其高效的线程模型和丰富的功能集，简化了网络编程的复杂性，使开发者能够更专注于业务逻辑的实现。</p><p><strong>实用工具网站</strong></p><ul><li><a href="https://waylau.gitbooks.io/netty-4-user-guide/content/">https://waylau.gitbooks.io/netty-4-user-guide/content/</a> ⭐</li><li><a href="https://github.com/waylau/netty-4-user-guide-demos">https://github.com/waylau/netty-4-user-guide-demos</a> Netty各种开发Demo</li><li><a href="https://www.gitbook.com/?utm_source=legacy&amp;utm_medium=redirect&amp;utm_campaign=close_legacy">https://www.gitbook.com/?utm_source=legacy&amp;utm_medium=redirect&amp;utm_campaign=close_legacy</a>    Product documentation your users will love</li><li><a href="https://dongzl.github.io/netty-handbook/#/">https://dongzl.github.io/netty-handbook/#/</a></li></ul><h1>目录</h1><h1>第 1 章 Netty 介绍和应用场景</h1><h2 id="1-1-本课程学习要求"><strong>1.1 本课程学习要求</strong></h2><ol><li>本课程不适用于 <code>0</code> 基础的学员。</li><li>要求已经掌握了 <code>Java</code> 编程，主要技术构成：<code>Java OOP</code> 编程、<code>Java</code> 多线程编程、<code>Java IO</code> 编程、<code>Java</code> 网络编程、常用的 <code>Java</code> 设计模式（比如观察者模式，命令模式，职责链模式）、常用的数据结构（比如链表）。</li><li>本课程的《<code>Netty</code> 核心源码剖析章节》要求学员最好有项目开发和阅读源码的经历。</li></ol><h2 id="1-2-Netty-的介绍"><strong>1.2 Netty 的介绍</strong></h2><ol><li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li><li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li><li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li><li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li><li>要透彻理解 <code>Netty</code>，需要先学习 <code>NIO</code>，这样我们才能阅读 <code>Netty</code> 的源码。</li></ol><h2 id="1-3-Netty-的应用场景"><strong>1.3 Netty 的应用场景</strong></h2><h3 id="1-3-1-互联网行业"><strong>1.3.1 互联网行业</strong></h3><ol><li>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <code>RPC</code> 框架必不可少，<code>Netty</code> 作为异步高性能的通信框架，往往作为基础通信组件被这些 <code>RPC</code> 框架使用。</li><li>典型的应用有：阿里分布式服务框架 <code>Dubbo</code> 的 <code>RPC</code> 框 架使用 <code>Dubbo</code> 协议进行节点间通信，<code>Dubbo</code> 协议默认使用 <code>Netty</code> 作为基础通信组件，用于实现各进程节点之间的内部通信。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter01/chapter01_01.png" alt="1-1"></p><h3 id="1-3-2-游戏行业"><strong>1.3.2 游戏行业</strong></h3><ol><li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用。</li><li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器。</li><li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter01/chapter01_02.png" alt="01_02.png"></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter01/chapter01_03.png" alt="01_03.png"></p><h3 id="1-3-3-大数据领域"><strong>1.3.3 大数据领域</strong></h3><ol><li>经典的 <code>Hadoop</code> 的高性能通信和序列化组件 <code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信。</li><li>它的 <code>NettyService</code> 基于 <code>Netty</code> 框架二次封装实现。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter01/chapter01_04.png" alt="01_04.png"></p><h3 id="1-3-4-其它开源项目使用到-Netty"><strong>1.3.4 其它开源项目使用到 Netty</strong></h3><p>网址：<a href="https://netty.io/wiki/related-projects.html"><strong>https://netty.io/wiki/related-projects.html</strong></a></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter01/chapter01_05.png" alt="01_05.png"></p><h2 id="1-4-Netty-的学习资料参考"><strong>1.4 Netty 的学习资料参考</strong></h2><p><img src="https://img11.360buyimg.com/n1/jfs/t1516/258/38352851/215555/68f629a5/555080b2Ne6cbf9e3.jpg" alt="https://img11.360buyimg.com/n1/jfs/t1516/258/38352851/215555/68f629a5/555080b2Ne6cbf9e3.jpg"></p><p><img src="https://img10.360buyimg.com/n1/jfs/t5227/173/1793618117/453810/1253bd90/59141c1dN7a93c127.jpg" alt="https://img10.360buyimg.com/n1/jfs/t5227/173/1793618117/453810/1253bd90/59141c1dN7a93c127.jpg"></p><h1>第 3 章 Java NIO 编程</h1><h2 id="3-1-Java-NIO-基本介绍"><strong>3.1 Java NIO 基本介绍</strong></h2><ol><li><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong> ，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li><li><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li><li><code>NIO</code> 有三大核心部分: <strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</li><li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li><li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li><li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li><li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li><li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio;<br><br><span class="hljs-keyword">import</span> java.nio.IntBuffer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicBuffer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//举例说明 Buffer 的使用(简单说明)</span><br>        <span class="hljs-comment">//创建一个 Buffer，大小为 5，即可以存放 5 个 int</span><br>        <span class="hljs-type">IntBuffer</span> <span class="hljs-variable">intBuffer</span> <span class="hljs-operator">=</span> IntBuffer.allocate(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">//向buffer存放数据</span><br>        <span class="hljs-comment">//intBuffer.put(10);</span><br>        <span class="hljs-comment">//intBuffer.put(11);</span><br>        <span class="hljs-comment">//intBuffer.put(12);</span><br>        <span class="hljs-comment">//intBuffer.put(13);</span><br>        <span class="hljs-comment">//intBuffer.put(14);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;<br>            intBuffer.put(i * <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-comment">//如何从 buffer 读取数据</span><br>        <span class="hljs-comment">//将 buffer 转换，读写切换(!!!)</span><br>        intBuffer.flip();<br>        <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;<br>            System.out.println(intBuffer.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-NIO-和-BIO-的比较"><strong>3.2 NIO 和 BIO 的比较</strong></h2><ol><li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li><li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li><li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li></ol><h2 id="3-3-NIO-三大核心原理示意图"><strong>3.3 NIO 三大核心原理示意图</strong></h2><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p><h3 id="3-3-1-Selector、Channel-和-Buffer-关系图（简单版）"><strong>3.3.1 Selector、Channel 和 Buffer 关系图（简单版）</strong></h3><p>关系图的说明:</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_01.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_01.png"></p><ol><li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li><li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li><li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li><li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li><li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li><li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li><li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li></ol><h2 id="3-4-缓冲区（Buffer）"><strong>3.4 缓冲区（Buffer）</strong></h2><h3 id="3-4-1-基本介绍"><strong>3.4.1 基本介绍</strong></h3><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须由 <code>Buffer</code>，如图:【后面举例说明】</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_02.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_02.png"></p><h3 id="3-4-2-Buffer-类及其子类"><strong>3.4.2 Buffer 类及其子类</strong></h3><ol><li>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_03.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_03.png"></p><ol><li><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_05.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_05.png"></p><ol><li><code>Buffer</code> 类相关方法一览</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_06.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_06.png"></p><h3 id="3-4-3-ByteBuffer"><strong>3.4.3 ByteBuffer</strong></h3><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_07.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_07.png"></p><h2 id="3-5-通道（Channel）"><strong>3.5 通道（Channel）</strong></h2><h2 id="3-6-基本介绍"><strong>3.6 基本介绍</strong></h2><ol><li><code>NIO</code> 的通道类似于流，但有些区别如下：<ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li></ul></li><li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li><li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></li><li>常用的 <code>Channel</code> 类有: <strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong> 。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li><li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li><li>图示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_08.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_08.png"></p><h3 id="3-6-1-FileChannel-类"><strong>3.6.1 FileChannel 类</strong></h3><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p><ul><li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li><li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li><li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li><li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li></ul><h3 id="3-6-2-应用实例1-本地文件写数据"><strong>3.6.2 应用实例1 - 本地文件写数据</strong></h3><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li><li>文件不存在就创建</li><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio;<br><br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOFileChannel01</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello,尚硅谷&quot;</span>;<br>        <span class="hljs-comment">//创建一个输出流 -&gt; channel</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;d:\\file01.txt&quot;</span>);<br><br>        <span class="hljs-comment">//通过 fileOutputStream 获取对应的 FileChannel</span><br>        <span class="hljs-comment">//这个 fileChannel 真实类型是 FileChannelImpl</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel</span> <span class="hljs-operator">=</span> fileOutputStream.getChannel();<br><br>        <span class="hljs-comment">//创建一个缓冲区 ByteBuffer</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>        <span class="hljs-comment">//将 str 放入 byteBuffer</span><br>        byteBuffer.put(str.getBytes());<br><br>        <span class="hljs-comment">//对 byteBuffer 进行 flip</span><br>        byteBuffer.flip();<br><br>        <span class="hljs-comment">//将 byteBuffer 数据写入到 fileChannel</span><br>        fileChannel.write(byteBuffer);<br>        fileOutputStream.close();<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h3 id="3-6-3-应用实例2-本地文件读数据"><strong>3.6.3 应用实例2 - 本地文件读数据</strong></h3><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li><li>假定文件已经存在</li><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOFileChannel02</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//创建文件的输入流</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:\\file01.txt&quot;</span>);<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br><br>        <span class="hljs-comment">//通过 fileInputStream 获取对应的 FileChannel -&gt; 实际类型 FileChannelImpl</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel</span> <span class="hljs-operator">=</span> fileInputStream.getChannel();<br><br>        <span class="hljs-comment">//创建缓冲区</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate((<span class="hljs-type">int</span>)file.length());<br><br>        <span class="hljs-comment">//将通道的数据读入到 Buffer</span><br>        fileChannel.read(byteBuffer);<br><br>        <span class="hljs-comment">//将 byteBuffer 的字节数据转成 String</span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array()));<br>        fileInputStream.close();<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h3 id="3-6-4-应用实例3-使用一个-Buffer-完成文件读取、写入"><strong>3.6.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入</strong></h3><p>实例要求：</p><ol><li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li><li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li><li>代码演示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_09.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_09.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOFileChannel03</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;1.txt&quot;</span>);<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel01</span> <span class="hljs-operator">=</span> fileInputStream.getChannel();<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;2.txt&quot;</span>);<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel02</span> <span class="hljs-operator">=</span> fileOutputStream.getChannel();<br><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">512</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">//循环读取</span><br><br>            <span class="hljs-comment">//这里有一个重要的操作，一定不要忘了</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            public final Buffer clear() &#123;</span><br><span class="hljs-comment">                position = 0;</span><br><span class="hljs-comment">                limit = capacity;</span><br><span class="hljs-comment">                mark = -1;</span><br><span class="hljs-comment">                return this;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            */</span><br>            byteBuffer.clear(); <span class="hljs-comment">//清空 buffer</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> fileChannel01.read(byteBuffer);<br>            System.out.println(<span class="hljs-string">&quot;read = &quot;</span> + read);<br>            <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//表示读完</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//将 buffer 中的数据写入到 fileChannel02--2.txt</span><br>            byteBuffer.flip();<br>            fileChannel02.write(byteBuffer);<br>        &#125;<br><br>        <span class="hljs-comment">//关闭相关的流</span><br>        fileInputStream.close();<br>        fileOutputStream.close();<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h3 id="3-6-5-应用实例4-拷贝文件-transferFrom-方法"><strong>3.6.5 应用实例4 - 拷贝文件 transferFrom 方法</strong></h3><ol><li>实例要求：</li><li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li><li>拷贝一张图片</li><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOFileChannel04</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//创建相关流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;d:\\a.jpg&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;d:\\a2.jpg&quot;</span>);<br><br>        <span class="hljs-comment">//获取各个流对应的 FileChannel</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">sourceCh</span> <span class="hljs-operator">=</span> fileInputStream.getChannel();<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">destCh</span> <span class="hljs-operator">=</span> fileOutputStream.getChannel();<br><br>        <span class="hljs-comment">//使用 transferForm 完成拷贝</span><br>        destCh.transferFrom(sourceCh, <span class="hljs-number">0</span>, sourceCh.size());<br><br>        <span class="hljs-comment">//关闭相关通道和流</span><br>        sourceCh.close();<br>        destCh.close();<br>        fileInputStream.close();<br>        fileOutputStream.close();<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h3 id="3-6-6-关于-Buffer-和-Channel-的注意事项和细节"><strong>3.6.6 关于 Buffer 和 Channel 的注意事项和细节</strong></h3><ol><li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.atguigu.nio;<br><br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOByteBufferPutGet</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//创建一个 Buffer</span><br>        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">64</span>);<br><br>        <span class="hljs-comment">//类型化方式放入数据</span><br>        buffer.<span class="hljs-built_in">putInt</span>(<span class="hljs-number">100</span>);<br>        buffer.<span class="hljs-built_in">putLong</span>(<span class="hljs-number">9</span>);<br>        buffer.<span class="hljs-built_in">putChar</span>(<span class="hljs-string">&#x27;尚&#x27;</span>);<br>        buffer.<span class="hljs-built_in">putShort</span>((<span class="hljs-type">short</span>) <span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">//取出</span><br>        buffer.<span class="hljs-built_in">flip</span>();<br><br>        System.out.<span class="hljs-built_in">println</span>();<br><br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">getInt</span>());<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">getLong</span>());<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">getChar</span>());<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">getShort</span>());<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><ol><li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.atguigu.nio;<br><br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadOnlyBuffer</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//创建一个 buffer</span><br>        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">64</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;<br>            buffer.<span class="hljs-built_in">put</span>((<span class="hljs-type">byte</span>) i);<br>        &#125;<br><br>        <span class="hljs-comment">//读取</span><br>        buffer.<span class="hljs-built_in">flip</span>();<br><br>        <span class="hljs-comment">//得到一个只读的 Buffer</span><br>        ByteBuffer readOnlyBuffer = buffer.<span class="hljs-built_in">asReadOnlyBuffer</span>();<br>        System.out.<span class="hljs-built_in">println</span>(readOnlyBuffer.<span class="hljs-built_in">getClass</span>());<br><br>        <span class="hljs-comment">//读取</span><br>        <span class="hljs-keyword">while</span> (readOnlyBuffer.<span class="hljs-built_in">hasRemaining</span>()) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(readOnlyBuffer.<span class="hljs-built_in">get</span>());<br>        &#125;<br><br>        readOnlyBuffer.<span class="hljs-built_in">put</span>((<span class="hljs-type">byte</span>) <span class="hljs-number">100</span>); <span class="hljs-comment">//ReadOnlyBufferException</span><br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><ol><li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio;<br><br><span class="hljs-keyword">import</span> java.io.RandomAccessFile;<br><span class="hljs-keyword">import</span> java.nio.MappedByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MappedByteBufferTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>        <span class="hljs-comment">//获取对应的通道</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> randomAccessFile.getChannel();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式</span><br><span class="hljs-comment">         * 参数 2：0：可以直接修改的起始位置</span><br><span class="hljs-comment">         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span><br><span class="hljs-comment">         * 可以直接修改的范围就是 0-5</span><br><span class="hljs-comment">         * 实际类型 DirectByteBuffer</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">mappedByteBuffer</span> <span class="hljs-operator">=</span> channel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br><br>        mappedByteBuffer.put(<span class="hljs-number">0</span>, (<span class="hljs-type">byte</span>) <span class="hljs-string">&#x27;H&#x27;</span>);<br>        mappedByteBuffer.put(<span class="hljs-number">3</span>, (<span class="hljs-type">byte</span>) <span class="hljs-string">&#x27;9&#x27;</span>);<br>        mappedByteBuffer.put(<span class="hljs-number">5</span>, (<span class="hljs-type">byte</span>) <span class="hljs-string">&#x27;Y&#x27;</span>);<span class="hljs-comment">//IndexOutOfBoundsException</span><br><br>        randomAccessFile.close();<br>        System.out.println(<span class="hljs-string">&quot;修改成功~~&quot;</span>);<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><ol><li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio;<br><br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]</span><br><span class="hljs-comment"> * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScatteringAndGatheringTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">inetSocketAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">7000</span>);<br><br>        <span class="hljs-comment">//绑定端口到 socket，并启动</span><br>        serverSocketChannel.socket().bind(inetSocketAddress);<br><br>        <span class="hljs-comment">//创建 buffer 数组</span><br>        ByteBuffer[] byteBuffers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[<span class="hljs-number">2</span>];<br>        byteBuffers[<span class="hljs-number">0</span>] = ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>        byteBuffers[<span class="hljs-number">1</span>] = ByteBuffer.allocate(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">//等客户端连接 (telnet)</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">messageLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>; <span class="hljs-comment">//假定从客户端接收 8 个字节</span><br><br>        <span class="hljs-comment">//循环的读取</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">byteRead</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">while</span> (byteRead &lt; messageLength) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> socketChannel.read(byteBuffers);<br>                byteRead += l; <span class="hljs-comment">//累计读取的字节数</span><br>                System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead);<br>                <span class="hljs-comment">//使用流打印,看看当前的这个 buffer 的 position 和 limit</span><br>                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="hljs-string">&quot;position = &quot;</span> + buffer.position() + <span class="hljs-string">&quot;, limit = &quot;</span> + buffer.limit()).forEach(System.out::println);<br>            &#125;<br><br>            <span class="hljs-comment">//将所有的 buffer 进行 flip</span><br>            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());<br>            <span class="hljs-comment">//将数据读出显示到客户端</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">byteWirte</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (byteWirte &lt; messageLength) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> socketChannel.write(byteBuffers);<span class="hljs-comment">//</span><br>                byteWirte += l;<br>            &#125;<br><br>            <span class="hljs-comment">//将所有的buffer进行clear</span><br>            Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123;<br>                buffer.clear();<br>            &#125;);<br><br>            System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead + <span class="hljs-string">&quot;, byteWrite = &quot;</span> + byteWirte + <span class="hljs-string">&quot;, messagelength = &quot;</span> + messageLength);<br>        &#125;<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h2 id="3-7-Selector（选择器）"><strong>3.7 Selector（选择器）</strong></h2><h3 id="3-7-1-基本介绍"><strong>3.7.1 基本介绍</strong></h3><ol><li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li><li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</li><li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li><li>避免了多线程之间的上下文切换导致的开销。</li></ol><h3 id="3-7-2-Selector-示意图和特点说明"><strong>3.7.2 Selector 示意图和特点说明</strong></h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_10.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_10.png"></p><p>说明如下：</p><ol><li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li><li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li><li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li><li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li><li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li></ol><h3 id="3-7-3-Selector-类相关方法"><strong>3.7.3 Selector 类相关方法</strong></h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_11.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_11.png"></p><h3 id="3-7-4-注意事项"><strong>3.7.4 注意事项</strong></h3><ol><li><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</li><li><code>Selector</code> 相关方法说明<ul><li><code>selector.select();</code> //阻塞</li><li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li><li><code>selector.wakeup();</code> //唤醒 selector</li><li><code>selector.selectNow();</code> //不阻塞，立马返还</li></ul></li></ol><h2 id="3-8-NIO-非阻塞网络编程原理分析图"><strong>3.8 NIO 非阻塞网络编程原理分析图</strong></h2><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_22.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_22.png"></p><p>对上图的说明：</p><ol><li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li><li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li><li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li><li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li><li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li><li>可以通过得到的 <code>channel</code>，完成业务处理。</li><li>代码撑腰。。。</li></ol><h2 id="3-9-NIO-非阻塞网络编程快速入门"><strong>3.9 NIO 非阻塞网络编程快速入门</strong></h2><p>案例要求：</p><ol><li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li><li>看老师代码演示</li></ol><h2 id="3-10-SelectionKey"><strong>3.10 SelectionKey</strong></h2><ol><li><code>SelectionKey</code>，表示 <code>Selector</code> 和网络通道的注册关系，共四种：<ul><li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li><li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li><li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li><li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li></ul></li></ol><p>源码中：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_READ = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_WRITE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_CONNECT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_ACCEPT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-keyword">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><ol><li><code>SelectionKey</code> 相关方法</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_12.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_12.png"></p><h2 id="3-11-ServerSocketChannel"><strong>3.11 ServerSocketChannel</strong></h2><ol><li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接</li><li>相关方法如下</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_13.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_13.png"></p><h2 id="3-12-SocketChannel"><strong>3.12 SocketChannel</strong></h2><ol><li><code>SocketChannel</code>，网络 <code>IO</code> 通道，具体负责进行读写操作。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li><li>相关方法如下</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_14.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_14.png"></p><h2 id="3-13-NIO-网络编程应用实例-群聊系统"><strong>3.13 NIO 网络编程应用实例 - 群聊系统</strong></h2><p>实例要求：</p><ol><li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li><li>示意图分析和代码</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_15.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_15.png"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务端：</span><br><br><span class="hljs-keyword">package</span> com.atguigu.nio.groupchat;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.Channel;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupChatServer</span> &#123;<br><br>    <span class="hljs-comment">//定义属性</span><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> ServerSocketChannel listenChannel;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6667</span>;<br><br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-comment">//初始化工作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GroupChatServer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//得到选择器</span><br>            selector = Selector.open();<br>            <span class="hljs-comment">//ServerSocketChannel</span><br>            listenChannel = ServerSocketChannel.open();<br>            <span class="hljs-comment">//绑定端口</span><br>            listenChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(PORT));<br>            <span class="hljs-comment">//设置非阻塞模式</span><br>            listenChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>            <span class="hljs-comment">//将该 listenChannel 注册到 selector</span><br>            listenChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listen</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//循环处理</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br>                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//有事件处理</span><br>                    <span class="hljs-comment">// 遍历得到 selectionKey 集合</span><br>                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br>                    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                        <span class="hljs-comment">//取出 selectionkey</span><br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                        <span class="hljs-comment">//监听到 accept</span><br>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> listenChannel.accept();<br>                            sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                            <span class="hljs-comment">//将该 sc 注册到 seletor</span><br>                            sc.register(selector, SelectionKey.OP_READ);<br>                            <span class="hljs-comment">//提示</span><br>                            System.out.println(sc.getRemoteAddress() + <span class="hljs-string">&quot; 上线 &quot;</span>);<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<span class="hljs-comment">//通道发送read事件，即通道是可读的状态</span><br>                            <span class="hljs-comment">// 处理读(专门写方法..)</span><br>                            readData(key);<br>                        &#125;<br>                        <span class="hljs-comment">//当前的 key 删除，防止重复处理</span><br>                        iterator.remove();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;等待....&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//发生异常处理....</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//读取客户端消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readData</span><span class="hljs-params">(SelectionKey key)</span> &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//得到 channel</span><br>            channel = (SocketChannel) key.channel();<br>            <span class="hljs-comment">//创建 buffer</span><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>            <span class="hljs-comment">//根据 count 的值做处理</span><br>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//把缓存区的数据转成字符串</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array());<br>                <span class="hljs-comment">//输出该消息</span><br>                System.out.println(<span class="hljs-string">&quot;form客户端:&quot;</span> + msg);<br>                <span class="hljs-comment">//向其它的客户端转发消息(去掉自己),专门写一个方法来处理</span><br>                sendInfoToOtherClients(msg, channel);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(channel.getRemoteAddress() + <span class="hljs-string">&quot;离线了..&quot;</span>);<br>                <span class="hljs-comment">//取消注册</span><br>                key.cancel();<br>                <span class="hljs-comment">//关闭通道</span><br>                channel.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e2) &#123;<br>                e2.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//转发消息给其它客户(通道)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendInfoToOtherClients</span><span class="hljs-params">(String msg, SocketChannel self)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;服务器转发消息中...&quot;</span>);<br>        <span class="hljs-comment">//遍历所有注册到 selector 上的 SocketChannel,并排除 self</span><br>        <span class="hljs-keyword">for</span> (SelectionKey key : selector.keys()) &#123;<br>            <span class="hljs-comment">//通过 key 取出对应的 SocketChannel</span><br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">targetChannel</span> <span class="hljs-operator">=</span> key.channel();<br>            <span class="hljs-comment">//排除自己</span><br>            <span class="hljs-keyword">if</span> (targetChannel <span class="hljs-keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;<br>                <span class="hljs-comment">//转型</span><br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> (SocketChannel) targetChannel;<br>                <span class="hljs-comment">//将 msg 存储到 buffer</span><br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(msg.getBytes());<br>                <span class="hljs-comment">//将 buffer 的数据写入通道</span><br>                dest.write(buffer);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建服务器对象</span><br>        <span class="hljs-type">GroupChatServer</span> <span class="hljs-variable">groupChatServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatServer</span>();<br>        groupChatServer.listen();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端：</span><br><br><span class="hljs-keyword">package</span> com.atguigu.nio.groupchat;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupChatClient</span> &#123;<br><br>    <span class="hljs-comment">//定义相关的属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HOST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<span class="hljs-comment">//服务器的ip</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6667</span>;<span class="hljs-comment">//服务器端口</span><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> SocketChannel socketChannel;<br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-comment">//构造器,完成初始化工作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GroupChatClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        selector = Selector.open();<br>        <span class="hljs-comment">//连接服务器</span><br>        socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(HOST, PORT));<br>        <span class="hljs-comment">//设置非阻塞</span><br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//将 channel 注册到selector</span><br>        socketChannel.register(selector, SelectionKey.OP_READ);<br>        <span class="hljs-comment">//得到 username</span><br>        username = socketChannel.getLocalAddress().toString().substring(<span class="hljs-number">1</span>);<br>        System.out.println(username + <span class="hljs-string">&quot; is ok...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//向服务器发送消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendInfo</span><span class="hljs-params">(String info)</span> &#123;<br>        info = username + <span class="hljs-string">&quot; 说：&quot;</span> + info;<br>        <span class="hljs-keyword">try</span> &#123;<br>            socketChannel.write(ByteBuffer.wrap(info.getBytes()));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//读取从服务器端回复的消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">readChannels</span> <span class="hljs-operator">=</span> selector.select();<br>            <span class="hljs-keyword">if</span> (readChannels &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有可以用的通道</span><br>                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                    <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                        <span class="hljs-comment">//得到相关的通道</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                        <span class="hljs-comment">//得到一个 Buffer</span><br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                        <span class="hljs-comment">//读取</span><br>                        sc.read(buffer);<br>                        <span class="hljs-comment">//把读到的缓冲区的数据转成字符串</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array());<br>                        System.out.println(msg.trim());<br>                    &#125;<br>                &#125;<br>                iterator.remove(); <span class="hljs-comment">//删除当前的 selectionKey,防止重复操作</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//启动我们客户端</span><br>        <span class="hljs-type">GroupChatClient</span> <span class="hljs-variable">chatClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatClient</span>();<br>        <span class="hljs-comment">//启动一个线程,每个 3 秒，读取从服务器发送数据</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    chatClient.readInfo();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-comment">//发送数据给服务器端</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>            chatClient.sendInfo(s);<br>        &#125;<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h2 id="3-14-NIO-与零拷贝"><strong>3.14 NIO 与零拷贝</strong></h2><h3 id="3-14-1-零拷贝基本介绍"><strong>3.14.1 零拷贝基本介绍</strong></h3><ol><li>零拷贝是网络编程的关键，很多性能优化都离不开。</li><li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li><li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li></ol><h3 id="3-14-2-传统-IO-数据读写"><strong>3.14.2 传统 IO 数据读写</strong></h3><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-keyword">file</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br><br><span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">file</span>.length()];<br>raf.<span class="hljs-keyword">read</span>(arr);<br><br>Socket socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>).accept();<br>socket.getOutputStream().<span class="hljs-keyword">write</span>(arr);<span class="hljs-keyword">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h3 id="3-14-3-传统-IO-模型"><strong>3.14.3 传统 IO 模型</strong></h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_17.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_17.png"></p><p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p><h3 id="3-14-4-mmap-优化"><strong>3.14.4 mmap 优化</strong></h3><ol><li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li><li><code>mmap</code> 示意图</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_18.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_18.png"></p><h3 id="3-14-5-sendFile-优化"><strong>3.14.5 sendFile 优化</strong></h3><ol><li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li><li>示意图和小结</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_19.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_19.png"></p><ol><li>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</li><li><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_20.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_20.png"></p><ol><li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li></ol><h3 id="3-14-6-零拷贝的再次理解"><strong>3.14.6 零拷贝的再次理解</strong></h3><ol><li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li><li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li></ol><h3 id="3-14-7-mmap-和-sendFile-的区别"><strong>3.14.7 mmap 和 sendFile 的区别</strong></h3><ol><li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li><li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li><li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li></ol><h3 id="3-14-8-NIO-零拷贝案例"><strong>3.14.8 NIO 零拷贝案例</strong></h3><p>案例要求：</p><ol><li>使用传统的 <code>IO</code> 方法传递一个大文件</li><li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li><li>看看两种传递方式耗时时间分别是多少</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java">NewIOServer.java<br><br><span class="hljs-keyword">package</span> com.atguigu.nio.zerocopy;<br><br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><br><span class="hljs-comment">//服务器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewIOServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">7001</span>);<br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> serverSocketChannel.socket();<br>        serverSocket.bind(address);<br><br>        <span class="hljs-comment">//创建buffer</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4096</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">readcount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (-<span class="hljs-number">1</span> != readcount) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    readcount = socketChannel.read(byteBuffer);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                    <span class="hljs-comment">// ex.printStackTrace();</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//</span><br>                byteBuffer.rewind(); <span class="hljs-comment">//倒带 position = 0 mark 作废</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>NewIOClient.java<br><br><span class="hljs-keyword">package</span> com.atguigu.nio.zerocopy;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewIOClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>        socketChannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">7001</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;protoc-3.6.1-win32.zip&quot;</span>;<br>        <span class="hljs-comment">//得到一个文件channel</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename).getChannel();<br>        <span class="hljs-comment">//准备发送</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">//在 linux 下一个 transferTo 方法就可以完成传输</span><br>        <span class="hljs-comment">//在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要</span><br>        <span class="hljs-comment">//传输时的位置=》课后思考...</span><br>        <span class="hljs-comment">//transferTo 底层使用到零拷贝</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">transferCount</span> <span class="hljs-operator">=</span> fileChannel.transferTo(<span class="hljs-number">0</span>, fileChannel.size(), socketChannel);<br>        System.out.println(<span class="hljs-string">&quot;发送的总的字节数 = &quot;</span> + transferCount + <span class="hljs-string">&quot; 耗时: &quot;</span> + (System.currentTimeMillis() - startTime));<br><br>        <span class="hljs-comment">//关闭</span><br>        fileChannel.close();<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h2 id="3-15-Java-AIO-基本介绍"><strong>3.15 Java AIO 基本介绍</strong></h2><ol><li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li><li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li><li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html"><strong>《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</strong></a></li></ol><h2 id="3-16-BIO、NIO、AIO-对比表"><strong>3.16 BIO、NIO、AIO 对比表</strong></h2><table><thead><tr><th></th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>IO模型</td><td>同步阻塞</td><td>同步非阻塞（多路复用）</td><td>异步非阻塞</td></tr><tr><td>编程难度</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>可靠性</td><td>差</td><td>好</td><td>好</td></tr><tr><td>吞吐量</td><td>低</td><td>高</td><td>高</td></tr></tbody></table><p><strong>举例说明</strong></p><ol><li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li><li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li><li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li></ol><h1><strong>第 4 章 Netty 概述</strong></h1><h2 id="4-1-原生-NIO-存在的问题"><strong>4.1 原生 NIO 存在的问题</strong></h2><ol><li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li><li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li><li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。4. <code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决。</li></ol><h2 id="4-2-Netty-官网说明"><strong>4.2 Netty 官网说明</strong></h2><p>官网：<a href="https://netty.io/"><strong>https://netty.io/</strong></a></p><p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter04/chapter04_01.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter04/chapter04_01.png"></p><h2 id="4-3-Netty-的优点"><strong>4.3 Netty 的优点</strong></h2><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p><ol><li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li><li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li><li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li><li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li><li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li></ol><h2 id="4-4-Netty-版本说明"><strong>4.4 Netty 版本说明</strong></h2><ol><li><code>Netty</code> 版本分为 <code>Netty 3.x</code> 和 <code>Netty 4.x</code>、<code>Netty 5.x</code></li><li>因为 <code>Netty 5</code> 出现重大 <code>bug</code>，已经被官网废弃了，目前推荐使用的是 <code>Netty 4.x</code>的稳定版本</li><li>目前在官网可下载的版本 <code>Netty 3.x</code>、<code>Netty 4.0.x</code> 和 <code>Netty 4.1.x</code></li><li>在本套课程中，我们讲解 <code>Netty4.1.x</code> 版本</li><li><code>Netty</code> 下载地址：<a href="https://bintray.com/netty/downloads/netty/"><strong>https://bintray.com/netty/downloads/netty/</strong></a></li></ol><h1><strong>第 5 章 Netty 高性能架构设计</strong></h1><h2 id="5-1-线程模型基本介绍"><strong>5.1 线程模型基本介绍</strong></h2><ol><li>不同的线程模式，对程序的性能有很大影响，为了搞清 <code>Netty</code> 线程模式，我们来系统的讲解下各个线程模式，最后看看 <code>Netty</code> 线程模型有什么优越性。</li><li>目前存在的线程模型有：传统阻塞 <code>I/O</code> 服务模型 <code>Reactor</code> 模式</li><li>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现单 <code>Reactor</code> 单线程；单 <code>Reactor</code>多线程；主从 <code>Reactor</code>多线程</li><li><code>Netty</code> 线程模式（<code>Netty</code> 主要基于主从 <code>Reactor</code> 多线程模型做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>）</li></ol><h2 id="5-2-传统阻塞-I-O-服务模型"><strong>5.2 传统阻塞 I/O 服务模型</strong></h2><h3 id="5-2-1-工作原理图"><strong>5.2.1 工作原理图</strong></h3><ol><li>黄色的框表示对象，蓝色的框表示线程</li><li>白色的框表示方法（<code>API</code>）</li></ol><h3 id="5-2-2-模型特点"><strong>5.2.2 模型特点</strong></h3><ol><li>采用阻塞 <code>IO</code> 模式获取输入的数据</li><li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li></ol><h3 id="5-2-3-问题分析"><strong>5.2.3 问题分析</strong></h3><ol><li>当并发数很大，就会创建大量的线程，占用很大系统资源</li><li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 <code>read</code> 操作，造成线程资源浪费</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_01.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_01.png"></p><h2 id="5-3-Reactor-模式"><strong>5.3 Reactor 模式</strong></h2><h3 id="5-3-1-针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案："><strong>5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</strong></h3><ol><li>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理 <code>Reactor</code> 对应的叫法：<ol><li>反应器模式</li><li>分发者模式（Dispatcher）</li><li>通知者模式（notifier）</li></ol></li><li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_02.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_02.png"></p><h3 id="5-3-2-I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图"><strong>5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</strong></h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_03.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_03.png"></p><p>对上图说明：</p><ol><li><code>Reactor</code> 模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li><li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 <code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式</li><li><code>Reactor</code> 模式使用 <code>IO</code> 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li></ol><h3 id="5-3-3-Reactor-模式中核心组成"><strong>5.3.3 Reactor 模式中核心组成</strong></h3><ol><li><code>Reactor</code>：<code>Reactor</code> 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 <code>IO</code> 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li><li><code>Handlers</code>：处理程序执行 <code>I/O</code> 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code> 通过调度适当的处理程序来响应 <code>I/O</code> 事件，处理程序执行非阻塞操作。</li></ol><h3 id="5-3-4-Reactor-模式分类"><strong>5.3.4 Reactor 模式分类</strong></h3><p>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现</p><ol><li>单 <code>Reactor</code> 单线程</li><li>单 <code>Reactor</code> 多线程</li><li>主从 <code>Reactor</code> 多线程</li></ol><h2 id="5-4-单-Reactor-单线程"><strong>5.4 单 Reactor 单线程</strong></h2><p>原理图，并使用 <code>NIO</code> 群聊系统验证</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_04.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_04.png"></p><h3 id="5-4-1-方案说明"><strong>5.4.1 方案说明</strong></h3><ol><li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 <code>API</code>，可以实现应用程序通过一个阻塞对象监听多路连接请求</li><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li><li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li><li><code>Handler</code> 会完成 <code>Read</code> → 业务处理 → <code>Send</code> 的完整业务流程</li></ol><p>结合实例：服务器端用一个线程通过多路复用搞定所有的 <code>IO</code> 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 <code>NIO</code> 案例就属于这种模型。</p><h3 id="5-4-2-方案优缺点分析"><strong>5.4.2 方案优缺点分析</strong></h3><ol><li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li><li>缺点：性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li><li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li><li>使用场景：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code> 在业务处理的时间复杂度 <code>O(1)</code> 的情况</li></ol><h2 id="5-5-单-Reactor-多线程"><strong>5.5 单 Reactor 多线程</strong></h2><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_05.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_05.png"></p><h3 id="5-5-1-原理图"><strong>5.5.1 原理图</strong></h3><h3 id="5-5-2-对上图的小结"><strong>5.5.2 对上图的小结</strong></h3><ol><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后，通过 <code>Dispatch</code> 进行分发</li><li>如果建立连接请求，则右 <code>Acceptor</code> 通过 <code>accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理</li><li><code>handler</code> 只负责响应事件，不做具体的业务处理，通过 <code>read</code> 读取数据后，会分发给后面的 <code>worker</code> 线程池的某个线程处理业务</li><li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给 <code>handler</code></li><li><code>handler</code> 收到响应后，通过 <code>send</code> 将结果返回给 <code>client</code></li></ol><h3 id="5-5-3-方案优缺点分析"><strong>5.5.3 方案优缺点分析</strong></h3><ol><li>优点：可以充分的利用多核 <code>cpu</code> 的处理能力</li><li>缺点：多线程数据共享和访问比较复杂，<code>Reactor</code> 处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</li></ol><h2 id="5-6-主从-Reactor-多线程"><strong>5.6 主从 Reactor 多线程</strong></h2><h3 id="5-6-1-工作原理图"><strong>5.6.1 工作原理图</strong></h3><p>针对单 <code>Reactor</code> 多线程模型中，<code>Reactor</code> 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 <code>Reactor</code> 在多线程中运行</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_06.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_06.png"></p><h3 id="5-6-2-上图的方案说明"><strong>5.6.2 上图的方案说明</strong></h3><ol><li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件</li><li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code></li><li><code>subreactor</code> 将连接加入到连接队列进行监听，并创建 <code>handler</code> 进行各种事件处理</li><li>当有新事件发生时，<code>subreactor</code> 就会调用对应的 <code>handler</code> 处理</li><li><code>handler</code> 通过 <code>read</code> 读取数据，分发给后面的 <code>worker</code> 线程处理</li><li><code>worker</code> 线程池分配独立的 <code>worker</code> 线程进行业务处理，并返回结果</li><li><code>handler</code> 收到响应的结果后，再通过 <code>send</code> 将结果返回给 <code>client</code></li><li><code>Reactor</code> 主线程可以对应多个 <code>Reactor</code> 子线程，即 <code>MainRecator</code> 可以关联多个 <code>SubReactor</code></li></ol><h3 id="5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解："><strong>5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解：</strong></h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_07.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_07.png"></p><h3 id="5-6-4-方案优缺点说明"><strong>5.6.4 方案优缺点说明</strong></h3><ol><li>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li><li>优点：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据。</li><li>缺点：编程复杂度较高</li><li>结合实例：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li></ol><h2 id="5-7-Reactor-模式小结"><strong>5.7 Reactor 模式小结</strong></h2><h3 id="5-7-1-3-种模式用生活案例来理解"><strong>5.7.1 3 种模式用生活案例来理解</strong></h3><ol><li>单 <code>Reactor</code> 单线程，前台接待员和服务员是同一个人，全程为顾客服务</li><li>单 <code>Reactor</code> 多线程，<code>1</code> 个前台接待员，多个服务员，接待员只负责接待</li><li>主从 <code>Reactor</code> 多线程，多个前台接待员，多个服务生</li></ol><h3 id="5-7-2-Reactor-模式具有如下的优点"><strong>5.7.2 Reactor 模式具有如下的优点</strong></h3><ol><li>响应快，不必为单个同步时间所阻塞，虽然 <code>Reactor</code> 本身依然是同步的</li><li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li><li>扩展性好，可以方便的通过增加 <code>Reactor</code> 实例个数来充分利用 <code>CPU</code> 资源</li><li>复用性好，<code>Reactor</code> 模型本身与具体事件处理逻辑无关，具有很高的复用性</li></ol><h2 id="5-8-Netty-模型"><strong>5.8 Netty 模型</strong></h2><h3 id="5-8-1-工作原理示意图1-简单版"><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter05?id=_581-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e7%a4%ba%e6%84%8f%e5%9b%be1-%e7%ae%80%e5%8d%95%e7%89%88"><strong>5.8.1 工作原理示意图1 - 简单版</strong></a></h3><p><code>Netty</code> 主要基于主从 <code>Reactors</code> 多线程模型（如图）做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_08.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_08.png"></p><h3 id="5-8-2-对上图说明"><strong>5.8.2 对上图说明</strong></h3><ol><li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code></li><li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护</li><li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 <code>handler</code>），注意 <code>handler</code> 已经加入到通道</li></ol><h3 id="5-8-3-工作原理示意图2-进阶版"><strong>5.8.3 工作原理示意图2 - 进阶版</strong></h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_09.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_09.png"></p><h3 id="5-8-4-工作原理示意图-详细版"><strong>5.8.4 工作原理示意图 - 详细版</strong></h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_10.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_10.png"></p><h3 id="5-8-5-对上图的说明小结"><strong>5.8.5 对上图的说明小结</strong></h3><ol><li><code>Netty</code> 抽象出两组线程池 <code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</li><li><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code></li><li><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code></li><li><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</li><li><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code></li><li>每个 <code>BossNioEventLoop</code> 循环执行的步骤有 <code>3</code> 步<ul><li>轮询 <code>accept</code> 事件</li><li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>worker</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li><li>处理任务队列的任务，即 <code>runAllTasks</code></li></ul></li><li>每个 <code>Worker</code> <code>NIOEventLoop</code> 循环执行的步骤<ul><li>轮询 <code>read</code>，<code>write</code> 事件</li><li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li><li>处理任务队列的任务，即 <code>runAllTasks</code></li></ul></li><li>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器</li></ol><h3 id="5-8-6-Netty-快速入门实例-TCP-服务"><strong>5.8.6 Netty 快速入门实例 - TCP 服务</strong></h3><p>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</p><ol><li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，客户端能发送消息给服务器&quot;hello,服务器~&quot;</li><li>服务器可以回复消息给客户端&quot;hello,客户端~&quot;</li><li>目的：对 <code>Netty</code> 线程模型有一个初步认识，便于理解 <code>Netty</code> 模型理论</li><li>看老师代码演示 5.1 编写服务端 5.2 编写客户端 5.3 对 <code>netty</code> 程序进行分析，看看 <code>netty</code> 模型特点 说明：创建 <code>Maven</code> 项目，并引入 <code>Netty</code> 包</li><li>代码如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><code class="hljs java">NettyServer.java<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.simple;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFutureListener;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<br><span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//创建BossGroup 和 WorkerGroup</span><br>        <span class="hljs-comment">//说明</span><br>        <span class="hljs-comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span><br>        <span class="hljs-comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span><br>        <span class="hljs-comment">//3. 两个都是无限循环</span><br>        <span class="hljs-comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span><br>        <span class="hljs-comment">//   默认实际 cpu核数 * 2</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(); <span class="hljs-comment">//8</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建服务器端的启动对象，配置参数</span><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            <span class="hljs-comment">//使用链式编程来进行设置</span><br>            bootstrap.group(bossGroup, workerGroup) <span class="hljs-comment">//设置两个线程组</span><br>                    .channel(NioServerSocketChannel.class) <span class="hljs-comment">//使用NioSocketChannel 作为服务器的通道实现</span><br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>) <span class="hljs-comment">// 设置线程队列得到连接个数</span><br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>) <span class="hljs-comment">//设置保持活动连接状态</span><br>            <span class="hljs-comment">//          .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span><br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<span class="hljs-comment">//创建一个通道初始化对象(匿名对象)</span><br>                        <span class="hljs-comment">//给pipeline 设置处理器</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            System.out.println(<span class="hljs-string">&quot;客户socketchannel hashcode=&quot;</span> + ch.hashCode()); <span class="hljs-comment">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>());<br>                        &#125;<br>                    &#125;); <span class="hljs-comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span><br><br>            System.out.println(<span class="hljs-string">&quot;.....服务器 is ready...&quot;</span>);<br><br>            <span class="hljs-comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span><br>            <span class="hljs-comment">//启动服务器(并绑定端口)</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">cf</span> <span class="hljs-operator">=</span> bootstrap.bind(<span class="hljs-number">6668</span>).sync();<br><br>            <span class="hljs-comment">//给cf 注册监听器，监控我们关心的事件</span><br><br>            cf.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;监听端口 6668 成功&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;监听端口 6668 失败&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//对关闭通道进行监听</span><br>            cf.channel().closeFuture().sync();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br>NettyServerHandler.java<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.simple;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.Channel;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<br><span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 说明</span><br><span class="hljs-comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span><br><span class="hljs-comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span><br><span class="hljs-comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;服务器读取线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; channle =&quot;</span> + ctx.channel());<br>        System.out.println(<span class="hljs-string">&quot;server ctx =&quot;</span> + ctx);<br>        System.out.println(<span class="hljs-string">&quot;看看channel 和 pipeline的关系&quot;</span>);<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ctx.pipeline(); <span class="hljs-comment">//本质是一个双向链接, 出站入站</span><br><br>        <span class="hljs-comment">//将 msg 转成一个 ByteBuf</span><br>        <span class="hljs-comment">//ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;客户端发送消息是:&quot;</span> + buf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">&quot;客户端地址:&quot;</span> + channel.remoteAddress());<br>    &#125;<br><br>    <span class="hljs-comment">//数据读取完毕</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//writeAndFlush 是 write + flush</span><br>        <span class="hljs-comment">//将数据写入到缓存，并刷新</span><br>        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.close();<br>    &#125;<br>&#125;<br><br>NettyClient.java<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.simple;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//客户端需要一个事件循环组</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">//创建客户端启动对象</span><br>            <span class="hljs-comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span><br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            <span class="hljs-comment">//设置相关参数</span><br>            bootstrap.group(group) <span class="hljs-comment">//设置线程组</span><br>                    .channel(NioSocketChannel.class) <span class="hljs-comment">// 设置客户端通道的实现类(反射)</span><br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientHandler</span>()); <span class="hljs-comment">//加入自己的处理器</span><br>                        &#125;<br>                    &#125;);<br><br>            System.out.println(<span class="hljs-string">&quot;客户端 ok..&quot;</span>);<br>            <span class="hljs-comment">//启动客户端去连接服务器端</span><br>            <span class="hljs-comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6668</span>).sync();<br>            <span class="hljs-comment">//给关闭通道进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br>NettyClientHandler.java<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.simple;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-comment">//当通道就绪就会触发该方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;client &quot;</span> + ctx);<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, server: (&gt;^ω^&lt;)喵&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-comment">//当通道有读取事件时，会触发</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;服务器回复的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">&quot;服务器的地址： &quot;</span> + ctx.channel().remoteAddress());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;Copy to clipboardErrorCopiedCopy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h3 id="5-8-7-任务队列中的-Task-有-3-种典型使用场景"><strong>5.8.7 任务队列中的 Task 有 3 种典型使用场景</strong></h3><ol><li>用户程序自定义的普通任务【举例说明】</li><li>用户自定义定时任务</li><li>非当前 <code>Reactor</code> 线程调用 <code>Channel</code> 的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的 <code>Channel</code> 引用，然后调用 <code>Write</code> 类方法向该用户推送消息，就会进入到这种场景。最终的 <code>Write</code> 会提交到任务队列中后被异步消费</li><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.simple;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 说明</span><br><span class="hljs-comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span><br><span class="hljs-comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span><br><span class="hljs-comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// 比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的</span><br>        <span class="hljs-comment">// NIOEventLoop 的 taskQueue中,</span><br><br>        <span class="hljs-comment">// 解决方案1 用户程序自定义的普通任务</span><br><br>        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);<br>                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;</span>, CharsetUtil.UTF_8));<br>                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);<br>                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵3&quot;</span>, CharsetUtil.UTF_8));<br>                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中</span><br><br>        ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);<br>                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵4&quot;</span>, CharsetUtil.UTF_8));<br>                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br><br>        System.out.println(<span class="hljs-string">&quot;go on ...&quot;</span>);<br><br><span class="hljs-comment">//        System.out.println(&quot;服务器读取线程 &quot; + Thread.currentThread().getName() + &quot; channle =&quot; + ctx.channel());</span><br><span class="hljs-comment">//        System.out.println(&quot;server ctx =&quot; + ctx);</span><br><span class="hljs-comment">//        System.out.println(&quot;看看channel 和 pipeline的关系&quot;);</span><br><span class="hljs-comment">//        Channel channel = ctx.channel();</span><br><span class="hljs-comment">//        ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        //将 msg 转成一个 ByteBuf</span><br><span class="hljs-comment">//        //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span><br><span class="hljs-comment">//        ByteBuf buf = (ByteBuf) msg;</span><br><span class="hljs-comment">//        System.out.println(&quot;客户端发送消息是:&quot; + buf.toString(CharsetUtil.UTF_8));</span><br><span class="hljs-comment">//        System.out.println(&quot;客户端地址:&quot; + channel.remoteAddress());</span><br>    &#125;<br><br>    <span class="hljs-comment">//数据读取完毕</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//writeAndFlush 是 write + flush</span><br>        <span class="hljs-comment">//将数据写入到缓存，并刷新</span><br>        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.close();<br>    &#125;<br>&#125;Copy to clipboardErrorCopiedCopy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h3 id="5-8-8-方案再说明"><strong>5.8.8 方案再说明</strong></h3><ol><li><code>Netty</code> 抽象出两组线程池，<code>BossGroup</code> 专门负责接收客户端连接，<code>WorkerGroup</code> 专门负责网络读写操作。</li><li><code>NioEventLoop</code> 表示一个不断循环执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code>网络通道。</li><li><code>NioEventLoop</code> 内部采用串行化设计，从消息的 <strong>读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</strong>，始终由 <code>IO</code> 线程 <code>NioEventLoop</code> 负责</li></ol><p><code>NioEventLoopGroup</code> 下包含多个 <code>NioEventLoop</code></p><ul><li>每个 <code>NioEventLoop</code> 中包含有一个 <code>Selector</code>，一个 <code>taskQueue</code></li><li>每个 <code>NioEventLoop</code> 的 <code>Selector</code> 上可以注册监听多个 <code>NioChannel</code></li><li>每个 <code>NioChannel</code> 只会绑定在唯一的 <code>NioEventLoop</code> 上</li><li>每个 <code>NioChannel</code> 都绑定有一个自己的 <code>ChannelPipeline</code></li></ul><h2 id="5-9-异步模型"><strong>5.9 异步模型</strong></h2><h3 id="5-9-1-基本介绍"><strong>5.9.1 基本介绍</strong></h3><ol><li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li><li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind、Write、Connect</code> 等操作会简单的返回一个 <code>ChannelFuture</code>。</li><li>调用者并不能立刻获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机制获得 <code>IO</code> 操作结果。</li><li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code> 返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code> 去监控方法 <code>fun</code> 的处理过程（即：<code>Future-Listener</code> 机制）</li></ol><h3 id="5-9-2-Future-说明"><strong>5.9.2 Future 说明</strong></h3><ol><li>表示异步的执行结果,可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</li><li><code>ChannelFuture</code> 是一个接口：<code>public interface ChannelFuture extends Future&lt;Void&gt;</code> 我们可以添加监听器，当监听的事件发生时，就会通知到监听器。案例说明</li></ol><h3 id="5-9-3-工作原理示意图"><strong>5.9.3 工作原理示意图</strong></h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_11.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_11.png"></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_12.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_12.png"></p><p>说明：</p><ol><li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用 <code>future</code> 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。</li><li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。</li></ol><h3 id="5-9-4-Future-Listener-机制"><strong>5.9.4 Future-Listener 机制</strong></h3><ol><li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li><li>常见有如下操作<ul><li>通过 <code>isDone</code> 方法来判断当前操作是否完成；</li><li>通过 <code>isSuccess</code> 方法来判断已完成的当前操作是否成功；</li><li>通过 <code>getCause</code> 方法来获取已完成的当前操作失败的原因；</li><li>通过 <code>isCancelled</code> 方法来判断已完成的当前操作是否被取消；</li><li>通过 <code>addListener</code> 方法来注册监听器，当操作已完成（<code>isDone</code>方法返回完成），将会通知指定的监听器；如果 <code>Future</code> 对象已完成，则通知指定的监听器</li></ul></li></ol><p>举例说明 演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//绑定一个端口并且同步,生成了一个ChannelFuture对象<br>//启动服务器(并绑定端口)<br>ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();<br>//给cf注册监听器，监控我们关心的事件<br>cf.addListener(<span class="hljs-built_in">new</span> ChannelFutureListener() &#123;<br>   @Override<br>   <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> operationComplete (ChannelFuture future) throws <span class="hljs-keyword">Exception</span> &#123;<br>      <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;<br>         <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;监听端口6668成功&quot;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;监听端口6668失败&quot;);<br>      &#125;<br>   &#125;<br>&#125;);<span class="hljs-keyword">Copy</span> <span class="hljs-keyword">to</span> clipboardErrorCopiedCopy <span class="hljs-keyword">to</span> clipboardErrorCopied<br></code></pre></td></tr></table></figure><h2 id="5-10-快速入门实例-HTTP服务"><strong>5.10 快速入门实例 - HTTP服务</strong></h2><ol><li>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</li><li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，浏览器发出请求 <code>http://localhost:6668/</code></li><li>服务器可以回复消息给客户端&quot;Hello!我是服务器5&quot;,并对特定请求资源进行过滤。</li><li>目的：<code>Netty</code> 可以做 <code>Http</code> 服务开发，并且理解 <code>Handler</code> 实例和客户端及其请求的关系。</li><li>看老师代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs java">TestServer.java<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.http;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestServerInitializer</span>());<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">6668</span>).sync();<br><br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br>TestServerInitializer.java<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.http;<br><br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//向管道加入处理器</span><br><br>        <span class="hljs-comment">//得到管道</span><br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br><br>        <span class="hljs-comment">//加入一个netty 提供的httpServerCodec codec =&gt;[coder - decoder]</span><br>        <span class="hljs-comment">//HttpServerCodec 说明</span><br>        <span class="hljs-comment">//1. HttpServerCodec 是netty 提供的处理http的 编-解码器</span><br>        pipeline.addLast(<span class="hljs-string">&quot;MyHttpServerCodec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br>        <span class="hljs-comment">//2. 增加一个自定义的handler</span><br>        pipeline.addLast(<span class="hljs-string">&quot;MyTestHttpServerHandler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestHttpServerHandler</span>());<br><br>        System.out.println(<span class="hljs-string">&quot;ok~~~~&quot;</span>);<br>    &#125;<br>&#125;<br><br>TestHttpServerHandler.java<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.http;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.http.*;<br><span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<br><br><span class="hljs-keyword">import</span> java.net.URI;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 说明</span><br><span class="hljs-comment"> * 1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter</span><br><span class="hljs-comment"> * 2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestHttpServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;HttpObject&gt; &#123;<br><br>    <span class="hljs-comment">//channelRead0 读取客户端数据</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;对应的channel=&quot;</span> + ctx.channel() + <span class="hljs-string">&quot; pipeline=&quot;</span> + ctx<br>                .pipeline() + <span class="hljs-string">&quot; 通过pipeline获取channel&quot;</span> + ctx.pipeline().channel());<br><br>        System.out.println(<span class="hljs-string">&quot;当前ctx的handler=&quot;</span> + ctx.handler());<br><br>        <span class="hljs-comment">//判断 msg 是不是 httprequest请求</span><br>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> HttpRequest) &#123;<br><br>            System.out.println(<span class="hljs-string">&quot;ctx 类型=&quot;</span> + ctx.getClass());<br><br>            System.out.println(<span class="hljs-string">&quot;pipeline hashcode&quot;</span> + ctx.pipeline().hashCode() + <span class="hljs-string">&quot; TestHttpServerHandler hash=&quot;</span> + <span class="hljs-built_in">this</span>.hashCode());<br><br>            System.out.println(<span class="hljs-string">&quot;msg 类型=&quot;</span> + msg.getClass());<br>            System.out.println(<span class="hljs-string">&quot;客户端地址&quot;</span> + ctx.channel().remoteAddress());<br><br>            <span class="hljs-comment">//获取到</span><br>            <span class="hljs-type">HttpRequest</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> (HttpRequest) msg;<br>            <span class="hljs-comment">//获取uri, 过滤指定的资源</span><br>            <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(httpRequest.uri());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;<br>                System.out.println(<span class="hljs-string">&quot;请求了 favicon.ico, 不做响应&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//回复信息给浏览器 [http协议]</span><br><br>            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 我是服务器&quot;</span>, CharsetUtil.UTF_8);<br><br>            <span class="hljs-comment">//构造一个http的相应，即 httpresponse</span><br>            <span class="hljs-type">FullHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);<br><br>            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="hljs-string">&quot;text/plain&quot;</span>);<br>            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());<br><br>            <span class="hljs-comment">//将构建好 response返回</span><br>            ctx.writeAndFlush(response);<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1><strong>第 6 章 Netty 核心模块组件</strong></h1><h2 id="6-1-Bootstrap、ServerBootstrap"><strong>6.1 Bootstrap、ServerBootstrap</strong></h2><ol><li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li><li>常见的方法有<ul><li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li><li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li><li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li><li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li><li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li><li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li><li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li><li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li></ul></li></ol><h2 id="6-2-Future、ChannelFuture"><strong>6.2 Future、ChannelFuture</strong></h2><p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p><p>常见的方法有</p><ul><li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li><li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li></ul><h2 id="6-3-Channel"><strong>6.3 Channel</strong></h2><ol><li><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</li><li>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</li><li>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</li><li><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</li><li>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</li><li>支持关联 <code>I/O</code> 操作与对应的处理程序</li><li>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code> 类型与之对应，常用的 <code>Channel</code> 类型：<ul><li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li><li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li><li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li><li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li><li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li></ul></li></ol><h2 id="6-4-Selector"><strong>6.4 Selector</strong></h2><ol><li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li><li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li></ol><h2 id="6-5-ChannelHandler-及其实现类"><strong>6.5 ChannelHandler 及其实现类</strong></h2><ol><li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li><li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li><li><code>ChannelHandler</code> 及其实现类一览图（后）</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_01.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_01.png"></p><ol><li>我们经常需要自定义一个 <code>Handler</code> 类去继承 <code>ChannelInboundHandlerAdapter</code>，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_02.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_02.png"></p><h2 id="6-6-Pipeline-和-ChannelPipeline"><strong>6.6 Pipeline 和 ChannelPipeline</strong></h2><p><code>ChannelPipeline</code> 是一个重点：</p><ol><li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li><li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li><li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_03.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_03.png"></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_04.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_04.png"></p><ol><li>常用方法 <code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li></ol><h2 id="6-7-ChannelHandlerContext"><strong>6.7 ChannelHandlerContext</strong></h2><ol><li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li><li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</li><li>常用方法<ul><li><code>ChannelFuture close()</code>，关闭通道</li><li><code>ChannelOutboundInvoker flush()</code>，刷新</li><li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到</li><li><code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</li></ul></li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_05.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_05.png"></p><h2 id="6-8-ChannelOption"><strong>6.8 ChannelOption</strong></h2><ol><li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li><li><code>ChannelOption</code> 参数如下：</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_06.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_06.png"></p><h2 id="6-9-EventLoopGroup-和其实现类-NioEventLoopGroup"><strong>6.9 EventLoopGroup 和其实现类 NioEventLoopGroup</strong></h2><ol><li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，<code>Netty</code> 为了更好的利用多核 <code>CPU</code> 资源，一般会有多个 <code>EventLoop</code> 同时工作，每个 <code>EventLoop</code> 维护着一个 <code>Selector</code> 实例。</li><li><code>EventLoopGroup</code> 提供 <code>next</code> 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code> 来处理任务。在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</li><li>通常一个服务端口即一个 <code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和一个 <code>EventLoop</code> 线程。<code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_07.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_07.png"></p><ol><li>常用方法 <code>public NioEventLoopGroup()</code>，构造方法 <code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li></ol><h2 id="6-10-Unpooled-类"><strong>6.10 Unpooled 类</strong></h2><ol><li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li><li>常用方法如下所示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_08.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_08.png"></p><ol><li>举例说明 <code>Unpooled</code> 获取 <code>Netty</code> 的数据容器 <code>ByteBuf</code> 的基本使用【案例演示】</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_09.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_09.png"></p><p>案例 1</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.atguigu.netty.buf;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyByteBuf01</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//创建一个ByteBuf</span><br>        <span class="hljs-comment">//说明</span><br>        <span class="hljs-comment">//1. 创建 对象，该对象包含一个数组arr , 是一个byte[10]</span><br>        <span class="hljs-comment">//2. 在netty 的buffer中，不需要使用flip 进行反转</span><br>        <span class="hljs-comment">//   底层维护了 readerindex 和 writerIndex</span><br>        <span class="hljs-comment">//3. 通过 readerindex 和  writerIndex 和  capacity， 将buffer分成三个区域</span><br>        <span class="hljs-comment">// 0---readerindex 已经读取的区域</span><br>        <span class="hljs-comment">// readerindex---writerIndex ， 可读的区域</span><br>        <span class="hljs-comment">// writerIndex -- capacity, 可写的区域</span><br>        ByteBuf buffer = Unpooled.<span class="hljs-built_in">buffer</span>(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            buffer.<span class="hljs-built_in">writeByte</span>(i);<br>        &#125;<br><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;capacity=&quot;</span> + buffer.<span class="hljs-built_in">capacity</span>());<span class="hljs-comment">//10</span><br>        <span class="hljs-comment">//输出</span><br><span class="hljs-comment">//        for(int i = 0; i&lt;buffer.capacity(); i++) &#123;</span><br><span class="hljs-comment">//            System.out.println(buffer.getByte(i));</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.<span class="hljs-built_in">capacity</span>(); i++) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">readByte</span>());<br>        &#125;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;执行完毕&quot;</span>);<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>案例 2</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> com.atguigu.netty.buf;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> NettyByteBuf02 &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-comment">//创建ByteBuf</span><br>        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello,world!&quot;</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));<br><br>        <span class="hljs-comment">//使用相关的方法</span><br>        <span class="hljs-keyword">if</span> (byteBuf.hasArray()) &#123; <span class="hljs-comment">// true</span><br><br>            <span class="hljs-keyword">byte</span>[] content = byteBuf.array();<br><br>            <span class="hljs-comment">//将 content 转成字符串</span><br>            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));<br><br>            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;byteBuf=&quot;</span> + byteBuf);<br><br>            System.out.<span class="hljs-keyword">println</span>(byteBuf.arrayOffset()); <span class="hljs-comment">// 0</span><br>            System.out.<span class="hljs-keyword">println</span>(byteBuf.readerIndex()); <span class="hljs-comment">// 0</span><br>            System.out.<span class="hljs-keyword">println</span>(byteBuf.writerIndex()); <span class="hljs-comment">// 12</span><br>            System.out.<span class="hljs-keyword">println</span>(byteBuf.capacity()); <span class="hljs-comment">// 36</span><br><br>            <span class="hljs-comment">//System.out.println(byteBuf.readByte()); //</span><br>            System.out.<span class="hljs-keyword">println</span>(byteBuf.getByte(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 104</span><br><br>            <span class="hljs-keyword">int</span> len = byteBuf.readableBytes(); <span class="hljs-comment">//可读的字节数  12</span><br>            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;len=&quot;</span> + len);<br><br>            <span class="hljs-comment">//使用for取出各个字节</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                System.out.<span class="hljs-keyword">println</span>((<span class="hljs-keyword">char</span>) byteBuf.getByte(i));<br>            &#125;<br><br>            <span class="hljs-comment">//按照某个范围读取</span><br>            System.out.<span class="hljs-keyword">println</span>(byteBuf.getCharSequence(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));<br>            System.out.<span class="hljs-keyword">println</span>(byteBuf.getCharSequence(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));<br>        &#125;<br>    &#125;<br>&#125;<span class="hljs-keyword">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h2 id="6-11-Netty-应用实例-群聊系统"><strong>6.11 Netty 应用实例-群聊系统</strong></h2><p>实例要求：</p><ol><li>编写一个 <code>Netty</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>Netty</code> 非阻塞网络编程机制</li><li>看老师代码演示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_10.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_10.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.*;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupChatServer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port; <span class="hljs-comment">//监听端口</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GroupChatServer</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-built_in">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-comment">//编写run方法，处理客户端的请求</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//创建两个线程组</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(); <span class="hljs-comment">//8个NioEventLoop</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>            b.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>                            <span class="hljs-comment">//获取到pipeline</span><br>                            <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                            <span class="hljs-comment">//向pipeline加入解码器</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());<br>                            <span class="hljs-comment">//向pipeline加入编码器</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                            <span class="hljs-comment">//加入自己的业务处理handler</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatServerHandler</span>());<br><br>                        &#125;<br>                    &#125;);<br><br>            System.out.println(<span class="hljs-string">&quot;netty 服务器启动&quot;</span>);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> b.bind(port).sync();<br><br>            <span class="hljs-comment">//监听关闭</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatServer</span>(<span class="hljs-number">7000</span>).run();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<br><br><span class="hljs-keyword">import</span> io.netty.channel.Channel;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><span class="hljs-keyword">import</span> io.netty.channel.group.ChannelGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.group.DefaultChannelGroup;<br><span class="hljs-keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupChatServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-comment">//public static List&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;();</span><br><br>    <span class="hljs-comment">//使用一个hashmap 管理</span><br>    <span class="hljs-comment">//public static Map&lt;String, Channel&gt; channels = new HashMap&lt;String,Channel&gt;();</span><br><br>    <span class="hljs-comment">//定义一个channle 组，管理所有的channel</span><br>    <span class="hljs-comment">//GlobalEventExecutor.INSTANCE) 是全局的事件执行器，是一个单例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ChannelGroup</span> <span class="hljs-variable">channelGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelGroup</span>(GlobalEventExecutor.INSTANCE);<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-comment">//handlerAdded 表示连接建立，一旦连接，第一个被执行</span><br>    <span class="hljs-comment">//将当前channel 加入到  channelGroup</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>        <span class="hljs-comment">//将该客户加入聊天的信息推送给其它在线的客户端</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        该方法会将 channelGroup 中所有的channel 遍历，并发送 消息，</span><br><span class="hljs-comment">        我们不需要自己遍历</span><br><span class="hljs-comment">         */</span><br>        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 加入聊天&quot;</span> + sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date()) + <span class="hljs-string">&quot; \n&quot;</span>);<br>        channelGroup.add(channel);<br><br>    &#125;<br><br>    <span class="hljs-comment">//断开连接, 将xx客户离开信息推送给当前在线的客户</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 离开了\n&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;channelGroup size&quot;</span> + channelGroup.size());<br><br>    &#125;<br><br>    <span class="hljs-comment">//表示channel 处于活动状态, 提示 xx上线</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 上线了~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//表示channel 处于不活动状态, 提示 xx离线了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 离线了~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//读取数据</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//获取到当前channel</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>        <span class="hljs-comment">//这时我们遍历channelGroup, 根据不同的情况，回送不同的消息</span><br><br>        channelGroup.forEach(ch -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (channel != ch) &#123; <span class="hljs-comment">//不是当前的channel,转发消息</span><br>                ch.writeAndFlush(<span class="hljs-string">&quot;[客户]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 发送了消息&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//回显自己发送的消息给自己</span><br>                ch.writeAndFlush(<span class="hljs-string">&quot;[自己]发送了消息&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//关闭通道</span><br>        ctx.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.*;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupChatClient</span> &#123;<br><br>    <span class="hljs-comment">//属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GroupChatClient</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-built_in">this</span>.host = host;<br>        <span class="hljs-built_in">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>                    .group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>                            <span class="hljs-comment">//得到pipeline</span><br>                            <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                            <span class="hljs-comment">//加入相关handler</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());<br>                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                            <span class="hljs-comment">//加入自定义的handler</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatClientHandler</span>());<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(host, port).sync();<br>            <span class="hljs-comment">//得到channel</span><br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFuture.channel();<br>            System.out.println(<span class="hljs-string">&quot;-------&quot;</span> + channel.localAddress() + <span class="hljs-string">&quot;--------&quot;</span>);<br>            <span class="hljs-comment">//客户端需要输入信息，创建一个扫描器</span><br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>                <span class="hljs-comment">//通过channel 发送到服务器端</span><br>                channel.writeAndFlush(msg + <span class="hljs-string">&quot;\r\n&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatClient</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>).run();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<br><br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupChatClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(msg.trim());<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h2 id="6-12-Netty-心跳检测机制案例"><strong>6.12 Netty 心跳检测机制案例</strong></h2><p>实例要求：</p><ol><li>编写一个 <code>Netty</code> 心跳检测机制案例,当服务器超过 <code>3</code> 秒没有读时，就提示读空闲</li><li>当服务器超过 <code>5</code> 秒没有写操作时，就提示写空闲</li><li>实现当服务器超过 <code>7</code> 秒没有读或者写操作时，就提示读写空闲</li><li>代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.heartbeat;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<br><span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;<br><span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;<br><span class="hljs-keyword">import</span> io.netty.handler.timeout.IdleStateHandler;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//创建两个线程组</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(); <span class="hljs-comment">//8个NioEventLoop</span><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>            serverBootstrap.group(bossGroup, workerGroup);<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO));<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                    <span class="hljs-comment">//加入一个netty 提供 IdleStateHandler</span><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                    说明</span><br><span class="hljs-comment">                    1. IdleStateHandler 是netty 提供的处理空闲状态的处理器</span><br><span class="hljs-comment">                    2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span><br><span class="hljs-comment">                    3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span><br><span class="hljs-comment">                    4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                    5. 文档说明</span><br><span class="hljs-comment">                    triggers an &#123;@link IdleStateEvent&#125; when a &#123;@link Channel&#125; has not performed</span><br><span class="hljs-comment"> * read, write, or both operation for a while.</span><br><span class="hljs-comment"> *                  6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个handler去处理</span><br><span class="hljs-comment"> *                  通过调用(触发)下一个handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)</span><br><span class="hljs-comment">                     */</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">7000</span>, <span class="hljs-number">7000</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS));<br>                    <span class="hljs-comment">//加入一个对空闲检测进一步处理的handler(自定义)</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServerHandler</span>());<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//启动服务器</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.heartbeat;<br><br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><span class="hljs-keyword">import</span> io.netty.handler.timeout.IdleStateEvent;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evt 事件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;<br><br>            <span class="hljs-comment">//将  evt 向下转型 IdleStateEvent</span><br>            <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> (IdleStateEvent) evt;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">eventType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">switch</span> (event.state()) &#123;<br>                <span class="hljs-keyword">case</span> READER_IDLE:<br>                    eventType = <span class="hljs-string">&quot;读空闲&quot;</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> WRITER_IDLE:<br>                    eventType = <span class="hljs-string">&quot;写空闲&quot;</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> ALL_IDLE:<br>                    eventType = <span class="hljs-string">&quot;读写空闲&quot;</span>;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot;--超时时间--&quot;</span> + eventType);<br>            System.out.println(<span class="hljs-string">&quot;服务器做相应处理..&quot;</span>);<br><br>            <span class="hljs-comment">//如果发生空闲，我们关闭通道</span><br>            <span class="hljs-comment">// ctx.channel().close();</span><br>        &#125;<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h2 id="6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接"><strong>6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接</strong></h2><p>实例要求：</p><ol><li><code>Http</code> 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。</li><li>要求：实现基于 <code>WebSocket</code> 的长连接的全双工的交互</li><li>改变 <code>Http</code> 协议多次请求的约束，实现长连接了，服务器可以发送消息给浏览器</li><li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li><li>运行界面</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_11.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_11.png"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package com.atguigu.netty.websocket;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<br><span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.codec.http.HttpObjectAggregator;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.codec.http.HttpServerCodec;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.codec.http.websocketx.WebSocketServerProtocolHandler;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.logging.LogLevel;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.logging.LoggingHandler;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.stream.ChunkedWriteHandler;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MyServer &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws <span class="hljs-keyword">Exception</span> &#123;<br><br>        //创建两个线程组<br>        EventLoopGroup bossGroup = <span class="hljs-built_in">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        EventLoopGroup workerGroup = <span class="hljs-built_in">new</span> NioEventLoopGroup(); //<span class="hljs-number">8</span>个NioEventLoop<br>        try &#123;<br><br>            ServerBootstrap serverBootstrap = <span class="hljs-built_in">new</span> ServerBootstrap();<br><br>            serverBootstrap.<span class="hljs-keyword">group</span>(bossGroup, workerGroup);<br>            serverBootstrap.channel(NioServerSocketChannel.<span class="hljs-keyword">class</span>);<br>            serverBootstrap.<span class="hljs-keyword">handler</span>(<span class="hljs-built_in">new</span> LoggingHandler(LogLevel.<span class="hljs-keyword">INFO</span>));<br>            serverBootstrap.childHandler(<span class="hljs-built_in">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br><br>                @Override<br>                protected <span class="hljs-type">void</span> initChannel(SocketChannel ch) throws <span class="hljs-keyword">Exception</span> &#123;<br>                    ChannelPipeline pipeline = ch.pipeline();<br><br>                    //因为基于http协议，使用http的编码和解码器<br>                    pipeline.addLast(<span class="hljs-built_in">new</span> HttpServerCodec());<br>                    //是以块方式写，添加ChunkedWriteHandler处理器<br>                    pipeline.addLast(<span class="hljs-built_in">new</span> ChunkedWriteHandler());<br><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                    说明</span><br><span class="hljs-comment">                    1. http数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span><br><span class="hljs-comment">                    2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span><br><span class="hljs-comment">                     */</span><br>                    pipeline.addLast(<span class="hljs-built_in">new</span> HttpObjectAggregator(<span class="hljs-number">8192</span>));<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                    说明</span><br><span class="hljs-comment">                    1. 对应websocket ，它的数据是以 帧(frame) 形式传递</span><br><span class="hljs-comment">                    2. 可以看到WebSocketFrame 下面有六个子类</span><br><span class="hljs-comment">                    3. 浏览器请求时 ws://localhost:7000/hello 表示请求的uri</span><br><span class="hljs-comment">                    4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws协议 , 保持长连接</span><br><span class="hljs-comment">                    5. 是通过一个 状态码 101</span><br><span class="hljs-comment">                     */</span><br>                    pipeline.addLast(<span class="hljs-built_in">new</span> WebSocketServerProtocolHandler(&quot;/hello2&quot;));<br><br>                    //自定义的<span class="hljs-keyword">handler</span> ，处理业务逻辑<br>                    pipeline.addLast(<span class="hljs-built_in">new</span> MyTextWebSocketFrameHandler());<br>                &#125;<br>            &#125;);<br><br>            //启动服务器<br>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; finally &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br>package com.atguigu.netty.websocket;<br><br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.codec.http.websocketx.TextWebSocketFrame;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br>//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MyTextWebSocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; &#123;<br><br>    @Override<br>    protected <span class="hljs-type">void</span> channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws <span class="hljs-keyword">Exception</span> &#123;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;服务器收到消息 &quot; + msg.text());<br><br>        //回复消息<br>        ctx.channel().writeAndFlush(<span class="hljs-built_in">new</span> TextWebSocketFrame(&quot;服务器时间&quot; + LocalDateTime.now() + &quot; &quot; + msg.text()));<br>    &#125;<br><br>    //当web客户端连接后， 触发方法<br>    @Override<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> handlerAdded(ChannelHandlerContext ctx) throws <span class="hljs-keyword">Exception</span> &#123;<br>        //id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;handlerAdded 被调用&quot; + ctx.channel().id().asLongText());<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;handlerAdded 被调用&quot; + ctx.channel().id().asShortText());<br>    &#125;<br><br>    @Override<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> handlerRemoved(ChannelHandlerContext ctx) throws <span class="hljs-keyword">Exception</span> &#123;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;handlerRemoved 被调用&quot; + ctx.channel().id().asLongText());<br>    &#125;<br><br>    @Override<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws <span class="hljs-keyword">Exception</span> &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;异常发生 &quot; + cause.getMessage());<br>        ctx.<span class="hljs-keyword">close</span>(); //关闭连接<br>    &#125;<br>&#125;<br><br>hello.html<br><br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;&lt;script&gt;var socket;<br>    //判断当前浏览器是否支持websocket<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">window</span>.WebSocket) &#123;<br>        //go <span class="hljs-keyword">on</span><br>        socket = <span class="hljs-built_in">new</span> WebSocket(&quot;ws://localhost:7000/hello2&quot;);<br>        //相当于channelReado, ev 收到服务器端回送的消息<br>        socket.onmessage = <span class="hljs-keyword">function</span> (ev) &#123;<br>            var rt = document.getElementById(&quot;responseText&quot;);<br>            rt.<span class="hljs-keyword">value</span> = rt.<span class="hljs-keyword">value</span> + &quot;\n&quot; + ev.data;<br>        &#125;<br><br>        //相当于连接开启(感知到连接开启)<br>        socket.onopen = <span class="hljs-keyword">function</span> (ev) &#123;<br>            var rt = document.getElementById(&quot;responseText&quot;);<br>            rt.<span class="hljs-keyword">value</span> = &quot;连接开启了..&quot;<br>        &#125;<br><br>        //相当于连接关闭(感知到连接关闭)<br>        socket.onclose = <span class="hljs-keyword">function</span> (ev) &#123;<br><br>            var rt = document.getElementById(&quot;responseText&quot;);<br>            rt.<span class="hljs-keyword">value</span> = rt.<span class="hljs-keyword">value</span> + &quot;\n&quot; + &quot;连接关闭了..&quot;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        alert(&quot;当前浏览器不支持websocket&quot;)<br>    &#125;<br><br>    //发送消息到服务器<br>    <span class="hljs-keyword">function</span> send(message) &#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">window</span>.socket) &#123; //先判断socket是否创建好<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(socket.readyState == WebSocket.<span class="hljs-keyword">OPEN</span>) &#123;<br>            //通过socket 发送消息<br>            socket.send(message)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            alert(&quot;连接没有开启&quot;);<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br>    &lt;form onsubmit=&quot;return false&quot;&gt;<br>        &lt;textarea <span class="hljs-type">name</span>=&quot;message&quot; style=&quot;height: 300px; width: 300px&quot;&gt;&lt;/textarea&gt;<br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;button&quot; <span class="hljs-keyword">value</span>=&quot;发生消息&quot; onclick=&quot;send(this.form.message.value)&quot;&gt;<br>        &lt;textarea id=&quot;responseText&quot; style=&quot;height: 300px; width: 300px&quot;&gt;&lt;/textarea&gt;<br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;button&quot; <span class="hljs-keyword">value</span>=&quot;清空内容&quot; onclick=&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;&gt;<br>    &lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h1><strong>第 7 章 Google Protobuf</strong></h1><h2 id="7-1-编码和解码的基本介绍"><strong>7.1 编码和解码的基本介绍</strong></h2><ol><li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码[示意图]</li><li><code>codec</code>（编解码器）的组成部分有两个：<code>decoder</code>（解码器）和 <code>encoder</code>（编码器）。<code>encoder</code> 负责把业务数据转换成字节码数据，<code>decoder</code> 负责把字节码数据转换成业务数据</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_01.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_01.png"></p><h2 id="7-2-Netty-本身的编码解码的机制和问题分析"><strong>7.2 Netty 本身的编码解码的机制和问题分析</strong></h2><ol><li><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)</li><li><code>Netty</code> 提供的编码器 <code>StringEncoder</code>，对字符串数据进行编码 <code>ObjectEncoder</code>，对Java对象进行编码…</li><li><code>Netty</code> 提供的解码器 <code>StringDecoder</code>,对字符串数据进行解码 <code>ObjectDecoder</code>，对 <code>Java</code> 对象进行解码…</li><li><code>Netty</code> 本身自带的 <code>ObjectDecoder</code> 和 <code>ObjectEncoder</code> 可以用来实现 <code>POJO</code> 对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，存在如下问题<ul><li>无法跨语言</li><li>序列化后的体积太大，是二进制编码的5倍多。</li><li>序列化性能太低</li></ul></li><li>=&gt;引出新的解决方案[<code>Google</code> 的 <code>Protobuf</code>]</li></ol><h2 id="7-3-Protobuf"><strong>7.3 Protobuf</strong></h2><ol><li><code>Protobuf</code> 基本介绍和使用示意图</li><li><code>Protobuf</code> 是 <code>Google</code> 发布的开源项目，全称 <code>Google Protocol Buffers</code>，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 <code>RPC</code> [远程过程调用 <code>remote procedure call</code> ]数据交换格式。目前很多公司 <code>http + json tcp + protobuf</code></li><li>参考文档：<a href="https://developers.google.com/protocol-buffers/docs/proto"><strong>https://developers.google.com/protocol-buffers/docs/proto</strong></a> 语言指南</li><li><code>Protobuf</code> 是以 <code>message</code> 的方式来管理数据的.</li><li>支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的]（支持目前绝大多数语言，例如 <code>C++</code>、<code>C#</code>、<code>Java</code>、<code>python</code> 等）</li><li>高性能，高可靠性</li><li>使用 <code>protobuf</code> 编译器能自动生成代码，<code>Protobuf</code> 是将类的定义使用 <code>.proto</code> 文件进行描述。说明，在 <code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.ptoto</code> 编写插件.可以让语法高亮。</li><li>然后通过 <code>protoc.exe</code> 编译器根据 <code>.proto</code> 自动生成 <code>.java</code> 文件</li><li><code>protobuf</code> 使用示意图</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_02.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_02.png"></p><h2 id="7-4-Protobuf-快速入门实例"><strong>7.4 Protobuf 快速入门实例</strong></h2><p>编写程序，使用 <code>Protobuf</code> 完成如下功能</p><ol><li>客户端可以发送一个 <code>StudentPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li><li>服务端能接收 <code>StudentPoJo</code> 对象，并显示信息(通过 <code>Protobuf</code> 解码)</li><li>具体看老师演示步骤</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Student.proto<br><br><span class="hljs-attribute">syntax</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;proto3&quot;</span><span class="hljs-comment">; //版本</span><br>option java_outer_classname <span class="hljs-operator">=</span> <span class="hljs-string">&quot;StudentPOJO&quot;</span><span class="hljs-comment">;//生成的外部类名，同时也是文件名</span><br>//protobuf 使用message 管理数据<br>message Student &#123; //会在 StudentPOJO 外部类生成一个内部类 Student， 他是真正发送的POJO对象<br>    int32 id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; // Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span><br>    string name <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>&#125;<br><br>编译<br>protoc.exe--java_out<span class="hljs-operator">=</span>.Student.proto<br>将生成的 StudentPOJO 放入到项目使用Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h2 id="7-5-Protobuf-快速入门实例-2"><strong>7.5 Protobuf 快速入门实例 2</strong></h2><ol><li>编写程序，使用 <code>Protobuf</code> 完成如下功能</li><li>客户端可以随机发送 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li><li>服务端能接收 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象(需要判断是哪种类型)，并显示信息(通过 <code>Protobuf</code> 解码)</li><li>具体看老师演示步骤</li></ol><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">Student.proto<br><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> optimize_for = SPEED; <span class="hljs-comment">// 加快解析</span><br><span class="hljs-keyword">option</span> java_package=<span class="hljs-string">&quot;com.atguigu.netty.codec2&quot;</span>;   <span class="hljs-comment">//指定生成到哪个包下</span><br><span class="hljs-keyword">option</span> java_outer_classname=<span class="hljs-string">&quot;MyDataInfo&quot;</span>; <span class="hljs-comment">// 外部类名, 文件名</span><br><br><span class="hljs-comment">//protobuf 可以使用message 管理其他的message</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">MyMessage</span> &#123;<br><br>    <span class="hljs-comment">//定义一个枚举类型</span><br>    <span class="hljs-keyword">enum </span><span class="hljs-title class_">DataType</span> &#123;<br>        StudentType = <span class="hljs-number">0</span>; <span class="hljs-comment">//在proto3 要求enum的编号从0开始</span><br>        WorkerType = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//用data_type 来标识传的是哪一个枚举类型</span><br>    DataType data_type = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//表示每次枚举类型最多只能出现其中的一个, 节省空间</span><br>    <span class="hljs-keyword">oneof</span> dataBody &#123;<br>        Student student = <span class="hljs-number">2</span>;<br>        Worker worker = <span class="hljs-number">3</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int32</span> id = <span class="hljs-number">1</span>;<span class="hljs-comment">//Student类的属性</span><br>    <span class="hljs-type">string</span> name = <span class="hljs-number">2</span>; <span class="hljs-comment">//</span><br>&#125;<br><span class="hljs-keyword">message </span><span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-type">string</span> name=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int32</span> age=<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><strong>第 8 章 Netty 编解码器和 Handler 调用机制</strong></h1><h2 id="8-1-基本说明"><strong>8.1 基本说明</strong></h2><ol><li><code>Netty</code> 的组件设计：<code>Netty</code> 的主要组件有 <code>Channel</code>、<code>EventLoop</code>、<code>ChannelFuture</code>、<code>ChannelHandler</code>、<code>ChannelPipe</code> 等</li><li><code>ChannelHandler</code> 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 <code>ChannelInboundHandler</code> 接口（或 <code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从 <code>ChannelInboundHandler</code> 冲刷数据。业务逻辑通常写在一个或者多个 <code>ChannelInboundHandler</code> 中。<code>ChannelOutboundHandler</code> 原理一样，只不过它是用来处理出站数据的</li><li><code>ChannelPipeline</code> 提供了 <code>ChannelHandler</code> 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 <code>pipeline</code> 中的一系列 <code>ChannelOutboundHandler</code>，并被这些 <code>Handler</code> 处理，反之则称为入站的</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_01.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_01.png"></p><h2 id="8-2编码解码器"><strong>8.2编码解码器</strong></h2><ol><li>当 <code>Netty</code> 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 <code>java</code> 对象）；如果是出站消息，它会被编码成字节。</li><li><code>Netty</code> 提供一系列实用的编解码器，他们都实现了 <code>ChannelInboundHadnler</code> 或者 <code>ChannelOutboundHandler</code> 接口。在这些类中，<code>channelRead</code> 方法已经被重写了。以入站为例，对于每个从入站 <code>Channel</code> 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 <code>decode()</code> 方法进行解码，并将已经解码的字节转发给 <code>ChannelPipeline</code> 中的下一个 <code>ChannelInboundHandler</code>。</li></ol><h2 id="8-3-解码器-ByteToMessageDecoder"><strong>8.3 解码器 - ByteToMessageDecoder</strong></h2><ol><li>关系继承图</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_02.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_02.png"></p><ol><li>由于不可能知道远程节点是否会一次性发送一个完整的信息，<code>tcp</code> 有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理.</li><li>一个关于 <code>ByteToMessageDecoder</code> 实例分析</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_03.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_03.png"></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_04.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_04.png"></p><h2 id="8-4-Netty-的-handler-链的调用机制"><strong>8.4 Netty 的 handler 链的调用机制</strong></h2><p>实例要求:</p><ol><li>使用自定义的编码器和解码器来说明 <code>Netty</code> 的 <code>handler</code> 调用机制 客户端发送 <code>long</code> -&gt; 服务器 服务端发送 <code>long</code> -&gt; 客户端</li><li>案例演示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_05.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_05.png"></p><ol><li>结论<ul><li>不论解码器 <code>handler</code> 还是编码器 <code>handler</code> 即接收的消息类型必须与待处理的消息类型一致，否则该 <code>handler</code> 不会被执行</li><li>在解码器进行数据解码时，需要判断缓存区（<code>ByteBuf</code>）的数据是否足够，否则接收到的结果会期望结果可能不一致</li></ul></li></ol><h2 id="8-5-解码器-ReplayingDecoder"><strong>8.5 解码器 - ReplayingDecoder</strong></h2><ol><li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></li><li><code>ReplayingDecoder</code> 扩展了 <code>ByteToMessageDecoder</code> 类，使用这个类，我们不必调用 <code>readableBytes()</code> 方法。参数 <code>S</code> 指定了用户状态管理的类型，其中 <code>Void</code> 代表不需要状态管理</li><li>应用实例：使用 <code>ReplayingDecoder</code> 编写解码器，对前面的案例进行简化[案例演示]</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.<span class="hljs-type">ByteBuf</span>;<br><span class="hljs-keyword">import</span> io.netty.channel.<span class="hljs-type">ChannelHandlerContext</span>;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.<span class="hljs-type">ReplayingDecoder</span>;<br><br><span class="hljs-keyword">import</span> java.util.<span class="hljs-type">List</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyByteToLongDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder&lt;Void&gt;</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void decode(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">ByteBuf</span> in, <span class="hljs-type">List</span>&lt;<span class="hljs-type">Object</span>&gt; out) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;MyByteToLongDecoder2 被调用&quot;</span>);<br>        <span class="hljs-comment">//在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断</span><br>        out.add(in.readLong());<br>    &#125;<br>&#125;<span class="hljs-type">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><ol><li><code>ReplayingDecoder</code> 使用方便，但它也有一些局限性：<ul><li>并不是所有的 <code>ByteBuf</code> 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>。</li><li><code>ReplayingDecoder</code> 在某些情况下可能稍慢于 <code>ByteToMessageDecoder</code>，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li></ul></li></ol><h2 id="8-6-其它编解码器"><strong>8.6 其它编解码器</strong></h2><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_06.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_06.png"></p><h3 id="8-6-1-其它解码器"><strong>8.6.1 其它解码器</strong></h3><ol><li><code>LineBasedFrameDecoder</code>：这个类在 <code>Netty</code> 内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</li><li><code>DelimiterBasedFrameDecoder</code>：使用自定义的特殊字符作为消息的分隔符。</li><li><code>HttpObjectDecoder</code>：一个 <code>HTTP</code> 数据的解码器</li><li><code>LengthFieldBasedFrameDecoder</code>：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li></ol><h3 id="8-6-2-其它编码器"><strong>8.6.2 其它编码器</strong></h3><h2 id="8-7-Log4j-整合到-Netty"><strong>8.7 Log4j 整合到 Netty</strong></h2><ol><li>在 <code>Maven</code> 中添加对 <code>Log4j</code> 的依赖在 <code>pom.xml</code></li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span>Copy <span class="hljs-keyword">to</span> clipboardErrorCopied<br></code></pre></td></tr></table></figure><ol><li>配置 <code>Log4j</code>，在 <code>resources/log4j.properties</code></li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">log4j.rootLogger</span>=DEBUG,stdout<br><span class="hljs-attr">log4j.appender.stdout</span>=org.apache.log4j.ConsoleAppender<br><span class="hljs-attr">log4j.appender.stdout.layout</span>=org.apache.log4j.PatternLayout<br><span class="hljs-attr">log4j.appender.stdout.layout.ConversionPattern</span>=[%p]%C&#123;<span class="hljs-number">1</span>&#125;-%m%nCopy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><ol><li>演示整合</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_07.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_07.png"></p><h1><strong>第 9 章 TCP 粘包和拆包及解决方案</strong></h1><h2 id="9-1-TCP-粘包和拆包基本介绍"><strong>9.1 TCP 粘包和拆包基本介绍</strong></h2><ol><li><code>TCP</code> 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 <code>socket</code>，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（<code>Nagle</code> 算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的</li><li>由于 <code>TCP</code> 无消息保护边界,需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题,看一张图</li><li>示意图 <code>TCP</code> 粘包、拆包图解</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter09/chapter09_01.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter09/chapter09_01.png"></p><p>对图的说明: 假设客户端分别发送了两个数据包 <code>D1</code> 和 <code>D2</code> 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p><ol><li>服务端分两次读取到了两个独立的数据包，分别是 <code>D1</code> 和 <code>D2</code>，没有粘包和拆包</li><li>服务端一次接受到了两个数据包，<code>D1</code> 和 <code>D2</code> 粘合在一起，称之为 <code>TCP</code> 粘包</li><li>服务端分两次读取到了数据包，第一次读取到了完整的 <code>D1</code> 包和 <code>D2</code> 包的部分内容，第二次读取到了 <code>D2</code> 包的剩余内容，这称之为 <code>TCP</code> 拆包</li><li>服务端分两次读取到了数据包，第一次读取到了 <code>D1</code> 包的部分内容 <code>D1_1</code>，第二次读取到了 <code>D1</code> 包的剩余部分内容 <code>D1_2</code> 和完整的 <code>D2</code> 包。</li></ol><h2 id="9-2-TCP-粘包和拆包现象实例"><strong>9.2 TCP 粘包和拆包现象实例</strong></h2><p>在编写 <code>Netty</code> 程序时，如果没有做处理，就会发生粘包和拆包的问题</p><p>看一个具体的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心代码</span><br><br>MyClientHandler.java<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.tcp;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//使用客户端发送10条数据 hello,server 编号</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello,server &quot;</span> + i, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));<br>            ctx.writeAndFlush(buffer);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[msg.readableBytes()];<br>        msg.readBytes(buffer);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;客户端接收到消息=&quot;</span> + message);<br>        System.out.println(<span class="hljs-string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="hljs-built_in">this</span>.count));<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br><br>MyServerHandler.java<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.tcp;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><span class="hljs-keyword">import</span> java.util.UUID;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//cause.printStackTrace();</span><br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[msg.readableBytes()];<br>        msg.readBytes(buffer);<br><br>        <span class="hljs-comment">//将buffer转成字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;服务器接收到数据 &quot;</span> + message);<br>        System.out.println(<span class="hljs-string">&quot;服务器接收到消息量=&quot;</span> + (++<span class="hljs-built_in">this</span>.count));<br><br>        <span class="hljs-comment">//服务器回送数据给客户端, 回送一个随机id ,</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">responseByteBuf</span> <span class="hljs-operator">=</span> Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="hljs-string">&quot; &quot;</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));<br>        ctx.writeAndFlush(responseByteBuf);<br><br>    &#125;<br>&#125;<br><br>Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h2 id="9-3-TCP-粘包和拆包解决方案"><strong>9.3 TCP 粘包和拆包解决方案</strong></h2><ol><li>使用自定义协议+编解码器来解决</li><li>关键就是要解决服务器端每次读取数据长度的问题，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 <code>TCP</code> 粘包、拆包。</li></ol><h2 id="9-4-看一个具体的实例"><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter09?id=_94-%e7%9c%8b%e4%b8%80%e4%b8%aa%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e4%be%8b"><strong>9.4 看一个具体的实例</strong></a></h2><ol><li>要求客户端发送 <code>5</code> 个 <code>Message</code> 对象，客户端每次发送一个 <code>Message</code> 对象</li><li>服务器端每次接收一个 <code>Message</code>，分 <code>5</code> 次进行解码，每读取到一个 <code>Message</code>，会回复一个 <code>Message</code> 对象给客户端。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter09/chapter09_02.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter09/chapter09_02.png"></p><ol><li>代码演示，全部代码核心</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心</span><br><br><span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<br><br><span class="hljs-comment">//协议包</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageProtocol</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> len; <span class="hljs-comment">//关键</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] content;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLen</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLen</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>        <span class="hljs-built_in">this</span>.len = len;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getContent() &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.content = content;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<br><br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;MessageProtocol&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//使用客户端发送10条数据 &quot;今天天气冷，吃火锅&quot; 编号</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">mes</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;今天天气冷，吃火锅&quot;</span>;<br>            <span class="hljs-type">byte</span>[] content = mes.getBytes(Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> mes.getBytes(Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)).length;<br><br>            <span class="hljs-comment">//创建协议包对象</span><br>            <span class="hljs-type">MessageProtocol</span> <span class="hljs-variable">messageProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageProtocol</span>();<br>            messageProtocol.setLen(length);<br>            messageProtocol.setContent(content);<br>            ctx.writeAndFlush(messageProtocol);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//    @Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> msg.getLen();<br>        <span class="hljs-type">byte</span>[] content = msg.getContent();<br><br>        System.out.println(<span class="hljs-string">&quot;客户端接收到消息如下&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + len);<br>        System.out.println(<span class="hljs-string">&quot;内容=&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));<br><br>        System.out.println(<span class="hljs-string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="hljs-built_in">this</span>.count));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;异常消息=&quot;</span> + cause.getMessage());<br>        ctx.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMessageEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MessageToByteEncoder</span>&lt;MessageProtocol&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyMessageEncoder encode 方法被调用&quot;</span>);<br>        out.writeInt(msg.getLen());<br>        out.writeBytes(msg.getContent());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReplayingDecoder</span>&lt;Void&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyMessageDecoder decode 被调用&quot;</span>);<br>        <span class="hljs-comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> in.readInt();<br><br>        <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>        in.readBytes(content);<br><br>        <span class="hljs-comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span><br>        <span class="hljs-type">MessageProtocol</span> <span class="hljs-variable">messageProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageProtocol</span>();<br>        messageProtocol.setLen(length);<br>        messageProtocol.setContent(content);<br>        out.add(messageProtocol);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<br><br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><span class="hljs-keyword">import</span> java.util.UUID;<br><br><span class="hljs-comment">//处理业务的handler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;MessageProtocol&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//cause.printStackTrace();</span><br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//接收到数据，并处理</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> msg.getLen();<br>        <span class="hljs-type">byte</span>[] content = msg.getContent();<br><br>        System.out.println();<br>        System.out.println();<br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;服务器接收到信息如下&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + len);<br>        System.out.println(<span class="hljs-string">&quot;内容=&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));<br><br>        System.out.println(<span class="hljs-string">&quot;服务器接收到消息包数量=&quot;</span> + (++<span class="hljs-built_in">this</span>.count));<br><br>        <span class="hljs-comment">//回复消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">responseContent</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">responseLen</span> <span class="hljs-operator">=</span> responseContent.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>).length;<br>        <span class="hljs-type">byte</span>[] responseContent2 = responseContent.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <span class="hljs-comment">//构建一个协议包</span><br>        <span class="hljs-type">MessageProtocol</span> <span class="hljs-variable">messageProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageProtocol</span>();<br>        messageProtocol.setLen(responseLen);<br>        messageProtocol.setContent(responseContent2);<br><br>        ctx.writeAndFlush(messageProtocol);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1><strong>第 10 章 Netty 核心源码剖析</strong></h1><h2 id="10-1-基本说明"><strong>10.1 基本说明</strong></h2><ol><li>只有看过 <code>Netty</code> 源码，才能说是真的掌握了 <code>Netty</code> 框架。</li><li>在 <code>io.netty.example</code> 包下，有很多 <code>Netty</code> 源码案例，可以用来分析。</li><li>源码分析章节是针对有 <code>Java</code> 项目经验，并且玩过框架源码的人员讲的，否则你听起来会有相当的难度。</li></ol><h2 id="10-2-Netty-启动过程源码剖析"><strong>10.2 Netty 启动过程源码剖析</strong></h2><h3 id="10-2-1-源码剖析目的"><strong>10.2.1 源码剖析目的</strong></h3><p>用源码分析的方式走一下 <code>Netty</code>（服务器）的启动过程，更好的理解 <code>Netty</code> 的整体设计和运行机制。</p><h3 id="10-2-2-源码剖析"><strong>10.2.2 源码剖析</strong></h3><p>说明：</p><ol><li>源码需要剖析到 <code>Netty</code> 调用 <code>doBind</code> 方法，追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>。</li><li>并且要 <code>Debug</code> 程序到 <code>NioEventLoop</code> 类的 <code>run</code> 代码，无限循环，在服务器端运行。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_01.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_01.png"></p><h3 id="10-2-3-源码剖析过程"><strong>10.2.3 源码剖析过程</strong></h3><p><strong>1. <code>demo</code> 源码的基本理解</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 服务器启动类源码</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright 2012 The Netty Project</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The Netty Project licenses this file to you under the Apache License,</span><br><span class="hljs-comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span><br><span class="hljs-comment"> * with the License. You may obtain a copy of the License at:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span><br><span class="hljs-comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span><br><span class="hljs-comment"> * License for the specific language governing permissions and limitations</span><br><span class="hljs-comment"> * under the License.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">package</span> atguigu.netty.example.echo2;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<br><span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.logging.LogLevel;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.logging.LoggingHandler;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.ssl.SslContext;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.ssl.SslContextBuilder;<br><span class="hljs-keyword">import</span> io.netty.<span class="hljs-keyword">handler</span>.ssl.util.SelfSignedCertificate;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Echoes back any received data from a client.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> SSL = System.getProperty(<span class="hljs-string">&quot;ssl&quot;</span>) != <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>));<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// Configure SSL.</span><br>        <span class="hljs-keyword">final</span> SslContext sslCtx;<br>        <span class="hljs-keyword">if</span> (SSL) &#123;<br>            SelfSignedCertificate ssc = <span class="hljs-keyword">new</span> SelfSignedCertificate();<br>            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sslCtx = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Configure the server.</span><br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            b.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)<br>                    .<span class="hljs-keyword">handler</span>(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ChannelPipeline p = ch.pipeline();<br>                            <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;<br>                                p.addLast(sslCtx.newHandler(ch.alloc()));<br>                            &#125;<br>                            <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span><br>                            p.addLast(<span class="hljs-keyword">new</span> EchoServerHandler());<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-comment">// Start the server.</span><br>            ChannelFuture f = b.bind(PORT).sync();<br><br>            <span class="hljs-comment">// Wait until the server socket is closed.</span><br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Shut down all event loops to terminate all threads.</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：</p><ol><li>先看启动类：<code>main</code> 方法中，首先创建了关于 SSL 的配置类。</li><li>重点分析下创建了两个 <code>EventLoopGroup</code> 对象：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">EventLoopGroup bossGroup <span class="hljs-operator">=</span> new NioEventLoopGroup(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>EventLoopGroup workerGroup <span class="hljs-operator">=</span> new NioEventLoopGroup()<span class="hljs-comment">;Copy to clipboardErrorCopied</span><br></code></pre></td></tr></table></figure><p>(1) 这两个对象是整个 <code>Netty</code> 的核心对象，可以说，整个 <code>Netty</code> 的运作都依赖于他们。<code>bossGroup</code> 用于接受 <code>TCP</code> 请求，他会将请求交给 <code>workerGroup</code>，<code>workerGroup</code> 会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作。</p><p>(2) <code>EventLoopGroup</code> 是事件循环组（线程组）含有多个 <code>EventLoop</code>，可以注册 <code>channel</code>，用于在事件循环中去进行选择（和选择器相关）。【debug看】</p><p>(3) <code>new NioEventLoopGroup(1);</code> 这个 <code>1</code> 表示 <code>bossGroup</code> 事件组有 <code>1</code> 个线程你可以指定，如果 <code>new NioEventLoopGroup()</code> 会含有默认个线程 <code>cpu核数 * 2</code>，即可以充分的利用多核的优势，【可以dubug一把】</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DEFAULT_EVENT_LOOP_THREADS</span> = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>))<span class="hljs-comment">;Copy to clipboardErrorCopied</span><br></code></pre></td></tr></table></figure><p>会创建 <code>EventExecutor</code> 数组 <code>children = new EventExecutor[nThreads];</code> // <code>debug</code> 一下每个元素的类型就是 <code>NIOEventLoop</code>，<code>NIOEventLoop</code> 实现了 <code>EventLoop</code> 接口和 <code>Executor</code> 接口 <code>try</code> 块中创建了一个 <code>ServerBootstrap</code> 对象，他是一个引导类，用于启动服务器和引导整个程序的初始化（看下源码 <code>allowseasybootstrapof&#123;@linkServerChannel&#125;</code>）。它和 <code>ServerChannel</code> 关联，而 <code>ServerChannel</code> 继承了 <code>Channel</code>，有一些方法 <code>remoteAddress</code> 等[可以Debug下]随后，变量 <code>b</code> 调用了 <code>group</code> 方法将两个 <code>group</code> 放入了自己的字段中，用于后期引导使用【<code>debug</code> 下 <code>group</code> 方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *Set the &#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125; for the parent (acceptor) and the child (client) . These</span><br><span class="hljs-comment"> *&#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125;&#x27;s are used to handle all the events and IO for &#123;<span class="hljs-doctag">@link</span> ServerChannel&#125; and</span><br><span class="hljs-comment"> *&#123;<span class="hljs-doctag">@link</span> Channel&#125;&#x27;s.</span><br><span class="hljs-comment"> */</span>Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>】。</p><p>(4) 然后添加了一个 <code>channel</code>，其中参数一个 <code>Class</code> 对象，引导类将通过这个 <code>Class</code> 对象反射创建 <code>ChannelFactory</code>。然后添加了一些 <code>TCP</code> 的参数。【说明：<code>Channel</code> 的创建在 <code>bind</code> 方法，可以 <code>Debug</code> 下 <code>bind</code>，会找到 <code>channel = channelFactory.newChannel();</code> 】</p><p>(5) 再添加了一个服务器专属的日志处理器 <code>handler</code> 。</p><p>(6) 再添加一个 <code>SocketChannel</code>（不是 <code>ServerSocketChannel</code>）的 <code>handler</code>。</p><p>(7) 然后绑定端口并阻塞至连接成功。</p><p>(8) 最后 <code>main</code> 线程阻塞等待关闭。</p><p>(9) <code>finally</code> 块中的代码将在服务器关闭时优雅关闭所有资源。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright 2012 The Netty Project</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The Netty Project licenses this file to you under the Apache License,</span><br><span class="hljs-comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span><br><span class="hljs-comment"> * with the License. You may obtain a copy of the License at:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span><br><span class="hljs-comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span><br><span class="hljs-comment"> * License for the specific language governing permissions and limitations</span><br><span class="hljs-comment"> * under the License.</span><br><span class="hljs-comment"> */</span><br>package atguigu.<span class="hljs-property">netty</span>.<span class="hljs-property">example</span>.<span class="hljs-property">echo2</span>;<br><br><span class="hljs-keyword">import</span> io.<span class="hljs-property">netty</span>.<span class="hljs-property">channel</span>.<span class="hljs-property">ChannelHandler</span>.<span class="hljs-property">Sharable</span>;<br><span class="hljs-keyword">import</span> io.<span class="hljs-property">netty</span>.<span class="hljs-property">channel</span>.<span class="hljs-property">ChannelHandlerContext</span>;<br><span class="hljs-keyword">import</span> io.<span class="hljs-property">netty</span>.<span class="hljs-property">channel</span>.<span class="hljs-property">ChannelInboundHandlerAdapter</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Handler implementation for the echo server.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">channelRead</span>(<span class="hljs-params">ChannelHandlerContext ctx, <span class="hljs-built_in">Object</span> msg</span>) &#123;<br>        ctx.<span class="hljs-title function_">write</span>(msg);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">channelReadComplete</span>(<span class="hljs-params">ChannelHandlerContext ctx</span>) &#123;<br>        ctx.<span class="hljs-title function_">flush</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">exceptionCaught</span>(<span class="hljs-params">ChannelHandlerContext ctx, Throwable cause</span>) &#123;<br>        <span class="hljs-comment">// Close the connection when an exception is raised.</span><br>        cause.<span class="hljs-title function_">printStackTrace</span>();<br>        ctx.<span class="hljs-title function_">close</span>();<br>    &#125;<br>&#125;<br><span class="hljs-title class_">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明:</p><ol><li>这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端。</li><li>大致讲解了我们的 <code>demo</code> 源码的作用。后面的 <code>debug</code> 的时候会详细。</li></ol><p><strong>2. 分析 EventLoopGroup 的过程</strong></p><p>2.1 构造器方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(nThreads, (Executor) <span class="hljs-keyword">null</span>);<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>2.2 上面的 <code>this(nThreads, (Executor) null);</code> 调用构造器（通过 <code>alt + d</code> 看即可）</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(nThreads, executor, SelectorProvider.provider());<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>2.3 上面的 <code>this(nThreads, executor, SelectorProvider.provider());</code> 调用下面构造器</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(nThreads, executor, selectorProvider,DefaultSelectStrategyFactory.INSTANCE);<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>2.4 上面的 <code>this()...</code> 调用构造器（<code>alt + d</code>）</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider,<span class="hljs-keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>2.5 上面的 <code>super()..</code> 的方法是父类：<code>MultithreadEventLoopGroup</code></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, Object...args)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>2.6 追踪到源码抽象类 <code>MultithreadEventExecutorGroup</code> 的构造器方法 <code>MultithreadEventExecutorGroup</code> 才是 <code>NioEventLoopGroup</code> 真正的构造方法，这里可以看成是一个模板方法，使用了设计模式的模板模式（可看我录制视频），所以，我们就需要好好分析 <code>MultithreadEventExecutorGroup</code> 方法了</p><p>2.7 分析 <code>MultithreadEventExecutorGroup</code></p><p>参数说明：</p><ul><li><code>@param nThreads</code> 使用的线程数，默认为 <code>core * 2</code>【可以追踪源码】</li><li><code>@param executor</code> 执行器:如果传入 <code>null</code>, 则采用 <code>Netty</code> 默认的线程工厂和默认的执行器 <code>ThreadPerTaskExecutor</code></li><li><code>@param chooserFactory</code> 单例 <code>new DefaultEventExecutorChooserFactory()</code></li><li><code>@param args args</code> 在创建执行器的时候传入固定参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor,</span><br><span class="hljs-params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nThreads &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(String.format(<span class="hljs-string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果传入的执行器是空的则采用默认的线程工厂和默认的执行器</span><br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());<br>    &#125;<br><br>    <span class="hljs-comment">// 创建指定线程数的执行器数组</span><br>    children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventExecutor</span>[nThreads];<br><br>    <span class="hljs-comment">// 初始化线程数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建 new NioEventLoop</span><br>            children[i] = newChild(executor, args);<br>            success = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 如果创建失败，优雅关闭</span><br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                    children[j].shutdownGracefully();<br>                &#125;<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> children[j];<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;<br>                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;<br>                        <span class="hljs-comment">// Let the caller handle the interruption.</span><br>                        Thread.currentThread().interrupt();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    chooser = chooserFactory.newChooser(children);<br><br>    <span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureListener</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;<br>                terminationFuture.setSuccess(<span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 为每一个单例线程池添加一个关闭监听器</span><br>    <span class="hljs-keyword">for</span> (EventExecutor e: children) &#123;<br>        e.terminationFuture().addListener(terminationListener);<br>    &#125;<br><br>    Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);<br>    <span class="hljs-comment">//将所有的单例线程池添加到一个 HashSet 中。</span><br>    Collections.addAll(childrenSet, children);<br>    readonlyChildren = Collections.unmodifiableSet(childrenSet);<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：</p><ol><li>如果 <code>executor</code> 是 <code>null</code>，创建一个默认的 <code>ThreadPerTaskExecutor</code>，使用 <code>Netty</code> 默认的线程工厂。</li><li>根据传入的线程数（<code>CPU * 2</code>）创建一个线程池（单例线程池）数组。</li><li>循环填充数组中的元素。如果异常，则关闭所有的单例线程池。</li><li>根据线程选择工厂创建一个线程选择器。</li><li>为每一个单例线程池添加一个关闭监听器。</li><li>将所有的单例线程池添加到一个 <code>HashSet</code> 中。</li></ol><p><strong>3. ServerBootstrap 创建和构造过程</strong></p><p>3.1 <code>ServerBootstrap</code> 是个空构造，但是有默认的成员变量</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, <span class="hljs-built_in">Object</span>&gt; childOptions = <span class="hljs-keyword">new </span><span class="hljs-class title_">LinkedHashMap</span>&lt;ChannelOption&lt;?&gt;, <span class="hljs-built_in">Object</span>&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, <span class="hljs-built_in">Object</span>&gt; childAttrs = <span class="hljs-keyword">new </span><span class="hljs-class title_">ConcurrentHashMap</span>&lt;AttributeKey&lt;?&gt;, <span class="hljs-built_in">Object</span>&gt;();<br><br><span class="hljs-comment">// config 对象，会在后面起很大作用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerBootstrapConfig config = <span class="hljs-keyword">new </span><span class="hljs-class title_">ServerBootstrapConfig</span>(<span class="hljs-variable">this</span>);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> EventLoopGroup childGroup;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ChannelHandler childHandler;<br>Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>3.2 分析一下 <code>ServerBootstrap</code> 基本使用情况</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ServerBootstrap b = <span class="hljs-built_in">new</span> ServerBootstrap();<br>b.<span class="hljs-keyword">group</span>(bossGroup, workerGroup)<br>        .channel(NioServerSocketChannel.<span class="hljs-keyword">class</span>)<br>        .<span class="hljs-keyword">option</span>(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)<br>        .<span class="hljs-keyword">handler</span>(<span class="hljs-built_in">new</span> LoggingHandler(LogLevel.<span class="hljs-keyword">INFO</span>))<br>        .childHandler(<span class="hljs-built_in">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>            @Override<br>            <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> initChannel(SocketChannel ch) throws <span class="hljs-keyword">Exception</span> &#123;<br>                ChannelPipeline p = ch.pipeline();<br>                <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;<br>                    p.addLast(sslCtx.newHandler(ch.alloc()));<br>                &#125;<br>                //p.addLast(<span class="hljs-built_in">new</span> LoggingHandler(LogLevel.<span class="hljs-keyword">INFO</span>));<br>                p.addLast(<span class="hljs-built_in">new</span> EchoServerHandler());<br>            &#125;<br>        &#125;);<br><span class="hljs-keyword">Copy</span> <span class="hljs-keyword">to</span> clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明:</p><ol><li>链式调用：<code>group</code> 方法，将 <code>boss</code> 和 <code>worker</code> 传入，<code>boss</code> 赋值给 <code>parentGroup</code> 属性, <code>worker</code> 赋值给 <code>childGroup</code> 属性。</li><li><code>channel</code> 方法传入 <code>NioServerSocketChannelclass</code> 对象。会根据这个 <code>class</code> 创建 <code>channel</code> 对象。</li><li><code>option</code> 方法传入 <code>TCP</code> 参数，放在一个 <code>LinkedHashMap</code> 中。</li><li><code>handler</code> 方法传入一个 <code>handler</code> 中，这个 <code>hanlder</code> 只专属于 <code>ServerSocketChannel</code> 而不是 <code>SocketChannel</code>。</li><li><code>childHandler</code> 传入一个 <code>hanlder</code>，这个 <code>handler</code> 将会在每个客户端连接的时候调用。供 <code>SocketChannel</code> 使用。</li></ol><p><strong>4. 绑定端口的分析</strong></p><p>4.1 服务器就是在这个 <code>bind</code> 方法里启动完成的 4.2 <code>bind</code> 方法代码,追踪到创建了一个端口对象，并做了一些空判断，核心代码 <code>doBind</code>，我们看看</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">public ChannelFuture <span class="hljs-built_in">bind</span>(SocketAddress localAddress) &#123;<br>    <span class="hljs-built_in">validate</span>();<br>    if (localAddress == null) &#123;<br>        throw new <span class="hljs-built_in">NullPointerException</span>(&quot;localAddress&quot;);<br>    &#125;<br>    return <span class="hljs-built_in">doBind</span>(localAddress);<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>4.3 <code>doBind</code> 源码剖析，核心是两个方法 <code>initAndRegister</code> 和 <code>doBind0</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title function_">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> initAndRegister();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> regFuture.channel();<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> regFuture;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;<br>        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span><br>        <span class="hljs-type">ChannelPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> channel.newPromise();<br>        <span class="hljs-comment">//============================================</span><br>        <span class="hljs-comment">//说明:执行doBind0方法，完成对端口的绑定</span><br>        <span class="hljs-comment">//============================================</span><br>        doBind0(regFuture, channel, localAddress, promise);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">PendingRegistrationPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PendingRegistrationPromise</span>(channel);<br>        regFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>                    promise.setFailure(cause);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>                    promise.registered();<br><br>                    doBind0(regFuture, channel, localAddress, promise);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>4.4 分析说明 <code>initAndRegister</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">final ChannelFuture <span class="hljs-title">initAndRegister</span>()</span> &#123;<br>    Channel channel = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        channel = channelFactory.newChannel();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 说明：channelFactory.newChannel() 方法的作用通过 ServerBootstrap 的通道工厂反射创建一个 NioServerSocketChannel,具体追踪源码可以得到下面结论</span><br><span class="hljs-comment">         * (1)通过 NIO 的 SelectorProvider 的 openServerSocketChannel 方法得到 JDK 的 channel。目的是让 Netty 包装 JDK 的 channel。</span><br><span class="hljs-comment">         * (2)创建了一个唯一的 ChannelId，创建了一个 NioMessageUnsafe，用于操作消息，创建了一个 DefaultChannelPipeline 管道，是个双向链表结构，用于过滤所有的进出的消息。</span><br><span class="hljs-comment">         * (3)创建了一个 NioServerSocketChannelConfig 对象，用于对外展示一些配置。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         * channel = channelFactory.newChannel();//NioServerSocketChannel</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         * 说明：init 初始化这个 NioServerSocketChannel，具体追踪源码可以得到如下结论</span><br><span class="hljs-comment">         * (1) init 方法，这是个抽象方法 (AbstractBootstrap类的），由ServerBootstrap实现（可以追一下源码//setChannelOptions(channel,options,logger);）。</span><br><span class="hljs-comment">         * (2)设置 NioServerSocketChannel 的 TCP 属性。</span><br><span class="hljs-comment">         * (3)由于 LinkedHashMap 是非线程安全的，使用同步进行处理。</span><br><span class="hljs-comment">         * (4)对 NioServerSocketChannel 的 ChannelPipeline 添加 ChannelInitializer 处理器。</span><br><span class="hljs-comment">         * (5)可以看出，init 的方法的核心作用在和 ChannelPipeline 相关。</span><br><span class="hljs-comment">         * (6)从 NioServerSocketChannel 的初始化过程中，我们知道，pipeline 是一个双向链表，并且，他本身就初始化了 head 和 tail，这里调用了他的 addLast 方法，也就是将整个 handler 插入到 tail 的前面，因为 tail 永远会在后面，需要做一些系统的固定工作。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">init</span>(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) &#123;<br>            channel.<span class="hljs-keyword">unsafe</span>().closeForcibly();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><br>    ChannelFuture regFuture = config().<span class="hljs-keyword">group</span>().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.<span class="hljs-keyword">unsafe</span>().closeForcibly();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：</p><ol><li>基本说明：<code>initAndRegister()</code> 初始化 <code>NioServerSocketChannel</code> 通道并注册各个 <code>handler</code>，返回一个 <code>future</code>。</li><li>通过 <code>ServerBootstrap</code> 的通道工厂反射创建一个 <code>NioServerSocketChannel</code>。</li><li><code>init</code> 初始化这个 <code>NioServerSocketChannel</code>。</li><li><code>config().group().register(channel)</code> 通过 <code>ServerBootstrap</code> 的 <code>bossGroup</code> 注册 <code>NioServerSocketChannel</code>。</li><li>最后，返回这个异步执行的占位符即 <code>regFuture</code>。</li></ol><p>4.5 <code>init</code> 方法会调用 <code>addLast</code>，现在进入到 <code>addLast</code> 方法内查看</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline addLast(EventExecutorGroup group, <span class="hljs-keyword">String</span> name, ChannelHandler handler) &#123;<br>    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>;<br>    synchronized (<span class="hljs-built_in">this</span>) &#123;<br>        checkMultiplicity(handler);<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Context</span>(group, filterName(name, handler), handler);<br>        addLast0(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);<br>        <span class="hljs-keyword">if</span> (!registered) &#123;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.setAddPending();<br>            callHandlerCallbackLater(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>, <span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        EventExecutor executor = <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.executor();<br>        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;<br>            callHandlerAddedInEventLoop(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>, executor);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>    &#125;<br>    callHandlerAdded0(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：</p><ol><li><code>addLast</code> 方法，在 <code>DefaultChannelPipeline</code> 类中</li><li><code>addLast</code> 方法这就是 <code>pipeline</code> 方法的核心</li><li>检查该 <code>handler</code> 是否符合标准。</li><li>创建一个 <code>AbstractChannelHandlerContext</code> 对象，这里说一下，<code>ChannelHandlerContext</code> 对象是 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的关联，每当有 <code>ChannelHandler</code> 添加到 <code>Pipeline</code> 中时，都会创建 <code>Context</code>。<code>Context</code> 的主要功能是管理他所关联的 <code>Handler</code> 和同一个 <code>Pipeline</code> 中的其他 <code>Handler</code> 之间的交互。</li><li>将 <code>Context</code> 添加到链表中。也就是追加到 <code>tail</code> 节点的前面。</li><li>最后，同步或者异步或者晚点异步的调用 <code>callHandlerAdded0</code> 方法</li></ol><p>4.6 前面说了 <code>dobind</code> 方法有 <code>2</code> 个重要的步骤，<code>initAndRegister</code> 说完，接下来看 <code>doBind0</code> 方法，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">doBind0</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">final</span> ChannelFuture regFuture, <span class="hljs-keyword">final</span> Channel channel,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br><br>    <span class="hljs-comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span><br>    <span class="hljs-comment">// the pipeline in its channelRegistered() implementation.</span><br>    channel.<span class="hljs-built_in">eventLoop</span>().<span class="hljs-built_in">execute</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Runnable</span>() &#123;<br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-built_in">run</span>() &#123;<br>            <span class="hljs-keyword">if</span> (regFuture.<span class="hljs-built_in">isSuccess</span>()) &#123;<br>                <span class="hljs-comment">//bind方法这里下断点，这里下断点，来玩!!</span><br>                channel.<span class="hljs-built_in">bind</span>(localAddress, promise).<span class="hljs-built_in">addListener</span>(ChannelFutureListener.CLOSE_ON_FAILURE);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                promise.<span class="hljs-built_in">setFailure</span>(regFuture.<span class="hljs-built_in">cause</span>());<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：</p><ol><li>该方法的参数为 <code>initAndRegister</code> 的 <code>future</code>，<code>NioServerSocketChannel</code>，端口地址，<code>NioServerSocketChannel</code> 的 <code>promise</code></li><li>这里就可以根据前面下的断点，一直 <code>debug</code>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将调用 LoggingHandler 的 invokeBind 方法,最后会追到</span><br><span class="hljs-comment">// DefaultChannelPipeline 类的 bind</span><br><span class="hljs-comment">// 然后进入到 unsafe.bind 方法 debug，注意要追踪到</span><br><span class="hljs-comment">// unsafe.bind，要 debug 第二圈的时候，才能看到。</span><br><br>@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">bind</span> <span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> throws Exception </span>&#123;<br>    unsafe.<span class="hljs-built_in">bind</span>(localAddress,promise);<br>&#125;<br><br><span class="hljs-comment">// 继续追踪 AbstractChannel 的</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">bind</span> <span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">//....</span><br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">//!!!! 小红旗可以看到，这里最终的方法就是 doBind 方法，执行成功后，执行通道的 fireChannelActive 方法，告诉所有的 handler，已经成功绑定。</span><br>        <span class="hljs-built_in">doBind</span>(localAddress);<span class="hljs-comment">//</span><br>    &#125; <span class="hljs-built_in">catch</span> (Throwable t) &#123;<br>        <span class="hljs-built_in">safeSetFailure</span>(promise, t);<br>        <span class="hljs-built_in">closeIfClosed</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><ol><li>最终 <code>doBind</code> 就会追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>，说明 <code>Netty</code> 底层使用的是 <code>NIO</code></li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-type">void</span> <span class="hljs-title">doBind</span> <span class="hljs-params">(SocketAddress localAddress)</span> throws Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (PlatformDependent.<span class="hljs-built_in">javaVersion</span>() &gt;= <span class="hljs-number">7</span>) &#123;<br>        <span class="hljs-built_in">javaChannel</span>().<span class="hljs-built_in">bind</span>(localAddress, config.<span class="hljs-built_in">getBacklog</span>());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">javaChannel</span>().<span class="hljs-built_in">socket</span>().<span class="hljs-built_in">bind</span>(localAddress, config.<span class="hljs-built_in">getBacklog</span>());<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><ol><li>回到 <code>bind</code> 方法（<code>alt + v</code>），最后一步：<code>safeSetSuccess(promise)</code>，告诉 <code>promise</code> 任务成功了。其可以执行监听器的方法了。到此整个启动过程已经结束了，ok 了</li><li>继续 <code>atl + v</code> 服务器就回进入到（<code>NioEventLoop</code> 类）一个循环代码，进行监听</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span>(;;) &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br><br>        &#125;<br>    &#125;<br>&#125;<span class="hljs-title class_">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h3 id="10-2-4-Netty-启动过程梳理"><strong>10.2.4 Netty 启动过程梳理</strong></h3><ol><li>创建 <code>2</code> 个 <code>EventLoopGroup</code> 线程池数组。数组默认大小 <code>CPU * 2</code>，方便 <code>chooser</code> 选择线程池时提高性能</li><li><code>BootStrap</code> 将 <code>boss</code> 设置为 <code>group</code> 属性，将 <code>worker</code> 设置为 <code>childer</code> 属性</li><li>通过 <code>bind</code> 方法启动，内部重要方法为 <code>initAndRegister</code> 和 <code>dobind</code> 方法</li><li><code>initAndRegister</code> 方法会反射创建 <code>NioServerSocketChannel</code> 及其相关的 <code>NIO</code> 的对象，<code>pipeline</code>，<code>unsafe</code>，同时也为 <code>pipeline</code> 初始了 <code>head</code> 节点和 <code>tail</code> 节点。</li><li>在 <code>register0</code> 方法成功以后调用在 <code>dobind</code> 方法中调用 <code>doBind0</code> 方法，该方法会调用 <code>NioServerSocketChannel</code> 的 <code>doBind</code> 方法对 <code>JDK</code> 的 <code>channel</code> 和端口进行绑定，完成 <code>Netty</code> 服务器的所有启动，并开始监听连接事件。</li></ol><h2 id="10-3-Netty-接受请求过程源码剖析"><strong>10.3 Netty 接受请求过程源码剖析</strong></h2><h3 id="10-3-1-源码剖析目的"><strong>10.3.1 源码剖析目的</strong></h3><ol><li>服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，下面源码分析 <code>Netty</code> 在启动之后是如何接受客户端请求的</li><li>在 <code>io.netty.example</code> 包下</li></ol><h3 id="10-3-2-源码剖析"><strong>10.3.2 源码剖析</strong></h3><p>说明：</p><ol><li>从之前服务器启动的源码中，我们得知，服务器最终注册了一个 <code>Accept</code> 事件等待客户端的连接。我们也知道，<code>NioServerSocketChannel</code> 将自己注册到了 <code>boss</code> 单例线程池（<code>reactor</code> 线程）上，也就是 <code>EventLoop</code>。</li><li>先简单说下 <code>EventLoop</code> 的逻辑(后面我们详细讲解 <code>EventLoop</code>)</li></ol><p><code>EventLoop</code> 的作用是一个死循环，而这个循环中做 3 件事情：</p><ol><li><p>有条件的等待 <code>NIO</code> 事件。</p></li><li><p>处理 <code>NIO</code> 事件。</p></li><li><p>处理消息队列中的任务。</p></li><li><p>仍用前面的项目来分析：进入到 <code>NioEventLoop</code> 源码中后，在 <code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法开始调试最终我们要分析到 <code>AbstractNioChannel</code> 的 <code>doBeginRead</code> 方法，当到这个方法时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</p><p>源码分析过程</p></li><li><p>断点位置 <code>NioEventLoop</code> 的如下方法 <code>processSelectedKey</code></p></li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">if</span>((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>    unsafe.<span class="hljs-keyword">read</span>();<span class="hljs-comment">//断点位置</span><br>&#125;<span class="hljs-keyword">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><ol><li>执行浏览器 <code>http://localhost:8007/</code> ，客户端发出请求</li><li>从的断点我们可以看到，<code>readyOps</code> 是 <code>16</code>，也就是 <code>Accept</code> 事件。说明浏览器的请求已经进来了。</li><li>这个 <code>unsafe</code> 是 <code>boss</code> 线程中 <code>NioServerSocketChannel</code> 的 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 对象。我们进入到 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 的 <code>read</code> 方法中</li><li><code>read</code> 方法代码并分析:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>    asserteventLoop().inEventLoop();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> config();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> pipeline();<br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.<span class="hljs-type">Handle</span> <span class="hljs-variable">allocHandle</span> <span class="hljs-operator">=</span> unsafe().recvBufAllocHandle();<br>    allocHandle.reset(config);<br>    booleanclosed = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Throwable</span> <span class="hljs-variable">exception</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">localRead</span> <span class="hljs-operator">=</span> doReadMessages(readBuf);<br>                <span class="hljs-keyword">if</span> (localRead == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (localRead &lt; <span class="hljs-number">0</span>) &#123;<br>                    closed = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                allocHandle.incMessagesRead(localRead);<br>            &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            exception = t;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> readBuf.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            readPending = <span class="hljs-literal">false</span>;<br>            pipeline.fireChannelRead(readBuf.get(i));<br>        &#125;<br>        readBuf.clear();<br>        allocHandle.readComplete();<br>        pipeline.fireChannelReadComplete();<br><br>        <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;<br>            closed = closeOnReadError(exception);<br><br>            pipeline.fireExceptionCaught(exception);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (closed) &#123;<br>            inputShutdown = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(isOpen()) &#123;<br>                close(voidPromise());<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//Check if there is a readPending which was not processed yet.</span><br>        <span class="hljs-comment">//This could be for two reasons:</span><br>        <span class="hljs-comment">//* The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>        <span class="hljs-comment">//* The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明： 1)检查该 <code>eventloop</code> 线程是否是当前线程。<code>asserteventLoop().inEventLoop()</code></p><p>2)执行 <code>doReadMessages</code> 方法，并传入一个 <code>readBuf</code> 变量，这个变量是一个 <code>List</code>，也就是容器。</p><p>3)循环容器，执行 <code>pipeline.fireChannelRead(readBuf.get(i));</code></p><p>4)<code>doReadMessages</code> 是读取 <code>boss</code> 线程中的 <code>NioServerSocketChannel</code> 接受到的请求。并把这些请求放进容器，一会我们 <code>debug</code> 下 <code>doReadMessages</code> 方法。</p><p>5)循环遍历容器中的所有请求，调用 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法，用于处理这些接受的请求或者其他事件，在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p><ol><li>追踪一下 <code>doReadMessages</code> 方法，就可以看得更清晰</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doReadMessages</span> <span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> SocketUtils.accept(javaChannel());<br>    buf.add(newNioSocketChannel(<span class="hljs-built_in">this</span>, ch));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明： 1)通过工具类，调用 <code>NioServerSocketChannel</code> 内部封装的 <code>serverSocketChannel</code> 的 <code>accept</code> 方法，这是 <code>NIO</code> 做法。</p><p>2)获取到一个 <code>JDK</code> 的 <code>SocketChannel</code>，然后，使用 <code>NioSocketChannel</code> 进行封装。最后添加到容器中</p><p>3)这样容器 <code>buf</code> 中就有了 <code>NioSocketChannel</code> 【如果有兴趣可以追一下 <code>NioSocketChannel</code> 是如何创建的，我就不追了】</p><ol><li>回到 <code>read</code> 方法，继续分析循环执行 <code>pipeline.fireChannelRead</code> 方法</li></ol><p>1)前面分析 <code>doReadMessages</code> 方法的作用是通过 <code>ServerSocket</code> 的 <code>accept</code> 方法获取到 <code>TCP</code> 连接，然后封装成 <code>Netty</code> 的 <code>NioSocketChannel</code> 对象。最后添加到容器中</p><p>2)在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p><p>3)经过 <code>dubug</code>（多次），可以看到会反复执行多个 <code>handler</code> 的 <code>ChannelRead</code>，我们知道，<code>pipeline</code> 里面又 <code>4</code> 个 <code>handler</code>，分别是 <code>Head</code>，<code>LoggingHandler</code>，<code>ServerBootstrapAcceptor</code>，<code>Tail</code>。</p><p>4)我们重点看看 <code>ServerBootstrapAcceptor</code>。<code>debug</code> 之后，断点会进入到 <code>ServerBootstrapAcceptor</code> 中来。我们来看看 <code>ServerBootstrapAcceptor</code> 的 <code>channelRead</code> 方法（要多次 <code>debug</code> 才可以）</p><p>5)<code>channelRead</code> 方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span> <span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Channelchild = (Channel)msg;<br>    child.pipeline().addLast(childHandler);<br>    setChannelOptions(child, childOptions, logger);<br>    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e : childAttrs) &#123;<br>        child.attr((AttributeKey&lt;Object&gt;)e.getKey()).set(e.getValue());<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//将客户端连接注册到 worker 线程池</span><br>        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuturefuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;<br>                    forceClose(child, future.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        forceClose(child, t);<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明： 1)<code>msg</code> 强转成 <code>Channel</code>，实际上就是 <code>NioSocketChannel</code>。</p><p>2)添加 <code>NioSocketChannel</code> 的 <code>pipeline</code> 的 <code>handler</code>，就是我们 <code>main</code> 方法里面设置的 <code>childHandler</code> 方法里的。</p><p>3)设置 <code>NioSocketChannel</code> 的各种属性。</p><p>4)将该 <code>NioSocketChannel</code> 注册到 <code>childGroup</code> 中的一个 <code>EventLoop</code> 上，并添加一个监听器。</p><p>5)这个 <code>childGroup</code> 就是我们 <code>main</code> 方法创建的数组 <code>workerGroup</code>。</p><ol><li>进入 <code>register</code> 方法查看(步步追踪会到)</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">register</span> <span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br>    <span class="hljs-keyword">if</span> (eventLoop.<span class="hljs-built_in">inEventLoop</span>()) &#123;<br>        <span class="hljs-built_in">register0</span>(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        eventLoop.<span class="hljs-built_in">execute</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Runnable</span>()&#123;<br>            @Override<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-built_in">run</span>() &#123;<br>                <span class="hljs-built_in">register0</span>(promise);<span class="hljs-comment">//进入到这里</span><br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 继续进入到下面方法，执行管道中可能存在的任务,这里我们就不追了Copy to clipboardErrorCopied</span><br></code></pre></td></tr></table></figure><ol><li>最终会调用 <code>doBeginRead</code> 方法，也就是 <code>AbstractNioChannel</code> 类的方法</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@Override<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> doBeginRead() throws Exception &#123;<br>    <span class="hljs-comment">//Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<span class="hljs-comment">//断点</span><br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    readPending = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>erestOps = selectionKey.<span class="hljs-built_in">int</span>erestOps();<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">int</span>erestOps&amp;readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        selectionKey.<span class="hljs-built_in">int</span>erestOps(<span class="hljs-built_in">int</span>erestOps | readInterestOp);<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><ol><li>这个地方调试时，请把前面的断点都去掉，然后启动服务器就会停止在 <code>doBeginRead</code>（需要先放过该断点，然后浏览器请求，才能看到效果）</li><li>执行到这里时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</li></ol><h3 id="10-3-3-Netty-接受请求过程梳理"><strong>10.3.3 Netty 接受请求过程梳理</strong></h3><p>总体流程：接受连接 --&gt; 创建一个新的 <code>NioSocketChannel</code> --&gt; 注册到一个 <code>workerEventLoop</code> 上 --&gt; 注册 <code>selecotRead</code> 事件。</p><ol><li>服务器轮询 <code>Accept</code> 事件，获取事件后调用 <code>unsafe</code> 的 <code>read</code> 方法，这个 <code>unsafe</code> 是 <code>ServerSocket</code> 的内部类，该方法内部由 <code>2</code> 部分组成</li><li><code>doReadMessages</code> 用于创建 <code>NioSocketChannel</code> 对象，该对象包装 <code>JDK</code> 的 <code>NioChannel</code> 客户端。该方法会像创建 <code>ServerSocketChanel</code> 类似创建相关的 <code>pipeline</code>，<code>unsafe</code>，<code>config</code></li><li>随后执行执行 <code>pipeline.fireChannelRead</code> 方法，并将自己绑定到一个 <code>chooser</code> 选择器选择的 <code>workerGroup</code> 中的一个 <code>EventLoop</code>。并且注册一个 <code>0</code>，表示注册成功，但并没有注册读（1）事件</li></ol><h2 id="10-4-Pipeline-Handler-HandlerContext-创建源码剖析"><strong>10.4 Pipeline Handler HandlerContext 创建源码剖析</strong></h2><h3 id="10-4-1-源码剖析目的"><strong>10.4.1 源码剖析目的</strong></h3><p><code>Netty</code> 中的 <code>ChannelPipeline</code>、<code>ChannelHandler</code> 和 <code>ChannelHandlerContext</code> 是非常核心的组件，我们从源码来分析 <code>Netty</code> 是如何设计这三个核心组件的，并分析是如何创建和协调工作的.</p><h3 id="10-4-2-源码剖析说明"><strong>10.4.2 源码剖析说明</strong></h3><p>说明 分析过程中，有很多的图形，所以我们准备了一个文档，在文档的基础上来做源码剖析</p><h3 id="10-4-3-源码剖析"><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter10?id=_1043-%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90"><strong>10.4.3 源码剖析</strong></a></h3><ol><li>ChannelPipeline | ChannelHandler | ChannelHandlerContext介绍</li><li>1 三者关系</li></ol><p>1)每当 <code>ServerSocket</code> 创建一个新的连接，就会创建一个 <code>Socket</code>，对应的就是目标客户端。</p><p>2)每一个新创建的 <code>Socket</code> 都将会分配一个全新的 <code>ChannelPipeline</code>（以下简称 <code>pipeline</code>）</p><p>3)每一个 <code>ChannelPipeline</code> 内部都含有多个 <code>ChannelHandlerContext</code>（以下简称 <code>Context</code>）</p><p>4)他们一起组成了双向链表，这些 <code>Context</code> 用于包装我们调用 <code>addLast</code> 方法时添加的 <code>ChannelHandler</code>（以下简称 <code>handler</code>）</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_02.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_02.png"></p><p>1)上图中：<code>ChannelSocket</code> 和 <code>ChannelPipeline</code> 是一对一的关联关系，而 <code>pipeline</code> 内部的多个 <code>Context</code> 形成了链表，<code>Context</code> 只是对 <code>Handler</code> 的封装。 2)当一个请求进来的时候，会进入 <code>Socket</code> 对应的 <code>pipeline</code>，并经过 <code>pipeline</code> 所有的 <code>handler</code>，对，就是设计模式中的过滤器模式。</p><p>1.2 ChannelPipeline 作用及设计</p><p>1)<code>pipeline</code> 的接口设计</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_03.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_03.png"></p><p>部分源码</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_04.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_04.png"></p><p>可以看到该接口继承了 <code>inBound</code>，<code>outBound</code>，<code>Iterable</code> 接口，表示他可以调用数据出站的方法和入站的方法，同时也能遍历内部的链表，看看他的几个代表性的方法，基本上都是针对 <code>handler</code> 链表的插入，追加，删除，替换操作，类似是一个 <code>LinkedList</code>。同时，也能返回 <code>channel</code>（也就是 <code>socket</code>）</p><p>1)在 <code>pipeline</code> 的接口文档上，提供了一幅图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_05.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_05.png"></p><p>对上图的解释说明： *这是一个 <code>handler</code> 的 <code>list</code>，<code>handler</code> 用于处理或拦截入站事件和出站事件，<code>pipeline</code> 实现了过滤器的高级形式，以便用户控制事件如何处理以及 <code>handler</code> 在 <code>pipeline</code> 中如何交互。</p><ul><li>上图描述了一个典型的 <code>handler</code> 在 <code>pipeline</code> 中处理 <code>I/O</code> 事件的方式，<code>IO</code> 事件由 <code>inboundHandler</code> 或者 <code>outBoundHandler</code> 处理，并通过调用 <code>ChannelHandlerContext.fireChannelRead</code> 方法转发给其最近的处理程序。</li><li>入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的 <code>I/O</code> 线程生成入站数据。入站数据通常从如 <code>SocketChannel.read(ByteBuffer)</code> 获取。</li><li>通常一个 <code>pipeline</code> 有多个 <code>handler</code>，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序协议解码器-将二进制数据转换为 <code>Java</code> 对象。协议编码器-将 <code>Java</code> 对象转换为二进制数据。业务逻辑处理程序-执行实际业务逻辑（例如数据库访问）</li><li>你的业务程序不能将线程阻塞，会影响 <code>IO</code> 的速度，进而影响整个 <code>Netty</code> 程序的性能。如果你的业务程序很快，就可以放在 <code>IO</code> 线程中，反之，你需要异步执行。或者在添加 <code>handler</code> 的时候添加一个线程池，例如：</li></ul><p>// 下面这个任务执行的时候，将不会阻塞 <code>IO</code> 线程，执行的线程来自 <code>group</code> 线程池</p><p><code>pipeline.addLast(group, &quot;handler&quot;, new MyBusinessLogicHandler());</code></p><p>1.3 <code>ChannelHandler</code> 作用及设计</p><p>1)源码</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelHandler</span> </span>&#123;<br>    <span class="hljs-comment">//当把 ChannelHandler 添加到 pipeline 时被调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>    <span class="hljs-comment">//当从 pipeline 中移除时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>    <span class="hljs-comment">//当处理过程中在 pipeline 发生异常时调用</span><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>2)<code>ChannelHandler</code> 的作用就是处理 <code>IO</code> 事件或拦截 <code>IO</code> 事件，并将其转发给下一个处理程序 <code>ChannelHandler</code>。<code>Handler</code> 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，<code>Netty</code> 定义了两个子接口继承 <code>ChannelHandler</code></p><p>2)<code>ChannelInboundHandler</code> 入站事件接口</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_06.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_06.png"></p><ul><li><code>channelActive</code> 用于当 <code>Channel</code> 处于活动状态时被调用；</li><li><code>channelRead</code> 当从 <code>Channel</code> 读取数据时被调用等等方法。</li><li>程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，<code>Netty</code> 会回调对应的方法。</li></ul><p>3)`ChannelOutboundHandler 出站事件接口</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_07.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_07.png"></p><ul><li><code>bind</code> 方法，当请求将 <code>Channel</code> 绑定到本地地址时调用</li><li><code>close</code> 方法，当请求关闭 <code>Channel</code> 时调用等等</li><li>出站操作都是一些连接和写出数据类似的方法。</li></ul><p>4)<code>ChannelDuplexHandler</code> 处理出站和入站事件</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_08.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_08.png"></p><ul><li><code>ChannelDuplexHandler</code> 间接实现了入站接口并直接实现了出站接口。</li><li>是一个通用的能够同时处理入站事件和出站事件的类。</li></ul><p>1.4 <code>ChannelHandlerContext</code> 作用及设计</p><p>1)<code>ChannelHandlerContext</code> <code>UML</code> 图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_09.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_09.png"></p><p><code>ChannelHandlerContext</code> 继承了出站方法调用接口和入站方法调用接口</p><p>1)<code>ChannelOutboundInvoker</code> 和 <code>ChannelInboundInvoker</code> 部分源码</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_10.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_10.png"></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_11.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_11.png"></p><ul><li>这两个 <code>invoker</code> 就是针对入站或出站方法来的，就是在入站或出站 <code>handler</code> 的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的</li></ul><p>2)<code>ChannelHandlerContext</code> 部分源码</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_12.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_12.png"></p><ul><li><code>ChannelHandlerContext</code> 不仅仅时继承了他们两个的方法，同时也定义了一些自己的方法</li><li>这些方法能够获取 <code>Context</code> 上下文环境中对应的比如 <code>channel</code>，<code>executor</code>，<code>handler</code>，<code>pipeline</code>，内存分配器，关联的 <code>handler</code> 是否被删除。</li><li><code>Context</code> 就是包装了 <code>handler</code> 相关的一切，以方便 <code>Context</code> 可以在 <code>pipeline</code> 方便的操作 <code>handler</code></li></ul><p>2.ChannelPipeline | ChannelHandler | ChannelHandlerContext</p><p>创建过程分为 <code>3</code> 个步骤来看创建的过程：</p><ul><li>任何一个 <code>ChannelSocket</code> 创建的同时都会创建一个 <code>pipeline</code>。</li><li>当用户或系统内部调用 <code>pipeline</code> 的 <code>add</code></li><li>** 方法添加 <code>handler</code> 时，都会创建一个包装这 <code>handler</code> 的 <code>Context</code>。</li><li>这些 <code>Context</code> 在 <code>pipeline</code> 中组成了双向链表。</li></ul><p>2.1 <code>Socket</code> 创建的时候创建 <code>pipeline</code> 在 <code>SocketChannel</code> 的抽象父类 <code>AbstractChannel</code> 的构造方法中</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">protected AbstractChannel(Channel parent) &#123;<br>    this.parent<span class="hljs-operator">=</span>parent<span class="hljs-comment">;//断点测试</span><br>    id <span class="hljs-operator">=</span> newId()<span class="hljs-comment">;</span><br>    unsafe <span class="hljs-operator">=</span> new Unsafe()<span class="hljs-comment">;</span><br>    pipeline <span class="hljs-operator">=</span> new ChannelPipeline()<span class="hljs-comment">;</span><br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p><code>Debug</code> 一下，可以看到代码会执行到这里，然后继续追踪到</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe">protected DefaultChannelPipeline(Channel channel) &#123;<br>    <span class="hljs-built_in">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="hljs-string">&quot;channel&quot;</span>);<br>    succeededFuture = <span class="hljs-keyword">new</span> <span class="hljs-type">SucceededChannelFuture</span>(channel, <span class="hljs-literal">null</span>);<br>    voidPromise = <span class="hljs-keyword">new</span> <span class="hljs-type">VoidChannelPromise</span>(channel, <span class="hljs-literal">true</span>);<br>    tail = <span class="hljs-keyword">new</span> <span class="hljs-type">TailContext</span>(<span class="hljs-built_in">this</span>);<br>    head = <span class="hljs-keyword">new</span> <span class="hljs-type">HeadContext</span>(<span class="hljs-built_in">this</span>);<br>    head.next = tail;<br>    tail.prev = head;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：</p><p>1）将 <code>channel</code> 赋值给 <code>channel</code> 字段，用于 <code>pipeline</code> 操作 <code>channel</code>。</p><p>2）创建一个 <code>future</code> 和 <code>promise</code>，用于异步回调使用。</p><p>3）创建一个 <code>inbound</code> 的 <code>tailContext</code>，创建一个既是 <code>inbound</code> 类型又是 <code>outbound</code> 类型的 <code>headContext</code>。</p><p>4）最后，将两个 <code>Context</code> 互相连接，形成双向链表。</p><p>5）<code>tailContext</code> 和 <code>HeadContext</code> 非常的重要，所有 <code>pipeline</code> 中的事件都会流经他们，</p><p>2.2 在 add<strong>添加处理器的时候创建Context</strong>看下 <code>DefaultChannelPipeline</code> 的 <code>addLast</code> 方法如何创建的 <code>Context</code>，代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline addLast(EventExecutorGroup executor, ChannelHandler... handlers) &#123;<br>    <span class="hljs-keyword">if</span> (handlers == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//断点</span><br>        <span class="hljs-keyword">throw</span> new NullPointerException(<span class="hljs-string">&quot;handlers&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (ChannelHandler h : handlers) &#123;<br>        <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        addLast(executor, <span class="hljs-literal">null</span>, h);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>继续 Debug</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline addLast(EventExecutorGroup group, <span class="hljs-keyword">String</span> name, ChannelHandler handler) &#123;<br>    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>;<br>    synchronized(<span class="hljs-built_in">this</span>) &#123;<br>        checkMultiplicity(handler);<br><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Context</span>(group, filterName(name, handler), handler);<br>        addLast0(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);<br>        <span class="hljs-comment">//If the registered is false it means that the channel was not registered on an eventloop yet.</span><br>        <span class="hljs-comment">//In this case we add the context to the pipeline and add a task that will call</span><br>        <span class="hljs-comment">//ChannelHandler.handlerAdded(...) once the channel is registered.</span><br>        <span class="hljs-keyword">if</span> (!registered) &#123;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.setAddPending();<br>            callHandlerCallbackLater(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>, <span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        EventExecutor executor = <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.executor();<br>        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.setAddPending();<br>            executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-type">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> void run () &#123;<br>                    callHandlerAdded0(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>    &#125;<br>    callHandlerAdded0(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明 1)<code>pipeline</code> 添加 <code>handler</code>，参数是线程池，<code>name</code> 是 <code>null</code>，<code>handler</code> 是我们或者系统传入的 <code>handler</code>。<code>Netty</code> 为了防止多个线程导致安全问题，同步了这段代码，步骤如下：</p><p>2)检查这个 <code>handler</code> 实例是否是共享的，如果不是，并且已经被别的 <code>pipeline</code> 使用了，则抛出异常。</p><p>3)调用 <code>new Context(group, filterName(name, handler), handler)</code> 方法，创建一个 <code>Context</code>。从这里可以看出来了，每次添加一个 <code>handler</code> 都会创建一个关联 <code>Context</code>。</p><p>4)调用 <code>addLast</code> 方法，将 <code>Context</code> 追加到链表中。</p><p>5)如果这个通道还没有注册到 <code>selecor</code> 上，就将这个 <code>Context</code> 添加到这个 <code>pipeline</code> 的待办任务中。当注册好了以后，就会调用 <code>callHandlerAdded0</code> 方法（默认是什么都不做，用户可以实现这个方法）。</p><p>6)到这里，针对三对象创建过程，了解的差不多了，和最初说的一样，每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。<code>tail</code> 是入站 <code>inbound</code> 类型的 <code>handler</code>，<code>head</code> 既是 <code>inbound</code> 也是 <code>outbound</code> 类型的 <code>handler</code>。在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。到此就 <code>OK</code> 了。</p><h3 id="10-4-4-Pipeline-Handler-HandlerContext-创建过程梳理"><strong>10.4.4 Pipeline Handler HandlerContext 创建过程梳理</strong></h3><ol><li>每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。</li><li>在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。</li><li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表</li><li>入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始</li></ol><h2 id="10-5-ChannelPipeline-调度-handler-的源码剖析"><strong>10.5 ChannelPipeline 调度 handler 的源码剖析</strong></h2><h3 id="10-5-1-源码剖析目的"><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter10?id=_1051-%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90%e7%9b%ae%e7%9a%84"><strong>10.5.1 源码剖析目的</strong></a></h3><ol><li><p>当一个请求进来的时候，<code>ChannelPipeline</code> 是如何调用内部的这些 <code>handler</code> 的呢？我们一起来分析下。</p></li><li><p>首先，当一个请求进来的时候，会第一个调用 <code>pipeline</code> 的相关方法，如果是入站事件，这些方法由 <code>fire</code> 开头，表示开始管道的流动。让后面的 <code>handler</code> 继续处理</p></li></ol><h3 id="10-5-2-源码剖析"><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter10?id=_1052-%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90"><strong>10.5.2 源码剖析</strong></a></h3><p>说明</p><p>当浏览器输入 <code>http://localhost:8007</code> 。可以看到会执行 <code>handler</code> 在 <code>Debug</code> 时，可以将断点下在 <code>DefaultChannelPipeline</code> 类的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline fireChannelActive() &#123;<br>    AbstractChannelHandlerContext.invokeChannelActive(head);<span class="hljs-comment">//断点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>源码分析</p><ol><li><code>DefaultChannelPipeline</code> 是如何实现这些 <code>fire</code> 方法的 3.1 <code>DefaultChannelPipeline</code> 源码</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultChannelPipeline</span> <span class="hljs-title">implements</span> <span class="hljs-title">ChannelPipeline</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline fireChannelActive() &#123;<br>        AbstractChannelHandlerContext.invokeChannelActive(head);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipelinefireChannelInactive() &#123;<br>        AbstractChannelHandlerContext.invokeChannelInactive(head);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline fireExceptionCaught(Throwable cause) &#123;<br>        AbstractChannelHandlerContext.invokeExceptionCaught(head, cause);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline fireUserEventTriggered(Object event) &#123;<br>        AbstractChannelHandlerContext.invokeUserEventTriggered(head, event);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline fireChannelRead(Objectmsg) &#123;<br>        AbstractChannelHandlerContext.invokeChannelRead(head, msg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline fireChannelReadComplete() &#123;<br>        AbstractChannelHandlerContext.invokeChannelReadComplete(head);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline fireChannelWritabilityChanged() &#123;<br>        AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明： 可以看出来，这些方法都是 <code>inbound</code> 的方法，也就是入站事件，调用静态方法传入的也是 <code>inbound</code> 的类型 <code>head</code> <code>handler</code>。这些静态方法则会调用 <code>head</code> 的 <code>ChannelInboundInvoker</code> 接口的方法，再然后调用 <code>handler</code> 的真正方法</p><p>3.2再看下 <code>piepline</code> 的 <code>outbound</code> 的 <code>fire</code> 方法实现源码</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultChannelPipeline</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelPipeline</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">bind</span><span class="hljs-params">(localAddress)</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">connect</span><span class="hljs-params">(remoteAddress)</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">connect</span><span class="hljs-params">(remoteAddress, localAddress)</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">disconnect</span><span class="hljs-params">()</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">deregister</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">deregister</span><span class="hljs-params">()</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelPipeline <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>        tail.flush();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">bind</span><span class="hljs-params">(localAddress, promise)</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">connect</span><span class="hljs-params">(remoteAddress, promise)</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">connect</span><span class="hljs-params">(remoteAddress, localAddress, promise)</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">disconnect</span><span class="hljs-params">(promise)</span></span>;<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：</p><p>1)这些都是出站的实现，但是调用的是 <code>outbound</code> 类型的 <code>tailhandler</code> 来进行处理，因为这些都是 <code>outbound</code> 事件。</p><p>2)出站是 <code>tail</code> 开始，入站从 <code>head</code> 开始。因为出站是从内部向外面写，从 <code>tail</code> 开始，能够让前面的 <code>handler</code> 进行处理，防止 <code>handler</code> 被遗漏，比如编码。反之，入站当然是从 <code>head</code> 往内部输入，让后面的 <code>handler</code> 能够处理这些输入的数据。比如解码。因此虽然 <code>head</code> 也实现了 <code>outbound</code> 接口，但不是从 head 开始执行出站任务</p><p>4.关于如何调度，用一张图来表示:</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_13.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_13.png"></p><p>说明： 1)<code>pipeline</code> 首先会调用 <code>Context</code> 的静态方法 <code>fireXXX</code>，并传入 <code>Context</code></p><p>2)然后，静态方法调用 <code>Context</code> 的 <code>invoker</code> 方法，而 <code>invoker</code> 方法内部会调用该 <code>Context</code> 所包含的 <code>Handler</code> 的真正的 <code>XXX</code> 方法，调用结束后，如果还需要继续向后传递，就调用 <code>Context</code> 的 <code>fireXXX2</code> 方法，循环往复。</p><h3 id="10-5-3-ChannelPipeline-调度-handler-梳理"><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter10?id=_1053-channelpipeline-%e8%b0%83%e5%ba%a6-handler-%e6%a2%b3%e7%90%86"><strong>10.5.3 ChannelPipeline 调度 handler 梳理</strong></a></h3><ol><li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表，入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始。</li><li>而节点中间的传递通过 <code>Abstract ChannelHandlerContext</code> 类内部的 <code>fire</code> 系列方法，找到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对 <code>handler</code> 的调度</li></ol><h2 id="10-6-Netty-心跳-heartbeat-服务源码剖析"><strong>10.6 Netty 心跳(heartbeat)服务源码剖析</strong></h2><h3 id="10-6-1-源码剖析目的"><strong>10.6.1 源码剖析目的</strong></h3><p><code>Netty</code> 作为一个网络框架，提供了诸多功能，比如编码解码等，<code>Netty</code> 还提供了非常重要的一个服务 – 心跳机制 <code>heartbeat</code>。通过心跳检查对方是否有效，这是 <code>RPC</code> 框架中是必不可少的功能。下面我们分析一下 <code>Netty</code> 内部心跳服务源码实现。</p><h3 id="10-6-2-源码剖析"><strong>10.6.2 源码剖析</strong></h3><p>说明</p><p><code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性，重点分析 <code>IdleStateHandler</code>。</p><p>如图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_14.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_14.png"></p><p>源码剖析：</p><p>5.<code>Netty</code> 提供的心跳介绍</p><p>1)<code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性。</p><p>2)如图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_15.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_15.png"></p><p>3)<code>ReadTimeout</code> 事件和 <code>WriteTimeout</code> 事件都会自动关闭连接，而且，属于异常处理，所以，这里只是介绍以下，我们重点看 <code>IdleStateHandler</code>。</p><p>6.<code>IdleStateHandler</code> 分析</p><p>6.1 <code>4</code> 个属性</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> observeOutput; <span class="hljs-comment">//是否考虑出站时较慢的情况。默认值是 false</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> readerIdleTimeNanos; <span class="hljs-comment">//读事件空闲时间，0 则禁用事件</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> writerIdleTimeNanos;<span class="hljs-comment">//写事件空闲时间，0 则禁用事件</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> allIdleTimeNanos;<span class="hljs-comment">//读或写空闲时间，0 则禁用事件Copy to clipboardErrorCopied</span><br></code></pre></td></tr></table></figure><p>6.2<code>handlerAdded</code> 方法</p><p>当该 <code>handler</code> 被添加到 <code>pipeline</code> 中时，则调用 <code>initialize</code> 方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> void initialize(ChannelHandlerContext ctx) &#123;<br>    <span class="hljs-comment">//Avoid the case where destroy() is called before scheduling timeouts.</span><br>    <span class="hljs-comment">//See:https://github.com/netty/netty/issues/143</span><br>    <span class="hljs-keyword">switch</span>(state) &#123;<br>        case1:<span class="hljs-type"></span><br>        case2:<span class="hljs-type"></span><br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    state=<span class="hljs-number">1</span>;<br>    initOutputChanged(ctx);<br><br>    lastReadTime = lastWriteTime = ticksInNanos();<br><br>    <span class="hljs-keyword">if</span>(readerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列中</span><br>        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> <span class="hljs-type">ReaderIdleTimeoutTask</span>(ctx), readerIdleTimeNanos, TimeUnit.NANOSECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(writerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;<br>        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> <span class="hljs-type">WriterIdleTimeoutTask</span>(ctx), writerIdleTimeNanos, TimeUnit.NANOSECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(allIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;<br>        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> <span class="hljs-type">AllIdleTimeoutTask</span>(ctx), allIdleTimeNanos, TimeUnit.NANOSECONDS);<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>只要给定的参数大于 <code>0</code>，就创建一个定时任务，每个事件都创建。同时，将 <code>state</code> 状态设置为 <code>1</code>，防止重复初始化。调用 <code>initOutputChanged</code> 方法，初始化“监控出站数据属性”。</p><p>6.3该类内部的 <code>3</code> 个定时任务类</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_16.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_16.png"></p><p>1)这 <code>3</code> 个定时任务分别对应读，写，读或者写事件。共有一个父类（<code>AbstractIdleTask</code>）。这个父类提供了一个模板方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractIdleTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelHandlerContext ctx;<br><br>    AbstractIdleTask(ChannelHandlerContext ctx) &#123;<br>        <span class="hljs-keyword">this</span>.ctx = ctx;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!ctx.channel().isOpen()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        run(ctx);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：当通道关闭了，就不执行任务了。反之，执行子类的 <code>run</code> 方法</p><p>7.读事件的 <code>run</code> 方法（即 <code>ReaderIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>1)代码及其说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nextDelay</span> <span class="hljs-operator">=</span> readerIdleTimeNanos;<br>    <span class="hljs-keyword">if</span>(!reading) &#123;<br>        nextDelay -= ticksInNanos() - lastReadTime;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(nextDelay &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//Reader is idle-set a new timeout and notify the callback.</span><br>        <span class="hljs-comment">//用于取消任务 promise</span><br>        readerIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstReaderIdleEvent;<br>        firstReaderIdleEvent = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//再次提交任务</span><br>            <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateEvent</span>(IdleState.READER_IDLE, first);<br>            <span class="hljs-comment">//触发用户 handler use</span><br>            channelIdle(ctx, event);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ctx.fireExceptionCaught(t);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//Read occurred before the timeout - set a new timeout with shorter delay.</span><br>        readerIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：</p><p>1)得到用户设置的超时时间。</p><p>2)如果读取操作结束了（执行了 <code>channelReadComplete</code> 方法设置），就用当前时间减去给定时间和最后一次读（执操作的时间行了 <code>channelReadComplete</code> 方法设置），如果小于 <code>0</code>，就触发事件。反之，继续放入队列。间隔时间是新的计算时间。</p><p>3)触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个 <code>promise</code> 对象，用于做取消操作。然后，设置 <code>first</code> 属性为<code>false</code>，表示，下一次读取不再是第一次了，这个属性在 <code>channelRead</code> 方法会被改成 <code>true</code>。</p><p>4)创建一个 <code>IdleStateEvent</code> 类型的写事件对象，将此对象传递给用户的 <code>UserEventTriggered</code> 方法。完成触发事件的操作。</p><p>5)总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发 <code>UserEventTriggered</code> 方法。//前面介绍 <code>IdleStateHandler</code> 说过,可以看一下</p><p>8.写事件的 <code>run</code> 方法（即 <code>WriterIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>1)<code>run</code> 代码和分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">lastWriteTime</span> <span class="hljs-operator">=</span> IdleStateHandler.<span class="hljs-built_in">this</span>.lastWriteTime;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nextDelay</span> <span class="hljs-operator">=</span> writerIdleTimeNanos - (ticksInNanos()-lastWriteTime);<br>    <span class="hljs-keyword">if</span> (nextDelay &lt;=<span class="hljs-number">0</span> ) &#123;<br>        <span class="hljs-comment">//Writer is idle - set a new timeout and notify the callback.</span><br>        writerIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, writerIdleTimeNanos, TimeUnit.NANOSECONDS);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWriterIdleEvent;<br>        firstWriterIdleEvent = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(hasOutputChanged(ctx, first)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateEvent</span>(IdleState.WRITER_IDLE, first);<br>            channelIdle(ctx, event);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ctx.fireExceptionCaught(t);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//Write occurred before the timeout - set a new timeout with shorter delay.</span><br>        writerIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：写任务的 <code>run</code> 代码逻辑基本和读任务的逻辑一样，唯一不同的就是有一个针对出站较慢数据的判断 <code>hasOutputChanged</code></p><p>9.所有事件的 <code>run</code> 方法（即 <code>AllIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>代码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nextDelay</span> <span class="hljs-operator">=</span> allIdleTimeNanos;<br>    <span class="hljs-keyword">if</span>(!reading) &#123;<br>        nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(nextDelay &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//Both reader and writer are idle - set a new timeout and</span><br>        <span class="hljs-comment">//notify the callback.</span><br>        allIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, allIdleTimeNanos, TimeUnit.NANOSECONDS);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstAllIdleEvent;<br>        firstAllIdleEvent = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(hasOutputChanged(ctx, first)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateEvent</span>(IdleState.ALL_IDLE, first);<br>            channelIdle(ctx, event);<br>        &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>            ctx.fireExceptionCaught(t);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//Either read or write occurred before the timeout - set a new</span><br>        <span class="hljs-comment">//timeout with shorter delay.</span><br>        allIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：</p><p>1)表示这个监控着所有的事件。当读写事件发生时，都会记录。代码逻辑和写事件的的基本一致：</p><p>2)需要大家注意的地方是</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">long</span> nextDelay = allIdleTimeNanos;<br><span class="hljs-keyword">if</span>(!reading) &#123;<br>    <span class="hljs-comment">//当前时间减去最后一次写或读的时间，若大于 0，说明超时了</span><br>    nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);<br>&#125;<span class="hljs-keyword">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>3)这里的时间计算是取读写事件中的最大值来的。然后像写事件一样，判断是否发生了写的慢的情况。</p><p>10.小结 <code>Netty</code> 的心跳机制</p><p>1)<code>IdleStateHandler</code> 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 <code>handler</code> 的 <code>userEventTriggered</code> 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接。</p><p>2)<code>IdleStateHandler</code> 的实现基于 <code>EventLoop</code> 的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。</p><p>3)内部有 <code>3</code> 个定时任务，分别对应读事件，写事件，读写事件。通常用户监听读写事件就足够了。</p><p>4)同时，<code>IdleStateHandler</code> 内部也考虑了一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间。<code>Netty</code> 通过构造方法中的 <code>observeOutput</code> 属性来决定是否对出站缓冲区的情况进行判断。</p><p>5)如果出站缓慢，<code>Netty</code> 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，可能造成 <code>OOM</code>，<code>OOM</code> 比空闲的问题更大。</p><p>6)所以，当你的应用出现了内存溢出，<code>OOM</code> 之类，并且写空闲极少发生（使用了 <code>observeOutput</code> 为 <code>true</code>），那么就需要注意是不是数据出站速度过慢。</p><p>7)还有一个注意的地方：就是 <code>ReadTimeoutHandler</code>，它继承自 <code>IdleStateHandler</code>，当触发读空闲事件的时候，就触发 <code>ctx</code>. <code>fireExceptionCaught</code> 方法，并传入一个 <code>ReadTimeoutException</code>，然后关闭 <code>Socket</code>。</p><p>8)而 <code>WriteTimeoutHandler</code> 的实现不是基于 <code>IdleStateHandler</code> 的，他的原理是，当调用 <code>write</code> 方法的时候，会创建一个定时任务，任务内容是根据传入的 <code>promise</code> 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 <code>promise</code> 的 <code>isDone</code> 方法返回 <code>false</code>，表明还没有写完，说明超时了，则抛出异常。当 <code>write</code> 方法完成后，会打断定时任务。</p><h2 id="10-7-Netty-核心组件-EventLoop-源码剖析"><strong>10.7 Netty 核心组件 EventLoop 源码剖析</strong></h2><h3 id="10-7-1-源码剖析目的"><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter10?id=_1071-%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90%e7%9b%ae%e7%9a%84"><strong>10.7.1 源码剖析目的</strong></a></h3><p><code>Echo</code> 第一行代码就是：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1)</code>; 下面分析其最核心的组件 <code>EventLoop</code>。</p><h3 id="10-7-2-源码剖析"><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter10?id=_1072-%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90"><strong>10.7.2 源码剖析</strong></a></h3><p>源码剖析</p><p>1.<code>EventLoop</code>介绍 1.1首先看看 <code>NioEventLoop</code> 的继承图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_17.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_17.png"></p><p>说明重点： 1)<code>ScheduledExecutorService</code> 接口表示是一个定时任务接口，<code>EventLoop</code> 可以接受定时任务。</p><p>2)<code>EventLoop</code> 接口：<code>Netty</code> 接口文档说明该接口作用：一旦 <code>Channel</code> 注册了，就处理该 <code>Channel</code> 对应的所有 <code>I/O</code> 操作。</p><p>3)<code>SingleThreadEventExecutor</code> 表示这是一个单个线程的线程池</p><p>4)<code>EventLoop</code> 是一个单例的线程池，里面含有一个死循环的线程不断的做着 <code>3</code> 件事情：监听端口，处理端口事件，处理队列事件。每个 <code>EventLoop</code> 都可以绑定多个 <code>Channel</code>，而每个 <code>Channel</code> 始终只能由一个 <code>EventLoop</code> 来处理</p><ol><li><code>NioEventLoop</code> 的使用 - <code>execute</code> 方法</li></ol><p>2.1 <code>execute</code> 源码剖析</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_18.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_18.png"></p><p>在 <code>EventLoop</code> 的使用，一般就是 <code>eventloop.execute(task);</code> 看下 <code>execute</code> 方法的实现(在 <code>SingleThreadEventExecutor</code> 类中)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gradle">@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> execute(Runnable <span class="hljs-keyword">task</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">task</span> == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> inEventLoop = inEventLoop();<br>    <span class="hljs-keyword">if</span>(inEventLoop) &#123;<br>        addTask(<span class="hljs-keyword">task</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        startThread();<br>        addTask(<span class="hljs-keyword">task</span>);<br>        <span class="hljs-keyword">if</span>(isShutdown() &amp;&amp; removeTask(<span class="hljs-keyword">task</span>)) &#123;<br>            reject();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(!addTaskWakesUp&amp;&amp;wakesUpForTask(<span class="hljs-keyword">task</span>)) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>&#125;<span class="hljs-keyword">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明: 1)首先判断该 <code>EventLoop</code> 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。</p><p>2)如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。</p><p>3)如果 <code>addTaskWakesUp</code> 是 <code>false</code>，并且任务不是 <code>NonWakeupRunnable</code> 类型的，就尝试唤醒 <code>selector</code>。这个时候，阻塞在 <code>selecor</code>的线程就会立即返回</p><p>4)可以下断点来追踪</p><p>2.2我们 <code>debugaddTask</code> 和 <code>offerTask</code> 方法源码</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss">protected void <span class="hljs-built_in">addTask</span>(Runnable task) &#123;<br>    <span class="hljs-built_in">if</span>(task == null) &#123;<br>        throw new <span class="hljs-built_in">NullPointerException</span>(&quot;task&quot;);<br>    &#125;<br><br>    <span class="hljs-built_in">if</span>(!offerTask(task)) &#123;<br>        <span class="hljs-built_in">reject</span>(task);<br>    &#125;<br>&#125;<br><br>final boolean <span class="hljs-built_in">offerTask</span>(Runnable task) &#123;<br>    <span class="hljs-built_in">if</span>(isShutdown()) &#123;<br>        <span class="hljs-built_in">reject</span>();<br>    &#125;<br>    return taskQueue<span class="hljs-selector-class">.offer</span>(task);<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>3.<code>NioEventLoop</code> 的父类 <code>SingleThreadEventExecutor</code> 的 <code>startThread</code> 方法 3.1当执行 <code>execute</code> 方法的时候，如果当前线程不是 <code>EventLoop</code> 所属线程，则尝试启动线程，也就是 <code>startThread</code> 方法，dubug 代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">private void <span class="hljs-built_in">startThread</span>() &#123;<br>    <span class="hljs-built_in">if</span>(state == ST_NOT_STARTED) &#123;<br>        <span class="hljs-built_in">if</span>(STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;<br>            try&#123;<br>                <span class="hljs-built_in">doStartThread</span>();<br>            &#125; <span class="hljs-built_in">catch</span>(Throwable cause) &#123;<br>                STATE_UPDATER<span class="hljs-selector-class">.set</span>(this, ST_NOT_STARTED);<br>                PlatformDependent<span class="hljs-selector-class">.throwException</span>(cause);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明:该方法首先判断是否启动过了，保证 <code>EventLoop</code> 只有一个线程，如果没有启动过，则尝试使用 <code>Cas</code> 将 <code>state</code> 状态改为 <code>ST_STARTED</code>，也就是已启动。然后调用 <code>doStartThread</code> 方法。如果失败，则进行回滚</p><p>看下 <code>doStartThread</code> 方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStartThread</span>()</span> &#123;<br>    executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>            boolean success = <span class="hljs-literal">false</span>;<br>            updateLastExecutionTime();<br>            <span class="hljs-keyword">try</span>&#123;<br>                SingleThreadEventExecutor.<span class="hljs-keyword">this</span>.run();<br>                success=<span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">for</span>( ; ; ) &#123;<br>                    intoldState = state;<br>                    <span class="hljs-keyword">if</span>(oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.<span class="hljs-keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span>( ; ; ) &#123;<br>                        <span class="hljs-keyword">if</span>(confirmShutdown()) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        cleanup();<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        STATE_UPDATER.<span class="hljs-keyword">set</span>(SingleThreadEventExecutor.<span class="hljs-keyword">this</span>,ST_TERMINATED);<br>                        threadLock.release();<br>                        terminationFuture.setSuccess(<span class="hljs-literal">null</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明： 1)首先调用 <code>executor</code> 的 <code>execute</code> 方法，这个 <code>executor</code> 就是在创建 <code>EventLoopGroup</code> 的时候创建的 <code>ThreadPerTaskExecutor</code> 类。该 <code>execute</code> 方法会将 <code>Runnable</code> 包装成 <code>Netty</code> 的 <code>FastThreadLocalThread</code>。</p><p>2)任务中，首先判断线程中断状态，然后设置最后一次的执行时间。</p><p>3)执行当前 <code>NioEventLoop</code> 的 <code>run</code> 方法，注意：这个方法是个死循环，是整个 <code>EventLoop</code> 的核心</p><p>4)在 <code>finally</code> 块中，使用 <code>CAS</code> 不断修改 <code>state</code> 状态，改成 <code>ST_SHUTTING_DOWN</code>。也就是当线程 <code>Loop</code> 结束的时候。关闭线程。最后还要死循环确认是否关闭，否则不会 <code>break</code>。然后，执行 <code>cleanup</code> 操作，更新状态为</p><p>5)<code>ST_TERMINATED</code>，并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。并回调 <code>terminationFuture</code> 方法。</p><p>6)其实最核心的就是 <code>EventLoop</code> 自身的 <code>run</code> 方法。再继续深入 <code>run</code> 方法</p><p>4.<code>EventLoop</code> 中的 <code>Loop</code> 是靠 <code>run</code> 实现的，我们分析下 <code>run</code> 方法(该方法在 <code>NioEventLoop</code>)</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>( ; ; ) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">switch</span>(selectStrategy.calculateStrategy(selectNowSupplier,hasTasks())) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    select(wakenUp.getAndSet(<span class="hljs-keyword">false</span>));<br>                    <span class="hljs-keyword">if</span>(wakenUp.get()) &#123;<br>                        selector.wakeup();<br>                    &#125;<br>                <span class="hljs-keyword">default</span>:<br>            &#125;<br><br>            cancelledKeys = 0;<br>            needsToSelectAgain = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;<br>            <span class="hljs-keyword">if</span>(ioRatio == <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//Ensure we always run tasks.</span><br>                    runAllTasks();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//Ensure we always runtasks.</span><br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;<br>                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>        <span class="hljs-comment">//Always handle shutdown even if the loop processing threw an exception.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(isShuttingDown()) &#123;<br>                closeAll();<br>                <span class="hljs-keyword">if</span>(confirmShutdown()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明: 1)从上面的步骤可以看出，整个 <code>run</code> 方法做了 <code>3</code> 件事情： <code>select</code> 获取感兴趣的事件。 <code>processSelectedKeys</code> 处理事件。 <code>runAllTasks</code> 执行队列中的任务。</p><p>2)上面的三个方法，我们就追一下 <code>select</code> 方法(体现非阻塞)核心 <code>select</code> 方法解析</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> select(<span class="hljs-keyword">boolean</span> oldWakenUp) <span class="hljs-keyword">throws</span> IOException &#123;<br>    Selector selector = <span class="hljs-keyword">this</span>.selector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> currentTimeNanos = System.nanoTime();<br>        <span class="hljs-keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);<br>        <span class="hljs-keyword">for</span>( ; ; ) &#123;<br>            <span class="hljs-keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="hljs-number">500000</span>L)/<span class="hljs-number">1000000</span>L;<br>            <span class="hljs-keyword">if</span>(timeoutMillis &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span>(selectCnt == <span class="hljs-number">0</span>) &#123;<br>                    selector.selectNow();<br>                    selectCnt=<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//If a task was submitted when wakenUp value was true, the task didn&#x27;t get a chance to call</span><br>            <span class="hljs-comment">//Selector#wakeup. So we need to check task queue again before executing select operation.</span><br>            <span class="hljs-comment">//If wedon&#x27;t, the task might be pended until select operation was timedout.</span><br>            <span class="hljs-comment">//It might be pended until idle timeout if IdleStateHandler existed inpipeline.</span><br>            <span class="hljs-keyword">if</span>(hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                selector.selectNow();<br>                selectCnt = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> selectedKeys = selector.select(timeoutMillis);<span class="hljs-comment">//否则阻塞给定时间，默认一秒</span><br>            selectCnt++;<br>            <span class="hljs-comment">//如果 1 秒后返回，有返回值||select被用户唤醒||任务队列有任务||有定时任务即将被执行；则跳出循环</span><br>            <span class="hljs-keyword">if</span>(selectedKeys != <span class="hljs-number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;<br>                <span class="hljs-comment">//-Selected something,</span><br>                <span class="hljs-comment">//-waken up by user,or</span><br>                <span class="hljs-comment">//-the task queue has apending task.</span><br>                <span class="hljs-comment">//-a scheduled task is ready for processing</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(Thread.interrupted()) &#123;<br>                <span class="hljs-comment">//Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span><br>                <span class="hljs-comment">//As this is most likely a bug in the handler of the user or it&#x27;s client library we will</span><br>                <span class="hljs-comment">//also log it.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">//See https://github.com/netty/netty/issues/2426</span><br>                <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Selector.select() returned prematurely because &quot;</span> + <span class="hljs-string">&quot; Thread.currentThread().interrupt() was called. Use &quot;</span> + <span class="hljs-string">&quot; NioEventLoop.shutdownGracefully() to shutdowntheNioEventLoop.&quot;</span>);<br>                &#125;<br>                selectCnt = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">long</span> time = System.nanoTime();<br>            <span class="hljs-keyword">if</span>(time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;<br>                <span class="hljs-comment">//timeoutMillis elapsed without any thing selected.</span><br>                selectCnt =<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br>                <span class="hljs-comment">//The selector returned prematurely many times in a row.</span><br>                <span class="hljs-comment">//Rebuild the selector to work around the problem.</span><br>                logger.warn(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>, selectCnt, selector);<br>                rebuildSelector();<br>                selector = <span class="hljs-keyword">this</span>.selector;<br>                <span class="hljs-comment">//Select again to populate selectedKeys.</span><br>                selector.selectNow();<br>                selectCnt = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            currentTimeNanos = time;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;<br>            <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Selector.select()returned prematurely &#123;&#125; times in a row for Selector&#123;&#125;.&quot;</span>, selectCnt - <span class="hljs-number">1</span>, selector);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>        <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;<br>            logger.debug(CancelledKeyException.<span class="hljs-keyword">class</span>.getSimpleName() + <span class="hljs-string">&quot;raisedbyaSelector &#123;&#125; - JDKbug?&quot;</span>, selector, e);<br>        &#125;<br>        <span class="hljs-comment">//Harmless exception - log anyway</span><br>    &#125;<br>&#125;<span class="hljs-keyword">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selector</code>，防止 <code>selector</code> 阻塞时间过长</p><p>5.<code>EventLoop</code> 作为 <code>Netty</code> 的核心的运行机制小结</p><p>1)每次执行 <code>execute</code> 方法都是向队列中添加任务。当第一次添加时就启动线程，执行 <code>run</code> 方法，而 <code>run</code> 方法是整个 <code>EventLoop</code> 的核心，就像 <code>EventLoop</code> 的名字一样，<code>LoopLoop</code>，不停的 <code>Loop</code>，<code>Loop</code> 做什么呢？做 <code>3</code> 件事情。</p><p>调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selecor</code>，防止 <code>selector</code> 阻塞时间过长。</p><p>当 <code>selector</code> 返回的时候，回调用 <code>processSelectedKeys</code> 方法对 <code>selectKey</code> 进行处理。</p><p>当 <code>processSelectedKeys</code> 方法执行结束后，则按照 <code>ioRatio</code> 的比例执行 <code>runAllTasks</code> 方法，默认是 <code>IO</code> 任务时间和非 <code>IO</code> 任务时间是相同的，你也可以根据你的应用特点进行调优。比如非 <code>IO</code> 任务比较多，那么你就将</p><p><code>ioRatio</code> 调小一点，这样非 <code>IO</code> 任务就能执行的长一点。防止队列积攒过多的任务。</p><h2 id="10-8-handler-中加入线程池和-Context-中添加线程池的源码剖析"><strong>10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析</strong></h2><h3 id="10-8-1-源码剖析目的"><strong>10.8.1 源码剖析目的</strong></h3><ol><li>在 <code>Netty</code> 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 <code>Netty</code> 对 <code>Socket</code> 的处理速度。</li><li>而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有 <code>2</code> 种方式，而且这 <code>2</code> 种方式实现的区别也蛮大的。</li><li>处理耗时业务的第一种方式 – <code>handler</code> 中加入线程池</li><li>处理耗时业务的第二种方式 – <code>Context</code> 中添加线程池</li><li>我们就来分析下两种方式</li></ol><h3 id="10-8-2-源码剖析"><strong>10.8.2 源码剖析</strong></h3><p>说明 演示两种方式的实现，以及从源码来追踪两种方式执行流程</p><ol><li>处理耗时业务的第一种方式 – handler种加入线程池</li><li>1对前面的 <code>Netty</code> <code>demo</code>源码进行修改，在 <code>EchoServerHandler</code> 的 <code>channelRead</code> 方法进行异步</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EventExecutorGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultEventExecutorGroup</span>(<span class="hljs-number">16</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException, InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">msgCop</span> <span class="hljs-operator">=</span> msg;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelHandlerContext</span> <span class="hljs-variable">cxtCop</span> <span class="hljs-operator">=</span> ctx;<br>        group.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf)msgCop;<br>                <span class="hljs-type">byte</span>[] req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buf.readableBytes()];<br>                buf.readBytes(req);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(req, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">10</span> * <span class="hljs-number">1000</span>);<br>                System.err.println(body + <span class="hljs-string">&quot; &quot;</span> + Thread.currentThread().getName());<br>                <span class="hljs-type">String</span> <span class="hljs-variable">reqString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Helloiamserver~~~&quot;</span>;<br>                <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> Unpooled.copiedBuffer(reqString.getBytes());<br>                cxtCop.writeAndFlush(resp);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;goon..&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        ctx.flush();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;<br>        <span class="hljs-comment">// Close the connection when an exception is raised.</span><br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明： 1)在 <code>channelRead</code> 方法，模拟了一个耗时 <code>10</code> 秒的操作，这里，我们将这个任务提交到了一个自定义的业务线程池中，这样，就不会阻塞 <code>Netty</code> 的 <code>IO</code> 线程。</p><p>11.2这样处理之后，整个程序的逻辑如图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_19.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_19.png"></p><p>说明：</p><p>1)解释一下上图，当 <code>IO</code> 线程轮询到一个 <code>socket</code> 事件，然后，<code>IO</code> 线程开始处理，当走到耗时 <code>handler</code> 的时候，将耗时任务交给业务线程池。</p><p>2)当耗时任务执行完毕再执行 <code>pipeline write</code> 方法的时候，(代码中使用的是 <code>context</code> 的 <code>write</code> 方法，上图画的是执行 <code>pipeline</code> 方法，是一个意思)会将任务这个任务交给 <code>IO</code> 线程</p><p>11.3 <code>write</code> 方法的源码(在 <code>AbstractChannelHandlerContext</code> 类)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">write</span>(Object msg, <span class="hljs-keyword">boolean</span> flush, ChannelPromise promise) &#123;<br>    AbstractChannelHandlerContext <span class="hljs-keyword">next</span> = findContextOutbound();<br>    <span class="hljs-keyword">final</span> Object m = pipeline.touch(msg, <span class="hljs-keyword">next</span>);<br>    EventExecutor executor = <span class="hljs-keyword">next</span>.executor();<br>    <span class="hljs-keyword">if</span>(executor.inEventLoop()) &#123;<br>        <span class="hljs-keyword">if</span>(flush) &#123;<br>            <span class="hljs-keyword">next</span>.invokeWriteAndFlush(m, promise);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">next</span>.invokeWrite(m, promise);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        AbstractWriteTask <span class="hljs-keyword">task</span>;<br>        <span class="hljs-keyword">if</span>(flush) &#123;<br>            <span class="hljs-keyword">task</span> = WriteAndFlushTask.newInstance(<span class="hljs-keyword">next</span>, m, promise);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">task</span> = WriteTask.newInstance(<span class="hljs-keyword">next</span>, m, promise);<br>        &#125;<br>        safeExecute(executor, <span class="hljs-keyword">task</span>, promise, m);<br>    &#125;<br>&#125;<span class="hljs-keyword">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明:</p><p>1)当判定下个 <code>outbound</code> 的 <code>executor</code> 线程不是当前线程的时候，会将当前的工作封装成 <code>task</code>，然后放入 <code>mpsc</code> 队列中，等待 <code>IO</code> 任务执行完毕后执行队列中的任务。</p><p>2)这里可以 Debug 来验证(提醒：Debug 时，服务器端 Debug, 客户端 <code>Run</code> 的方式)，当我们使用了 <code>group.submit(new Callable&lt;Object&gt; ()&#123;&#125;</code> 在 <code>handler</code> 中加入线程池，就会进入到 <code>safeExecute(executor, task, promise, m);</code> 如果去掉这段代码，而使用普通方式来执行耗时的业务，那么就不会进入到 <code>safeExecute(executor, task, promise, m);</code>（说明：普通方式执行耗时代码，看我准备好的案例即可）</p><p>12.处理耗时业务的第二种方式 -<code>Context</code> 中添加线程池 1.1在添加 <code>pipeline</code> 中的 <code>handler</code> 时候，添加一个线程池</p><p>//属性</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">static final EventExecutorGroup <span class="hljs-keyword">group</span> = <span class="hljs-built_in">new</span> DefaultEventExecutorGroup(<span class="hljs-number">16</span>);<br>ServerBootstrap b = <span class="hljs-built_in">new</span> ServerBootstrap();<br>                b.<span class="hljs-keyword">group</span>(bossGroup, workerGroup)<br>                 .channel(NioServerSocketChannel.<span class="hljs-keyword">class</span>)<br>                 .<span class="hljs-keyword">option</span>(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)<br>                 .<span class="hljs-keyword">handler</span>(newLoggingHandler(LogLevel.<span class="hljs-keyword">INFO</span>))<br>                 .childHandler(<span class="hljs-built_in">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                     @Override<br>                     <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> initChannel(SocketChannel ch) throws <span class="hljs-keyword">Exception</span> &#123;<br>                         ChannelPipeline p = ch.pipeline();<br>                         <span class="hljs-keyword">if</span>(sslCtx != <span class="hljs-keyword">null</span>) &#123;<br>                             p.addLast(sslCtx.newHandler(ch.alloc()));<br>                         &#125;<br>                         //p.addLast(<span class="hljs-built_in">new</span> LoggingHandler(LogLevel.<span class="hljs-keyword">INFO</span>));<br>                         //p.addLast(<span class="hljs-built_in">new</span> EchoServerHandler());<br>                         p.addLast(<span class="hljs-keyword">group</span>, <span class="hljs-built_in">new</span> EchoServerHandler());<br>                    &#125;<br>                &#125;);<span class="hljs-keyword">Copy</span> <span class="hljs-keyword">to</span> clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>说明：</p><p>1)<code>handler</code> 中的代码就使用普通的方式来处理耗时业务。</p><p>2)当我们在调用 <code>addLast</code> 方法添加线程池后，<code>handler</code> 将优先使用这个线程池，如果不添加，将使用 <code>IO</code> 线程</p><p>3)当走到 <code>AbstractChannelHandlerContext</code> 的 <code>invokeChannelRead</code> 方法的时候，<code>executor.inEventLoop()</code> 是不会通过的，因为当前线程是 <code>IO</code> 线程 <code>Context</code>（也就是 <code>Handler</code>）的 <code>executor</code> 是业务线程，所以会异步执行，debug 下源码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> invokeChannelRead(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext <span class="hljs-keyword">next</span>, Object msg) &#123;<br>    <span class="hljs-keyword">final</span> Object m = <span class="hljs-keyword">next</span>.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), <span class="hljs-keyword">next</span>);<br>    EventExecutor executor = <span class="hljs-keyword">next</span>.executor();<br>    <span class="hljs-keyword">if</span>(executor.inEventLoop()) &#123;<br>        <span class="hljs-keyword">next</span>.invokeChannelRead(m);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-comment">//执行run</span><br>            @Override<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>                <span class="hljs-keyword">next</span>.invokeChannelRead(m);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<span class="hljs-keyword">Copy</span> to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>4)验证时，我们如果去掉 <code>p.addLast(group,newEchoServerHandler());</code> 改成 <code>p.addLastnewEchoServerHandler());</code> 你会发现代码不会进行异步执行。</p><p>5)后面的整个流程就变成和第一个方式一样了</p><p>13.两种方式的比较</p><p>1)第一种方式在 <code>handler</code> 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 <code>mpscTask</code> 中。如果 <code>IO</code> 时间很短，<code>task</code> 很多，可能一个循环下来，都没时间执行整个 <code>task</code>，导致响应时间达不到指标。</p><p>2)第二种方式是 <code>Netty</code> 标准方式(即加入到队列)，但是，这么做会将整个 <code>handler</code> 都交给业务线程池。不论耗时不耗时，都加入到队列里，不够灵活。</p><p>3)各有优劣，从灵活性考虑，第一种较好。</p><h1><strong>第 11 章 用 Netty 自己实现 Dubbo RPC</strong></h1><h2 id="11-1-RPC-基本介绍"><strong>11.1 RPC 基本介绍</strong></h2><ol><li><code>RPC（Remote Procedure Call）</code>—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li><li>两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图)</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_01.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_01.png"></p><ol><li>常见的 <code>RPC</code> 框架有：比较知名的如阿里的 <code>Dubbo</code>、<code>Google</code> 的 <code>gRPC</code>、<code>Go</code> 语言的 <code>rpcx</code>、<code>Apache</code> 的 <code>thrift</code>，<code>Spring</code> 旗下的 <code>SpringCloud</code>。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_02.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_02.png"></p><h2 id="11-2-RPC-调用流程图"><strong>11.2 RPC 调用流程图</strong></h2><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_03.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_03.png"></p><h2 id="11-3-PRC-调用流程说明"><strong>11.3 PRC 调用流程说明</strong></h2><ol><li>服务消费方（<code>client</code>）以本地调用方式调用服务</li><li><code>client stub</code> 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体</li><li><code>client stub</code> 将消息进行编码并发送到服务端</li><li><code>server stub</code> 收到消息后进行解码</li><li><code>server stub</code> 根据解码结果调用本地的服务</li><li>本地服务执行并将结果返回给 <code>server stub</code></li><li><code>server stub</code> 将返回导入结果进行编码并发送至消费方</li><li><code>client stub</code> 接收到消息并进行解码</li><li>服务消费方（<code>client</code>）得到结果</li></ol><p>小结：<code>RPC</code> 的目标就是将 <code>2 - 8</code> 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用</p><h2 id="11-4-自己实现-Dubbo-RPC（基于-Netty）"><strong>11.4 自己实现 Dubbo RPC（基于 Netty）</strong></h2><h3 id="11-4-1-需求说明"><strong>11.4.1 需求说明</strong></h3><ol><li><code>Dubbo</code> 底层使用了 <code>Netty</code> 作为网络通讯框架，要求用 <code>Netty</code> 实现一个简单的 <code>RPC</code> 框架</li><li>模仿 <code>Dubbo</code>，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 <code>Netty 4.1.20</code></li></ol><h3 id="11-4-2-设计说明"><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter11?id=_1142-%e8%ae%be%e8%ae%a1%e8%af%b4%e6%98%8e"><strong>11.4.2 设计说明</strong></a></h3><ol><li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。</li><li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。</li><li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 <code>Netty</code> 请求提供者返回数据</li><li>开发的分析图</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_04.png" alt="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_04.png"></p><h3 id="11-4-3-代码实现"><strong>11.4.3 代码实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.publicinterface;<br><br><span class="hljs-comment">//这个是接口，是服务提供方和 服务消费方都需要</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HelloService</span> &#123;<br><br>    String <span class="hljs-title function_">hello</span><span class="hljs-params">(String mes)</span>;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.provider;<br><br><span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HelloService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//当有消费方调用该方法时， 就返回一个结果</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(String mes)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;收到客户端消息=&quot;</span> + mes);<br>        <span class="hljs-comment">//根据mes 返回不同的结果</span><br>        <span class="hljs-keyword">if</span> (mes != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好客户端, 我已经收到你的消息 [&quot;</span> + mes + <span class="hljs-string">&quot;] 第&quot;</span> + (++count) + <span class="hljs-string">&quot; 次&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好客户端, 我已经收到你的消息 &quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.provider;<br><br><span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyServer;<br><br><span class="hljs-comment">//ServerBootstrap 会启动一个服务提供者，就是 NettyServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerBootstrap</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//代码代填..</span><br>        NettyServer.startServer(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<br><span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startServer</span><span class="hljs-params">(String hostName, <span class="hljs-type">int</span> port)</span> &#123;<br>        startServer0(hostName, port);<br>    &#125;<br><br>    <span class="hljs-comment">//编写一个方法，完成对NettyServer的初始化和启动</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startServer0</span><span class="hljs-params">(String hostname, <span class="hljs-type">int</span> port)</span> &#123;<br><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>            serverBootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                                      <span class="hljs-meta">@Override</span><br>                                      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                          <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                                          pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());<br>                                          pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                                          pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>()); <span class="hljs-comment">//业务处理器</span><br><br>                                      &#125;<br>                                  &#125;<br><br>                    );<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(hostname, port).sync();<br>            System.out.println(<span class="hljs-string">&quot;服务提供方开始提供服务~~&quot;</span>);<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<br><br><span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.customer.ClientBootstrap;<br><span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.provider.HelloServiceImpl;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><br><span class="hljs-comment">//服务器这边handler比较简单</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取客户端发送的消息，并调用服务</span><br>        System.out.println(<span class="hljs-string">&quot;msg=&quot;</span> + msg);<br>        <span class="hljs-comment">//客户端在调用服务器的api 时，我们需要定义一个协议</span><br>        <span class="hljs-comment">//比如我们要求 每次发消息是都必须以某个字符串开头 &quot;HelloService#hello#你好&quot;</span><br>        <span class="hljs-keyword">if</span> (msg.toString().startsWith(ClientBootstrap.providerName)) &#123;<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloServiceImpl</span>().hello(msg.toString().substring(msg.toString().lastIndexOf(<span class="hljs-string">&quot;#&quot;</span>) + <span class="hljs-number">1</span>));<br>            ctx.writeAndFlush(result);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<br><br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> ChannelHandlerContext context;<span class="hljs-comment">//上下文</span><br>    <span class="hljs-keyword">private</span> String result; <span class="hljs-comment">//返回的结果</span><br>    <span class="hljs-keyword">private</span> String para; <span class="hljs-comment">//客户端调用方法时，传入的参数</span><br><br>    <span class="hljs-comment">//与服务器的连接创建后，就会被调用, 这个方法是第一个被调用(1)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot; channelActive 被调用  &quot;</span>);<br>        context = ctx; <span class="hljs-comment">//因为我们在其它方法会使用到 ctx</span><br>    &#125;<br><br>    <span class="hljs-comment">//收到服务器的数据后，调用方法 (4)</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot; channelRead 被调用  &quot;</span>);<br>        result = msg.toString();<br>        notify(); <span class="hljs-comment">//唤醒等待的线程</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-comment">//被代理对象调用, 发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果 (3)-》5</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot; call1 被调用  &quot;</span>);<br>        context.writeAndFlush(para);<br>        <span class="hljs-comment">//进行wait</span><br>        wait(); <span class="hljs-comment">//等待channelRead 方法获取到服务器的结果后，唤醒</span><br>        System.out.println(<span class="hljs-string">&quot; call2 被调用  &quot;</span>);<br>        <span class="hljs-keyword">return</span> result; <span class="hljs-comment">//服务方返回的结果</span><br><br>    &#125;<br><br>    <span class="hljs-comment">//(2)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPara</span><span class="hljs-params">(String para)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot; setPara  &quot;</span>);<br>        <span class="hljs-built_in">this</span>.para = para;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executor;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> &#123;<br><br>    <span class="hljs-comment">//创建线程池</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> NettyClientHandler client;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//编写方法使用代理模式，获取一个代理对象</span><br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; serivceClass, <span class="hljs-keyword">final</span> String providerName)</span> &#123;<br><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[]&#123;serivceClass&#125;, (proxy, method, args) -&gt; &#123;<br><br>                    System.out.println(<span class="hljs-string">&quot;(proxy, method, args) 进入....&quot;</span> + (++count) + <span class="hljs-string">&quot; 次&quot;</span>);<br>                    <span class="hljs-comment">//&#123;&#125;  部分的代码，客户端每调用一次 hello, 就会进入到该代码</span><br>                    <span class="hljs-keyword">if</span> (client == <span class="hljs-literal">null</span>) &#123;<br>                        initClient();<br>                    &#125;<br><br>                    <span class="hljs-comment">//设置要发给服务器端的信息</span><br>                    <span class="hljs-comment">//providerName 协议头 args[0] 就是客户端调用api hello(???), 参数</span><br>                    client.setPara(providerName + args[<span class="hljs-number">0</span>]);<br><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-keyword">return</span> executor.submit(client).get();<br><br>                &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">//初始化客户端</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initClient</span><span class="hljs-params">()</span> &#123;<br>        client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientHandler</span>();<br>        <span class="hljs-comment">//创建EventLoopGroup</span><br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>        bootstrap.group(group)<br>                .channel(NioSocketChannel.class)<br>                .option(ChannelOption.TCP_NODELAY, <span class="hljs-literal">true</span>)<br>                .handler(<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());<br>                                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                                pipeline.addLast(client);<br>                            &#125;<br>                        &#125;<br>                );<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>).sync();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.customer;<br><br><span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyClient;<br><span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientBootstrap</span> &#123;<br><br>    <span class="hljs-comment">//这里定义协议头</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">providerName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HelloService#hello#&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//创建一个消费者</span><br>        <span class="hljs-type">NettyClient</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClient</span>();<br><br>        <span class="hljs-comment">//创建代理对象</span><br>        <span class="hljs-type">HelloService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> (HelloService) customer.getBean(HelloService.class, providerName);<br><br>        <span class="hljs-keyword">for</span> (; ; ) &#123;<br>            Thread.sleep(<span class="hljs-number">2</span> * <span class="hljs-number">1000</span>);<br>            <span class="hljs-comment">//通过代理对象调用服务提供者的方法(服务)</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> service.hello(<span class="hljs-string">&quot;你好 dubbo~&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;调用的结果 res= &quot;</span> + res);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Data Jpa 学习笔记</title>
    <link href="/2024/05/02/Spring%20Data%20Jpa%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    <url>/2024/05/02/Spring%20Data%20Jpa%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>官网 ；<a href="https://docs.spring.io/spring-data/jpa/reference/index.html">https://docs.spring.io/spring-data/jpa/reference/index.html</a></p></blockquote><p><img src="/img/spring-data-jpa-01.png" alt="图01"></p><h1>一、spring Data Jpa 介绍</h1><blockquote><p><strong>Jpa</strong> : JPA（Java Persistence API）是用于在Java应用程序中进行对象持久化的API，用于描述对象-关系映射（ORM）规范（就像java的JDBC规范，每个数据库厂商都有对应的实现）。</p><p><strong>Hibernate</strong> ：Hibernate 是一个流行的开源对象-关系映射（ORM）框架，它实现了JPA（Java Persistence API）规范，为Java应用程序提供了数据持久化的解决方案。</p><p><strong>Spring Data JPA</strong>：Spring Data JPA 是 Spring 框架中的一个模块，它简化了对于基于 JPA (Java Persistence API) 的数据访问层的开发。JPA 是 Java EE 中用于对象持久化的标准，而 Spring Data JPA 则在其基础上提供了一系列便捷的功能，帮助开发者更轻松地与数据库进行交互。</p><p><strong>Spring Data:</strong> Spring Data是Spring生态中的一个项目，目标就是简化对数据访问的开发，个人觉得spring的野心很大，它并不限于关系型数据库，还支持文档型数据库，NoSQL数据库。</p></blockquote><p>简单来说 Spring Data Jpa 是spring对Jpa规范的在一次封装，目的就是简化数据库操作。最大特点就是</p><p><strong>Defining Query Methods</strong>定义查询方法。第一次接触的时候感觉很神奇。通过对方法名的解析就能自动生成查询语句。</p><h1>二、快速入门</h1><ol><li>引入maven坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>创建实体类 和 repository接口 还有启动类的开启Jpa ,代码中对应解释</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> chances.learn.jpa.entity;<br><br><span class="hljs-meta">@Entity</span> <span class="hljs-comment">//@Entity是用来标识实体类，spring会把有这个注解的类</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Table(name=&quot;sc_person&quot;)</span>  <span class="hljs-comment">//对应数据库表名，也可以根据name生成属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-meta">@Id</span>   <span class="hljs-comment">//标识主键</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>  <span class="hljs-comment">//主键生成策略</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>&#125;<br><br>-- ------------------------------------------------------------------------<br><span class="hljs-comment">//Repository接口是 Jpa中最核心的接口，</span><br><span class="hljs-comment">// 继承之后例如 findByLastName(String lastName) 将会自动生成根据 lastName 查询实体的方法</span><br><span class="hljs-keyword">package</span> chances.learn.jpa.repo;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Repository</span>&lt;Person, Long&gt; &#123;<br><br>  Person <span class="hljs-title function_">save</span><span class="hljs-params">(Person person)</span>;<br>  Optional&lt;Person&gt; <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>;<br>&#125;<br><br>-- ------------------------------------------------------------------------<br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableJpaRepositories(basePackages = &quot;chances.learn.jpa.repo&quot;)</span><br><span class="hljs-meta">@EntityScan(&quot;chances.learn.jpa.repo.entity&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaLearnApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(JpaLearnApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>我们测试一下看看结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaLearnApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    PersonRepository personRepository;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        person.setName(<span class="hljs-string">&quot;shichong_update&quot;</span>);<br>        person.setAge(<span class="hljs-number">20</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">save</span> <span class="hljs-operator">=</span> personRepository.save(person);<br>        log.info(<span class="hljs-string">&quot;sava result：&#123;&#125;&quot;</span>,save.toString());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://chances.feishu.cn/space/api/box/stream/download/asynccode/?code=MWQxMWVjMTFkZTcxYTJlMGMyZTkzNWZhZWIzNWE2ZmNfUDh1S0M4VWNZSURyc3dRYlVqd1V6QUx3NmhjSXJJN3pfVG9rZW46R2tFNWJQckhab0gxR1h4MlpiRmNtZGxwblpiXzE3MTQ5MDIzMzg6MTcxNDkwNTkzOF9WNA" alt="img"></p><p><img src="https://chances.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDI2NTAzMDM3ZTRlMmZkZjY5YThhZTBiODk4YjE2ZDNfanpueGc0OTBhcWt0YjJpZXBTUnBMdm5hT1V2WWd5UkZfVG9rZW46V3ZTS2JEMVlEb2NJTnd4TW1VUWMyUFZXblllXzE3MTQ5MDIzMzg6MTcxNDkwNTkzOF9WNA" alt="img"></p><h1>三、核心接口</h1><p>Spring Data抽象出来的顶层接口是<code> Repository</code>。 直接或间接实现这个接口才有操作数据的能力，不限于关系型数据库，还支持Redis ，MangoDB等。</p><p>Spring data jpa 通过解析方法名自动去生成查询sql。为了简化开发者开发，也提供了一些带有常用查询方法的接口，我们只需要直接实现就可以使用。例如CrudRepository ，ListCrudRepository ,JpaRepository,PagingAndSortingRepository等接口，每一个接口都补充了一些特定的功能下面是我在idea中查看的关系图，</p><p><img src="https://chances.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDU1ZmY3MTZlNjYxZDI3ODkyMGQyZGZlZDYwZGE5ODhfdkNPOElZOWN5MFphajhZMnNyUkFNZzA4V3BxU3MwSUFfVG9rZW46WGZPSWI0dFMwb3EyYjd4eWdNNWNLOGp3blRmXzE3MTQ5MDIzMzg6MTcxNDkwNTkzOF9WNA" alt="img"></p><h2 id="3-1-CrudRepository接口-增删改查接口">3.1 CrudRepository接口 增删改查接口</h2><p>对比实现普通Repository和CrudRepository，看一看UserRepository会发生什么变化</p><ul><li>实现Repository。</li></ul><p><img src="https://chances.feishu.cn/space/api/box/stream/download/asynccode/?code=MWFjODNhNTlhM2YwODU3OGRjNjVhNTUxZWIyYjFiNzhfYTlKNHN3S0xJT3lIMDF5eFdQVE5Qd2szS01nWllwT3BfVG9rZW46UTVVTWJxRUJEb2kyUm94UE5zR2NjOFZSbk5kXzE3MTQ5MDIzMzg6MTcxNDkwNTkzOF9WNA" alt="img"></p><ul><li>实现CrudRepository</li></ul><p><img src="https://chances.feishu.cn/space/api/box/stream/download/asynccode/?code=NTBiODk3M2M5NjRiNjM3ZGFiOTdiZTI0MjBhOThkMGJfNGFmNFdPaUdaZVhHMTBLR0d4TlppNlQyZHBDM3ZBQW5fVG9rZW46SUpKMmJERjJob2pkZjd4R3lEWWN0OEZ2bklnXzE3MTQ5MDIzMzg6MTcxNDkwNTkzOF9WNA" alt="img"></p><ul><li>总结，CrudRepository就和我们自己定义的repository是一样的原理，只不过声明好了一些通用的方法，搭配泛型就可以复用一些通用的操作.看一下源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="hljs-comment">// (powered by FernFlower decompiler)</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">package</span> org.springframework.data.repository;<br><br><span class="hljs-keyword">import</span> java.util.Optional;<br><br><span class="hljs-meta">@NoRepositoryBean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CrudRepository</span>&lt;T, ID&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Repository</span>&lt;T, ID&gt; &#123;<br>    &lt;S <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; S <span class="hljs-title function_">save</span><span class="hljs-params">(S entity)</span>;<br><br>    &lt;S <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; Iterable&lt;S&gt; <span class="hljs-title function_">saveAll</span><span class="hljs-params">(Iterable&lt;S&gt; entities)</span>;<br><br>    Optional&lt;T&gt; <span class="hljs-title function_">findById</span><span class="hljs-params">(ID id)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">existsById</span><span class="hljs-params">(ID id)</span>;<br><br>    Iterable&lt;T&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>;<br><br>    Iterable&lt;T&gt; <span class="hljs-title function_">findAllById</span><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span>;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(ID id)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(T entity)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAllById</span><span class="hljs-params">(Iterable&lt;? extends ID&gt; ids)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAll</span><span class="hljs-params">(Iterable&lt;? extends T&gt; entities)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>@NoRepositoryBean：  因为继承了repository接口spring会认为他也是一个bean，实际并不是只是中间扩展接口，所以使用@NoRepositoryBean标识一下 就不会当作Bean处理了</li></ul><p>支持分页接口</p><h2 id="3-2-PagingAndSortingRepository-分页排序接口">3.2 PagingAndSortingRepository 分页排序接口</h2><ol><li>使用的时候直接继承这个接口即可,声明一个方法返回结果为 page 字面意思理解就是<ol><li><pre><code class="language-Java">package chances.learn.jpa.repo;import chances.learn.jpa.entity.Person;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.repository.CrudRepository;import org.springframework.data.repository.PagingAndSortingRepository;import org.springframework.data.repository.Repository;import java.util.Optional;public interface PersonRepository extends CrudRepository&lt;Person, Long&gt;, PagingAndSortingRepository&lt;Person,Long&gt; &#123;  Person save(Person person);    Page&lt;Person&gt; findAll(String name, Pageable pageable);  Optional&lt;Person&gt; findById(long id);&#125;<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-number">2</span>. 开始<span class="hljs-selector-tag">unit</span> <span class="hljs-selector-tag">test</span> ，创建分页查询条件时候 使用<span class="hljs-selector-tag">PageRequest</span><span class="hljs-selector-class">.of</span>方法 。看看数据库和结果。<br>   <span class="hljs-number">1</span>. !<span class="hljs-selector-attr">[img]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//chances.feishu.cn/space/api/box/stream/download/asynccode/?code=MTliOTRmNmQyMDA0ZDZlNGQ2NzFiNjMyYjQ2OWU5YjFfenZtMFJzTlg0R3hKNmlWTno4SWcxTWJBZ2xlUkQ3ZkNfVG9rZW46RDdlRmJsMUFOb0tuVlJ4eWxUS2N2YWRhbjJkXzE3MTQ5MDIzMzg6MTcxNDkwNTkzOF9WNA)</span><br><br>   <span class="hljs-number">2</span>. ![img](<span class="hljs-attribute">https</span>:<span class="hljs-comment">//chances.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTI4YmM1NzA2ZGExMzMzYzE0ZDZhYTUyYTliYmM2YjBfUGhyOUMzUERzQU1XMFZKZk9vWVljM0Ezb3lpSWNiZFRfVG9rZW46TFVCamJmbWpZb3BnaTZ4MXFPcWNFa3hzbmNoXzE3MTQ5MDIzMzg6MTcxNDkwNTkzOF9WNA)</span><br><br>   <span class="hljs-number">3</span>. <span class="hljs-built_in">``</span>`Java<br>      <span class="hljs-variable">@Test</span><br>      void <span class="hljs-built_in">page</span>() &#123;<br>          <span class="hljs-comment">//每页两条 第一页 按照age降序</span><br>          Sort sort = Sort.<span class="hljs-built_in">by</span>(Sort.Direction.DESC, <span class="hljs-string">&quot;age&quot;</span>);<br>          Page&lt;Person&gt; all = personRepository.<span class="hljs-built_in">findAll</span>(PageRequest.<span class="hljs-built_in">of</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>          log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;page result：&#123;&#125;&quot;</span>,all.<span class="hljs-built_in">toString</span>());<br>      &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ol></li></ol><h2 id="3-3-JpaRepository-整合了常用的数据库操作">3.3 JpaRepository 整合了常用的数据库操作</h2><p>通过扩展 <code>JpaRepository</code>，继承基本的 CRUD（创建、读取、更新、删除）操作，以及使用 Spring Data 的本地查询进行分页、排序方法。这个接口简化了 Spring 应用程序中数据访问层的开发，减少了与数据库操作通常相关的样板代码。</p><p>在debug的时候发现一件事情，发现PersonRepository经过动态代理之后已经变成了SimpleJpaRepository类型，</p><p><img src="https://chances.feishu.cn/space/api/box/stream/download/asynccode/?code=MTRjZWU3ODZjMDIxNDEwNjJhNGU1ZjhjZjEzZGQxNzVfamFsRDNRU2VBNGtWMXFOZUY2V2ZOT0sySnhCVFU5N0hfVG9rZW46TlJyemJhUTFab0ZDbWt4YUdPRGM0NHZvbmhnXzE3MTQ5MDIzMzg6MTcxNDkwNTkzOF9WNA" alt="img"></p><h1>四、Defining Query Methods 定义查询方法（Jpa特色）</h1><p><img src="https://chances.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGI3MDM5ZDY3MzJhYzI1OGJiZGYzNjc3NDNjMGVjZjNfSXlEdG5YQmxGR3d6dmxRWHZ4VnQySjNLMG5LaFo2VXVfVG9rZW46VXlXT2JGS0ZSb3J1ZTl4UXRZMGNhQWt5bmhjXzE3MTQ5MDIzMzg6MTcxNDkwNTkzOF9WNA" alt="img"></p><p>Defining Query Method是Jpa的一大特性。定义查询方法有官网说明<strong>提供了两种方式</strong>。第一种 通过直接从方法名称解析后查询，第二种 通过手动定义方式的来执行。</p><p>简单示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//第一种 没有sql直接解析方法名</span><br>Optional&lt;LoginToken&gt; <span class="hljs-title function_">findByUserId</span><span class="hljs-params">(String userId)</span>;<br><br><span class="hljs-comment">//第二种</span><br><span class="hljs-meta">@Query(&quot;select e from SysUser e where e.userName = :userName and e.deleted = false&quot;)</span><br>Optional&lt;SysUser&gt; <span class="hljs-title function_">findByUserName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userName&quot;)</span> String userName)</span>;<br></code></pre></td></tr></table></figure><h2 id="4-1-Query-Lookup-Strategies查询查找策略">4.1 Query Lookup Strategies查询查找策略</h2><p><img src="https://chances.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGU4ZDI1MGFkNTRlNTU3ZjRmNmY1MDdmMGIwNmEyMTRfeld5UWpiQ0lPb2ZWOWlHVElLUVE2VUN3Z3V0NmtEQ1VfVG9rZW46Unk5S2JJTFE3b0lWZG14dDVFRGNPaWJwblFmXzE3MTQ5MDIzMzg6MTcxNDkwNTkzOF9WNA" alt="img"></p><p>在 Spring Data JPA 中，有两种主要的方式来定义查询方法：基于方法名的命名约定和使用 <code>@Query</code> 注解定义的自定义查询。查询查找策略决定了 Spring Data JPA 在执行方法时应该优先考虑哪种方式。官网中告诉我们一共有三种选择策略模式，和如何切换查找策略。</p><ul><li><code>CREATE</code> 从方法名解析删除指定的前缀 例如 find,findAll，然后解析方法名的其余部分。也就是直接根据方法名创建查询。如果方法名不符合规则启动会报异常，及时配置了 <code>@query</code> 注解</li><li><em><code>USE_DECLARED_QUERY</code></em> <em>使用声明好的查询，也就是使用</em>*<code>@query</code>* <em>注解声明的查询，如果没找到也会抛出异常。</em></li><li><code>CREATE_IF_NOT_FOUND</code> 这是默认的查找策略，先去使用<code>@Quer</code>y声明好的查询，如果找不到再去使用通过方法名创建查询。</li></ul><p>更改默认的策略修改<code>@EnableJpaRepositories</code>的queryLookupStrategy属性即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> chances.learn.jpa;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableJpaRepositories(basePackages=&quot;chances.learn.jpa.repo&quot;, queryLookupStrategy= QueryLookupStrategy.Key.CREATE)</span><br><span class="hljs-meta">@EntityScan(&quot;chances.learn.jpa.entity&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaLearnApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(JpaLearnApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-通过方法名解析查询">4.2 通过方法名解析查询</h2><p>下面是官网给出的示例，可以看出方法名是通过<strong>前缀+字段名+字段描述符</strong>+…组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Repository</span>&lt;Person, Long&gt; &#123;<br>    <br>  List&lt;Person&gt; <span class="hljs-title function_">findByEmailAddressAndLastname</span><span class="hljs-params">(EmailAddress emailAddress, String lastname)</span>;<br><br>  <span class="hljs-comment">// Enables the distinct flag for the query</span><br>  List&lt;Person&gt; <span class="hljs-title function_">findDistinctPeopleByLastnameOrFirstname</span><span class="hljs-params">(String lastname, String firstname)</span>;<br>  List&lt;Person&gt; <span class="hljs-title function_">findPeopleDistinctByLastnameOrFirstname</span><span class="hljs-params">(String lastname, String firstname)</span>;<br><br>  <span class="hljs-comment">// Enabling ignoring case for an individual property</span><br>  List&lt;Person&gt; <span class="hljs-title function_">findByLastnameIgnoreCase</span><span class="hljs-params">(String lastname)</span>;<br>  <span class="hljs-comment">// Enabling ignoring case for all suitable properties</span><br>  List&lt;Person&gt; <span class="hljs-title function_">findByLastnameAndFirstnameAllIgnoreCase</span><span class="hljs-params">(String lastname, String firstname)</span>;<br><br>  <span class="hljs-comment">// Enabling static ORDER BY for a query</span><br>  List&lt;Person&gt; <span class="hljs-title function_">findByLastnameOrderByFirstnameAsc</span><span class="hljs-params">(String lastname)</span>;<br>  List&lt;Person&gt; <span class="hljs-title function_">findByLastnameOrderByFirstnameDesc</span><span class="hljs-params">(String lastname)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前缀不仅有find还有 count，delete,remove等其他的前缀。每个版本可能支持的都不一样可以看看Jpa的查询解析语法树看看。 <code>org.springframework.data.repository.query.parser.PartTree</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.repository</span><span class="hljs-selector-class">.query</span><span class="hljs-selector-class">.parser</span><span class="hljs-selector-class">.Part</span>.Type<br></code></pre></td></tr></table></figure><p><img src="https://chances.feishu.cn/space/api/box/stream/download/asynccode/?code=YWJhNDAzMmM3ZTkyZjBjNzA5ZDBkNjNiZTRhNzJhZDRfeldSa1QzU0xySkNyVFd6cWtsc01kNE9GclpHOWFkWFhfVG9rZW46TlVWNGJsS09Eb0NlQ1p4T2VNb2NZY3FwbklnXzE3MTQ5MDIzMzg6MTcxNDkwNTkzOF9WNA" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security</title>
    <link href="/2023/09/13/SpringSecurity%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/13/SpringSecurity%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>Spring Security</h1><p>SpringSecurity 安全管理框架 ( 之后简称 security ) 是基于过滤器实现的权限验证功能，他可以验证用户的身份以及所拥有的权限来判断你是否具有访问目标资源的条件</p><p>安全管理框架除了 security 之外还有 shiro 也可以实现相同的功能，相比之下 security 就笨重一些，但是相对的带来的好处就是相比 shiro，security 对于访问权限的把控细粒度比较好</p><p>笔记基于 Springboot 2.4.0 的 web 程序通过 Java 代码 + 注解的方式进行配置 ( 不使用 xml 配置文件 )</p><h2 id="快速开始">快速开始</h2><p>创建好 boot 程序之后，导入静态素材页面至 templates 目录下，配置好三个 level 的视图 ( 页面来自狂神说 ) 跳转就可以开始练习了</p><p><img src="/img/security-01.png" alt=""></p><p>boot 项目添加 security 环境需要在项目创建时勾选 security 模块，或者手动在 pom 文件中添加场景启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- security场景启动器，除此之外还引用了web、thymeleaf、test、lombok... --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们将依赖引入后，无需做任何的配置，security 就已经开始工作了，他默认会验证所有请求只有登录的情况下才可以访问，并且为我们提供了登录页面：</p><p><img src="/img/security-02.jpg" alt=""></p><p>security 默认提供的登录用户名为 <code>user</code>，登录密码是随机分配的，通过查看程序启动日志就可以看到：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Using</span> <span class="hljs-keyword">generated</span> <span class="hljs-keyword">security</span> <span class="hljs-keyword">password</span>: f20e3e53-b7fc<span class="hljs-number">-4</span>a3b<span class="hljs-number">-9</span>d53-f6cc57b9c586<br></code></pre></td></tr></table></figure><p>输入用户名密码后我们就可以登录了，security 非常的智能，他会记录被拦截之前访问的页面，登录后 security 会重新访问该页面以方便操作，这就是 security 最简单的登录验证了</p><h2 id="访问权限设置-一">访问权限设置(一)</h2><blockquote><p>请求的授权验证和放行</p></blockquote><p>我们可以看到，security 的默认配置连 index 首页也访问不了，这不是我想要的，我们要调整一下页面的访问权限，这里需要创建 security 的配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * SpringSecurity的配置类要求</span><br><span class="hljs-comment"> *   1.标注了<span class="hljs-doctag">@EnableWebSecurity</span>注解</span><br><span class="hljs-comment"> *   2.继承了WebSecurityConfigurerAdapter抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>配置类创建好了，接下来需要复写其中的 <code>configure</code> 方法来自定义访问权限，这里需要注意的是重写的方法是重载方法，参数列表为：<code>HttpSecurity http</code> 不要重写错了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 请求流程：访问控制器 GetMapping(&quot;/&quot;) 跳转到视图 &quot;index.html&quot;</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// authorizeRequests：这里要设置根据请求进行授权验证</span><br>        http.authorizeRequests()<br>                <span class="hljs-comment">// antMatchers：如果方法访问的是这些请求地址</span><br>                .antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>)<br>                <span class="hljs-comment">// permitAll：不进行验证，直接放行可直接进行访问</span><br>                .permitAll()<br>                <span class="hljs-comment">// 剩下的所有请求</span><br>                .anyRequest()<br>                <span class="hljs-comment">// 都要进行授权验证</span><br>                .authenticated();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>所有关于请求验证方面的操作都需要在 <strong>http.authorizeRequests()</strong> 下进行</li></ul><p>对哪些请求操作可以通过 <code>antMatchers</code> 进行添加，例如对 / 或者对 index.html 请求进行操作，<code>anyRequest</code> 代表剩下的所有请求，而具体执行什么操作可以通过 <code>permitAll</code> 和 <code>authenticated</code> 进行设置</p><p>如上设置后，就可以在未登录的情况下访问 index 程序首页，而访问 level1 2 3 等就需要进行登录，直接访问会提示 403 Forbidden 没有权限访问</p><p><img src="/img/security-03.jpg" alt=""></p><h2 id="登录表单设置">登录表单设置</h2><h3 id="简单登录授权">简单登录授权</h3><p>上面通过重写 <code>configure(HttpSecurity http)</code> 方法实现了请求的授权与放行，以及授权失败后的 403 页面，但是之前我们没有设置的时候他会自动跳转到登录页面，这个时候我们就需要添加一下表单的相关设置了</p><p>之前说过 <code>authorizeRequests</code> 是根据请求进行授权验证，验证部分结束后开始进行表单方面设置，需要使用 <code>formLogin</code> 来对表单进行操作，<strong>当进行两种不同操作的时候，中间需要用 <code>and()</code> 连接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http.authorizeRequests()  <span class="hljs-comment">// 根据请求请求进行验证</span><br>                .antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>).permitAll()<br>                .anyRequest().authenticated()<br>                .and()<br>            <span class="hljs-comment">// 添加表单方面的设置</span><br>            .formLogin();  <span class="hljs-comment">// 这一句话就可以开启登录表单了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加 <code>formLogin</code> 之后，访问 level 1 2 3 页面就会自动跳转到 security 为我们提供的登录页，输入用户名密码后所有页面就都可以访问了</p><h3 id="自定义登录设置">自定义登录设置</h3><blockquote><p>登录页面设置</p></blockquote><p>security 为我们提供了登录页面很方便，但是有点不太好看，我们在程序中要求每个页面都要贴合主题的，这个页面未免有些太突兀了，所以这里我们要自定义登录页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http.authorizeRequests()  <span class="hljs-comment">// 根据请求请求进行验证</span><br>                <span class="hljs-comment">// 涉及到所有有关请求的路径都需要在这里配置过滤</span><br>                .antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/toLogin&quot;</span>,<br>                             <span class="hljs-string">&quot;/views/login.html&quot;</span>, <span class="hljs-string">&quot;/login&quot;</span>)<br>                .permitAll().anyRequest().authenticated()<br>                .and()<br>            .formLogin()<br>                .loginPage(<span class="hljs-string">&quot;/toLogin&quot;</span>);  <span class="hljs-comment">// 自定义登录页为toLogin地址</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单配置 <code>loginPage</code> 之后，我们的自定义登录页就完成了，接下来我们修改修改一下表单的 name 以及提交地址</p><blockquote><p>修改表单提交地址以及表单项</p></blockquote><p>security 提供的登录页表单的 name 和提交的 action 地址都是预设好的，所以这里我们要先获取一下然后放到自己的登录页面中</p><p><img src="/img/security-04.jpg" alt=""></p><p>当我们配置好要求后去进行登录，结果 <strong>请求的地址不存在404</strong>，这是因为我们在<strong>自定义登录页面的同时也影响到了表单提交地址</strong>，<em>表单的提交地址和自定义的登录地址相同</em>，也就是说我们通过 get 请求访问 toLogin 跳转到了登录页面，然后需要通过 post 请求访问 toLogin 进行登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    http.authorizeRequests()  <span class="hljs-comment">// 根据请求请求进行验证</span><br>        .antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/toLogin&quot;</span>,<br>                     <span class="hljs-string">&quot;/views/login.html&quot;</span>, <span class="hljs-string">&quot;/doLogin&quot;</span>)<br>        .permitAll().anyRequest().authenticated()<br>        .and()<br>        .formLogin()<br>        .loginPage(<span class="hljs-string">&quot;/toLogin&quot;</span>)  <span class="hljs-comment">// 自定义登录页</span><br>        .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>); <span class="hljs-comment">// 表单的POST提交地址接口，无需自己实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有些时候我们的登录名并不是 username 以及 password，可能是一些其他的值，而且表单的提交地址也不想和页面使用同一个地址，这里我们都可以通过自定义操作来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    http.authorizeRequests()  <span class="hljs-comment">// 根据请求请求进行验证</span><br>        .antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/toLogin&quot;</span>,<br>                     <span class="hljs-string">&quot;/views/login.html&quot;</span>, <span class="hljs-string">&quot;/doLogin&quot;</span>)<br>        .permitAll().anyRequest().authenticated()<br>        .and()<br>        .formLogin()<br>        .loginPage(<span class="hljs-string">&quot;/toLogin&quot;</span>)<br>        .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)<br>        .usernameParameter(<span class="hljs-string">&quot;name&quot;</span>)  <span class="hljs-comment">// 自定义username表单的name属性值</span><br>        .passwordParameter(<span class="hljs-string">&quot;pwd&quot;</span>)  <span class="hljs-comment">// 自定义password表单中的name属性值</span><br>        .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>);  <span class="hljs-comment">// 自定义表单请求地址</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="登录成功后的视图跳转">登录成功后的视图跳转</h3><p>这里了解一下登录成功和失败的页面跳转处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http.authorizeRequests()  <span class="hljs-comment">// 根据请求请求进行验证</span><br>                .antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/toLogin&quot;</span>,<span class="hljs-string">&quot;/views/login.html&quot;</span>,<br>                       <span class="hljs-string">&quot;/doLogin&quot;</span>, <span class="hljs-string">&quot;/toPage/success&quot;</span>)<br>                .permitAll().anyRequest().authenticated()<br>                .and()<br>            .formLogin()<br>                .loginPage(<span class="hljs-string">&quot;/toLogin&quot;</span>)<br>                .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)<br>                .usernameParameter(<span class="hljs-string">&quot;name&quot;</span>)<br>                .passwordParameter(<span class="hljs-string">&quot;pwd&quot;</span>)<br>                <span class="hljs-comment">// 登录成功后默认跳转的页面</span><br>                .defaultSuccessUrl(<span class="hljs-string">&quot;/toPage/success&quot;</span>)<br>             <span class="hljs-comment">// 登录失败后跳转的页面</span><br>                .failureUrl(<span class="hljs-string">&quot;/toPage/error&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里需要注意的是 <code>defaultSuccessUrl</code> 设置的是默认成功的页面，但如果是通过访问其他页面被过滤后跳转到登录页的话，这项设置就不会起作用</li></ul><h2 id="用户登录设置">用户登录设置</h2><p>之前我们登录时都是通过日志提供的用户名密码进行登录，接下来我们就使用自己的用户进行登录</p><p>我们在实现请求验证以及表单操作的时候都是复写了父类的 <code>configure(HttpSecurity http)</code> 完成操作的，接下来的用户登录相关操作需要复写另外一个方法：<code>configure(AuthenticationManagerBuilder auth)</code></p><h3 id="内存模拟登录">内存模拟登录</h3><p>首先复写父类中的函数，然后配置内存模拟登陆，需要提一嘴的是高版本的 security 要求必须使用加密：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">PasswordEncoder</span> <span class="hljs-variable">noEncrypt</span> <span class="hljs-operator">=</span> NoOpPasswordEncoder.getInstance();<br>    auth.inMemoryAuthentication()  <span class="hljs-comment">// 在内存中模拟用户</span><br>        .passwordEncoder(noEncrypt) <span class="hljs-comment">// 设置加密方式</span><br>        .withUser(<span class="hljs-string">&quot;zhang&quot;</span>)    <span class="hljs-comment">// 添加用户</span><br>        .password(<span class="hljs-string">&quot;hanzhe&quot;</span>)<br>        .authorities(<span class="hljs-string">&quot;用户列表:查询&quot;</span>)<br>        .and()  <span class="hljs-comment">// 通过and()连接无限添加用户</span><br>        .withUser(<span class="hljs-string">&quot;admin&quot;</span>)<br>        .password(<span class="hljs-string">&quot;admin&quot;</span>)<br>        .roles(<span class="hljs-string">&quot;管理员&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>inMemoryAuthentication</code>：代表用户信息在内存中取</li><li><code>passwordEncoder</code>：<strong>高版本的 security 要求必须对登录密码进行加密</strong>，但是我们测试时不想使用加密，所以就通过 <code>NoOpPasswordEncoder</code> 获取了实例，这个实例并不会对密码进行加密，他作用就是占个位，从而实现配置了加密的同时不执行加密操作，加密具体后面会提</li><li><code>withUser</code>：添加用户，需要传入用户名进行登录，后面紧跟的几个方法就是当前用户的 <code>password</code> 密码，<code>roles</code> 角色和 <code>authorities</code> 权限等，通过 <code>and</code> 可以无限链接添加用户</li><li>注意事项：<ul><li>每个用户应至少拥有一个角色或者权限，否则不允许登录</li><li>角色和权限的命名都不允许使用 “ROLE_” 开头</li></ul></li></ul><p>这样一来内存模拟登录就简单完成了，启动程序后最明显的就是日志中不会在提供 user 用户，我们可以通过自己添加的用户进行登录。</p><h3 id="连接数据库登录">连接数据库登录</h3><blockquote><p>前置准备：entity dao service</p></blockquote><p><i>这里简单偷个懒，在Service中写了假数据没有 dao没连数据库，不过道理是一样的</i></p><p>上面我们通过 <code>inMemoryAuthentication</code> 来模拟内存登录，接下来通过 <strong><code>UserDetailsService</code></strong> 来进行登录，准备好实体类以及 service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实体类</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span> &#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// service层</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br> <span class="hljs-comment">// 用于存储用户列表</span><br>    <span class="hljs-keyword">private</span> List&lt;UserEntity&gt; userList = <span class="hljs-literal">null</span>;<br> <span class="hljs-comment">// 模拟的用户假数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initUserList</span><span class="hljs-params">()</span> &#123;<br>        userList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;zhang&quot;</span>, <span class="hljs-string">&quot;18D7044C8EAF484A1C498379BA770E1E&quot;</span>));<br>        userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;21232F297A57A5A743894A0E4A801FC3&quot;</span>));<br>    &#125;<br> <span class="hljs-comment">// 通过用户名查找用户的方法</span><br>    <span class="hljs-keyword">public</span> UserEntity <span class="hljs-title function_">selectUserByUsername</span><span class="hljs-params">(String username)</span>&#123;<br>        <span class="hljs-comment">// 每次获取信息之前都要重置一下用户列表</span><br>        <span class="hljs-built_in">this</span>.initUserList();<br>        List&lt;UserEntity&gt; collect = userList.stream()<br>                .filter(item -&gt; item.getUsername().equals(username))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> collect.size() == <span class="hljs-number">1</span> ? collect.get(<span class="hljs-number">0</span>) : <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>配置类代码</p></blockquote><p>之前配置在内存中登录时使用的是 <code>auth.inMemoryAuthentication()</code> 方法，这回配置数据库登录后使用的是 <code>auth.userDetailsService</code> 方法，这里需要传入 <code>UserDetailsService</code> 的实例，而<code>UserDetailsService</code> 实际上是一个接口，而且是支持函数式的接口，这里就使用 lambda 表达式进行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">PasswordEncoder</span> <span class="hljs-variable">noEncrypt</span> <span class="hljs-operator">=</span> NoOpPasswordEncoder.getInstance();<br>    <span class="hljs-comment">// 函数接收的username就是登录表单提交的username</span><br>    auth.userDetailsService((String username)-&gt;&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 这个集合是必须得有的，用于存储角色和权限的集合，其中角色由 &quot;ROLE_&quot; 开头，权限正常添</span><br><span class="hljs-comment">         * 加即可，正是因为这里需要通过 ROLE_ 开头来区分角色和权限，所以我们自己创建角色或权限</span><br><span class="hljs-comment">         * 的时候不可以使用 ROLE_ 开头，不然在这个地方会影响程序的运行</span><br><span class="hljs-comment">         */</span><br>        List&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 通过username查询该用户的实体信息</span><br>        <span class="hljs-type">UserEntity</span> <span class="hljs-variable">userEntity</span> <span class="hljs-operator">=</span> userService.selectUserByUsername(username);<br>        <span class="hljs-comment">// 通过用户查询他所拥有的权限以及角色，然后插入到集合中</span><br>        <span class="hljs-keyword">if</span> ( <span class="hljs-string">&quot;admin&quot;</span>.equals(username) )    <span class="hljs-comment">// 角色要以ROLE_开头存储</span><br>            authorities.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGrantedAuthority</span>(<span class="hljs-string">&quot;ROLE_管理员&quot;</span>));<br>        <span class="hljs-keyword">else</span> authorities.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGrantedAuthority</span>(<span class="hljs-string">&quot;用户列表:查询&quot;</span>));<br>        <span class="hljs-comment">// 最后将用户名，密码，权限信息等封装为一个User对象，需要注意这个User是security包下的类</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(username, userEntity.getPassword(), authorities);<br>    &#125;).passwordEncoder(noEncrypt); <span class="hljs-comment">// 加密配置不能忘</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来就配置完成了，只要自行连接数据库通过 service 调用 dao，这就是一个数据库的登录</p><h3 id="关于加密配置">关于加密配置</h3><p>无论是内存模拟登录 <code>inMemoryAuthentication</code> 还是数据库登录 <code>userDetailsService</code>，在用户信息配置完成之后都会调用 <code>passwordEncoder</code> 传入一个加密实例进行密码加密，之前图省事用了 <code>NoOpPasswordEncoder</code> 的实例，他的作用是不对密码进行加密操作，当我们在真实开发环境下的时候数据库是不建议存储明文密码的，所以在 security 中加密是必须配置的，这里就了解一下如何配置加密</p><h4 id="使用MD5加密">使用MD5加密</h4><blockquote><p>首先准备 MD5 的加密工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MD5Util</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toMD5</span><span class="hljs-params">(String source)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">MessageDigest</span> <span class="hljs-variable">md5</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">&quot;MD5&quot;</span>);<br>            <span class="hljs-type">byte</span>[] digest = md5.digest(source.getBytes());<br>            target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(<span class="hljs-number">1</span>, digest).toString(<span class="hljs-number">16</span>).toUpperCase();<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>创建Security的密码加密配置类</p></blockquote><p>点进 <code>passwordEncoder</code> 方法，我们可以看到他需要的是 <code>PasswordEncoder</code> 的实例，那就创建一个类来实现这个 <code>PasswordEncoder</code> 接口类来自定义加密：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Security的密码加密类，只需要实现encode和matches方法即可</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PwdEncoderConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PasswordEncoder</span> &#123;<br> <span class="hljs-comment">// 用于密码加密的方法，rawPassword为我们在表单提交的明文密码</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(CharSequence rawPassword)</span> &#123;<br>        <span class="hljs-keyword">return</span> MD5Util.toMD5(rawPassword.toString());<br>    &#125;<br>    <span class="hljs-comment">// 用于比较两个密码是否相同，rawPassword为表单密码，encodedPassword为数据库密码</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span> &#123;<br>        <span class="hljs-keyword">return</span> MD5Util.toMD5(rawPassword.toString()).equals(encodedPassword);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>回到 Security 配置类配置类中传入加密对象即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 省略一大滩代码</span><br>    auth.userDetailsService((String username)-&gt;&#123;......&#125;)<br>        <span class="hljs-comment">// 这里传入了自定义的MD5加密算法</span><br>        .passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PwdEncoderConfig</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>将 service 中测试的密码通过 md5 加密一下就可以验证效果了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;zhang&quot;</span>, <span class="hljs-string">&quot;18D7044C8EAF484A1C498379BA770E1E&quot;</span>));  <span class="hljs-comment">// hanzhe</span><br>userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;21232F297A57A5A743894A0E4A801FC3&quot;</span>));  <span class="hljs-comment">// admin</span><br></code></pre></td></tr></table></figure><h4 id="使用盐值加密">使用盐值加密</h4><p>MD5 加密只是我们用来测试自定义加密的联系，MD5 虽然是不可逆的算法，但是加密后的值是一样的，有心人通过暴力破解还是可以成功的，这里我们就要使用 security 推荐的盐值加密，使用方法非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    auth.userDetailsService((String username)-&gt;&#123;......&#125;)<br>        <span class="hljs-comment">// 换一个实例给他就行了.....</span><br>        .passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取登录人信息">获取登录人信息</h3><h4 id="在控制器中获取">在控制器中获取</h4><p>我们在平时开发中都是讲登录信息存储到 session 中的，在控制器中通过 HttpSession 获取到当前用户的昵称、账号等其他信息，security 的话我们想要获取到信息需要在参数列表中添加以下参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toIndex</span><span class="hljs-params">(Principal principal)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;登录人信息===&gt;&gt;&quot;</span> + principal);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br><span class="hljs-comment">/*  打印后得到：</span><br><span class="hljs-comment">UsernamePasswordAuthenticationToken[Principal=org.springframework.security.core.userdetails.User [Username=zhang, Password=[PROTECTED], Enabled=true, AccountNonExpired=true, credentialsNonExpired=true, AccountNonLocked=true, Granted Authorities=[用户列表:查询]], Credentials=[PROTECTED], Authenticated=true, Details=WebAuthenticationDetails [RemoteIpAddress=0:0:0:0:0:0:0:1, SessionId=92FCFF1A0CAF7E8E74C886874D73049A], Granted Authorities=[用户列表:查询]]  */</span><br></code></pre></td></tr></table></figure><p>可以看出，只有 username 和 password 以及角色权限信息，如果我们想要获得更多例如昵称、性别、生日以及注册信息等等都没有提供</p><p>仔细一看打印结果，发现用户信息都封装在了 <code>org.springframework.security.core.userdetails.User</code> 类中，这个类在练习【登录用户设置 → 连接数据库登录】时将用户信息以及角色权限封装的位置用过，这么说来我们获取的其实是这个类的信息，那么我们来修改一下之前的代码</p><blockquote><p>创建新的类继承 security 的 User 类</p></blockquote><p>在新的 <code>UserSecurityEntity</code> 类中声明一个 entity 属性，代表当前登录人的实体，并对外提供 get 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SpringSecurity封装用户登录信息的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserSecurityEntity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> UserEntity entity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserSecurityEntity</span><span class="hljs-params">(</span><br><span class="hljs-params">          UserEntity entity,</span><br><span class="hljs-params">          Collection&lt;GrantedAuthority&gt; authorities)</span> &#123;<br>        <span class="hljs-built_in">super</span>(entity.getUsername(), entity.getPassword(), authorities);<br>        entity.setPassword(<span class="hljs-string">&quot;******&quot;</span>);<br>        <span class="hljs-built_in">this</span>.entity = entity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> UserEntity <span class="hljs-title function_">getEntity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.entity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>修改之前的数据库登录代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    auth.userDetailsService((String username)-&gt;&#123;  <span class="hljs-comment">// 省略一滩代码.......</span><br>        <span class="hljs-comment">// 将 new User 更换为我们刚刚创建的类</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserSecurityEntity</span>(userEntity, authorities);<br>    &#125;).passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PwdEncoderConfig</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>现在回到控制器中在查看打印出来的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">登录人信息===&gt;&gt;UsernamePasswordAuthenticationToken [Principal=site.hanzhe.security.UserSecurityEntity [Username=zhang...<br></code></pre></td></tr></table></figure><p>可以看到，里面已经有我们刚刚创建好的那个类了，接下来我们来通过类型转换来获取到 entity 就万事大吉啦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toLevelX</span><span class="hljs-params">(Principal principal)</span>&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ((UsernamePasswordAuthenticationToken) principal).getPrincipal();<br>    <span class="hljs-type">UserEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> ((UserSecurityEntity) p).getEntity();<br>    <span class="hljs-comment">// 获取成功！！！！！</span><br>    System.out.println(entity);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在页面上获取">在页面上获取</h4><p>在页面上使用 thymeleaf 除了场景启动器之外还需要添加另一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 版本号已在父工程中设置好了，不用我们手动设置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加好依赖后，还需要在对应使用 security 的页面中添加 <code>sec</code> 的引用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:sec</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">sec推荐使用上面的URL，如果没有代码提示可以考虑换为：</span><br><span class="hljs-comment">xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><p>在页面中获取到 entity 信息 ( 基于之前修改好的代码才可以这么获取 )：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">sec:authentication</span>=<span class="hljs-string">&quot;principal.entity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="记住我登录状态">记住我登录状态</h3><p>我们登录成功之后可以访问所有页面，根据正常流程来说当我重启浏览器后再次访问这个页面时，他会让我们你重新登录，现在我们要实现一劳永逸的方法，security 为我们提供了 <strong>记住我</strong> 功能，通过 <code>Cookie</code> 实现了重启浏览器也可以保持登录状态，而开启这个功能只需要一个方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    http.authorizeRequests()  <span class="hljs-comment">// 根据请求请求进行验证</span><br>        ........<br>        .rememberMe()  <span class="hljs-comment">// 开启&quot;记住我&quot;功能</span><br>        .rememberMeParameter(<span class="hljs-string">&quot;remember&quot;</span>); <span class="hljs-comment">// 表单checkbox的name属性值，默认为remember-me</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注销登录状态"><em>注销登录状态</em></h3><p>之前我们通过移除 session 中的登录信息来实现退出登录，使用 security 后一直通过关闭浏览器的方式进行登录注销，在学习了 &quot; 记住我 &quot; 登录状态之后连关闭浏览器都可以保持登录状态了， 所以这里学习一下注销登录</p><p>注销登录的操作也非常简单，和登陆的表单设置差不多，只需要开启功能并指定控制器的 URL 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    http.authorizeRequests()  <span class="hljs-comment">// 根据请求请求进行验证</span><br>        ......<br>        .rememberMe()  <span class="hljs-comment">// 记住我</span><br>         .rememberMeParameter(<span class="hljs-string">&quot;remember&quot;</span>)<br>         .and()<br>        .logout()      <span class="hljs-comment">// 开启注销功能</span><br>            .logoutUrl(<span class="hljs-string">&quot;/doLogout&quot;</span>)  <span class="hljs-comment">// 指定注销需要请求的控制器地址，控制器代码不需要我们实现</span><br>            .logoutSuccessUrl(<span class="hljs-string">&quot;/&quot;</span>);  <span class="hljs-comment">// 注销成功后跳转的目标页面</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样 security 的配置就完成了，这里我选择将退出功能放到 level1/1 的页面中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--主容器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;~&#123;index::nav-menu&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui segment&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align: center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Level-1-1<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/&#125;&quot;</span>&gt;</span>返回首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-symbol">&amp;nbsp;</span> <span class="hljs-symbol">&amp;nbsp;</span> <span class="hljs-symbol">&amp;nbsp;</span> <span class="hljs-symbol">&amp;nbsp;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/doLogout&#125;&quot;</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注销的控制器完成了，点击注销的超链接也完成了，接下来我们来测试一下结果：</p><p><img src="/img/security-05.jpg" alt=""></p><p>结果点击退出登录之后提示 404 了，这是因为 <em>security 出于安全考虑配置了防止跨站请求伪造 ( CSRF )</em>，他要求我们的<strong>请求必须是 POST 请求，且需要携带参数 token 参数</strong>，之前的登录表单虽然我们没有添加 token 参数，但是仔细看请求信息的时候还是可以看出 scurity 自动为我们添加了这个参数：</p><p><img src="/img/security-06.jpg" alt=""></p><p>我们的注销没有携带 token 参数并且不是 POST 请求，为了省事这里选择<em>关闭 CSRF 功能</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    http.authorizeRequests()  <span class="hljs-comment">// 根据请求请求进行验证</span><br>        ......<br>        .rememberMe()  <span class="hljs-comment">// 记住我</span><br>         .rememberMeParameter(<span class="hljs-string">&quot;remember&quot;</span>)<br>         .and()<br>        .csrf().disable()  <span class="hljs-comment">// 关闭跨站请求伪造防护功能</span><br>        .logout()      <span class="hljs-comment">// 开启注销功能</span><br>            .logoutUrl(<span class="hljs-string">&quot;/doLogout&quot;</span>)  <span class="hljs-comment">// 指定注销需要请求的控制器地址，控制器代码不需要我们实现</span><br>            .logoutSuccessUrl(<span class="hljs-string">&quot;/&quot;</span>);  <span class="hljs-comment">// 注销成功后跳转的目标页面</span><br>&#125;<br></code></pre></td></tr></table></figure><p>**扩展：**有一个和 <code>csrf().disable()</code> 长得非常像的一段代码需要注意一下：<code>.cors().disable()</code>，这个通常在前后端分离的情况使用，用于关闭跨域请求</p><h2 id="访问权限设置-二">访问权限设置(二)</h2><p>之前简单学习了一下访问权限设置，可以设置哪些页面可以直接访问、哪些页面需要登录后访问、还可以自定义登录页面、参数名称以及表单请求地址、登录的成功失败分别跳转的视图，接下来配合角色和权限实现权限控制</p><h3 id="Java代码控制授权">Java代码控制授权</h3><blockquote><p>通过权限控制访问权限</p></blockquote><p>首先调整一下测试数据，为他们分配合适的角色及权限：zhang 具有 vip 权限，admin 具有所有权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编辑假数据</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    auth.userDetailsService((String username)-&gt;&#123;<br>        <span class="hljs-type">UserEntity</span> <span class="hljs-variable">userEntity</span> <span class="hljs-operator">=</span> userService.selectUserByUsername(username);<br>        List&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// zhang只有vip1权限，admin具有所有权限</span><br>        <span class="hljs-keyword">if</span> ( <span class="hljs-string">&quot;admin&quot;</span>.equals(username) )&#123;<br>            authorities.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGrantedAuthority</span>(<span class="hljs-string">&quot;vip1&quot;</span>));<br>            authorities.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGrantedAuthority</span>(<span class="hljs-string">&quot;vip2&quot;</span>));<br>            authorities.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGrantedAuthority</span>(<span class="hljs-string">&quot;vip3&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> authorities.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGrantedAuthority</span>(<span class="hljs-string">&quot;vip1&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserSecurityEntity</span>(userEntity, authorities);<br>    &#125;).passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PwdEncoderConfig</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将请求资源设置权限，只有应有的权限才能访问对应的页面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 修改权限验证规则</span><br>@<span class="hljs-title class_">Override</span><br>protected <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span>(<span class="hljs-title class_">HttpSecurity</span> http) throws <span class="hljs-title class_">Exception</span> &#123;<br>    http.<span class="hljs-title function_">authorizeRequests</span>()<br>            .<span class="hljs-title function_">antMatchers</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/toLogin&quot;</span>,<span class="hljs-string">&quot;/views/login.html&quot;</span>,<br>                         <span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/doLogin&quot;</span>, <span class="hljs-string">&quot;/toPage/success&quot;</span>, <span class="hljs-string">&quot;/doLogout&quot;</span>)<br>            .<span class="hljs-title function_">permitAll</span>()<br>            <span class="hljs-comment">// laven1只有vip1及以上才可以访问</span><br>            .<span class="hljs-title function_">antMatchers</span>(<span class="hljs-string">&quot;/level1/*&quot;</span>)<br>            .<span class="hljs-title function_">hasAnyAuthority</span>(<span class="hljs-string">&quot;vip1&quot;</span>)<br>            <span class="hljs-comment">// laven2只有vip2及以上才可以访问</span><br>            .<span class="hljs-title function_">antMatchers</span>(<span class="hljs-string">&quot;/level2/*&quot;</span>)<br>            .<span class="hljs-title function_">hasAnyAuthority</span>(<span class="hljs-string">&quot;vip2&quot;</span>)<br>            <span class="hljs-comment">// lavel3只有vip3及以上才能访问，由于需要设置的权限太多这里通过角色来设置</span><br>            .<span class="hljs-title function_">antMatchers</span>(<span class="hljs-string">&quot;/level3/*&quot;</span>)<br>            .<span class="hljs-title function_">hasAnyAuthority</span>(<span class="hljs-string">&quot;vip3&quot;</span>)<br>            <span class="hljs-comment">// 剩下的登录即可</span><br>            .<span class="hljs-title function_">anyRequest</span>()<br>            .<span class="hljs-title function_">authenticated</span>()<br>        ........<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>hasAuthority</td><td>必须拥有目标权限才能访问</td></tr><tr><td>hasAnyAuthority</td><td>必须拥有目标权限 ( 可传多个参数 ) 才能访问</td></tr></tbody></table><blockquote><p>通过角色控制访问权限</p></blockquote><p>之前通过权限判断是否有访问资格，这次通过角色判断，代码实际上差不了多少：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 修改一下假数据</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    auth.userDetailsService((String username)-&gt;&#123;<br>        <span class="hljs-type">UserEntity</span> <span class="hljs-variable">userEntity</span> <span class="hljs-operator">=</span> userService.selectUserByUsername(username);<br>        List&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-string">&quot;admin&quot;</span>.equals(username) )&#123;<br>            authorities.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGrantedAuthority</span>(<span class="hljs-string">&quot;ROLE_普通会员&quot;</span>));<br>            authorities.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGrantedAuthority</span>(<span class="hljs-string">&quot;ROLE_高级会员&quot;</span>));<br>            authorities.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGrantedAuthority</span>(<span class="hljs-string">&quot;ROLE_超级会员&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> authorities.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGrantedAuthority</span>(<span class="hljs-string">&quot;ROLE_普通会员&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserSecurityEntity</span>(userEntity, authorities);<br>    &#125;).passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PwdEncoderConfig</span>());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 修改权限验证规则</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    http.authorizeRequests()  <span class="hljs-comment">// 根据请求请求进行验证</span><br>        .antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/toLogin&quot;</span>,<span class="hljs-string">&quot;/views/login.html&quot;</span>,<br>                     <span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/doLogin&quot;</span>, <span class="hljs-string">&quot;/toPage/success&quot;</span>, <span class="hljs-string">&quot;/doLogout&quot;</span>)<br>        .permitAll()<br>        .antMatchers(<span class="hljs-string">&quot;/level1/*&quot;</span>)<br>        .hasRole(<span class="hljs-string">&quot;普通会员&quot;</span>)<br>        .antMatchers(<span class="hljs-string">&quot;/level2/*&quot;</span>)<br>        .hasRole(<span class="hljs-string">&quot;高级会员&quot;</span>)<br>        .antMatchers(<span class="hljs-string">&quot;/level3/*&quot;</span>)<br>        .hasRole(<span class="hljs-string">&quot;超级会员&quot;</span>)<br>        .anyRequest()<br>        .authenticated();<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>hasRole</td><td>必须拥有目标角色才能访问</td></tr><tr><td>hasAnyRole</td><td>必须拥有目标角色 ( 可传多个参数 ) 才能访问</td></tr></tbody></table><blockquote><p>同时验证权限和角色</p></blockquote><p>可以通过权限验证，或者也可以通过角色验证，那么能不能两个混用呢？可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 再次修改测试数据</span><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 修改权限验证规则</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring家族</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用详解</title>
    <link href="/2023/02/21/Docker%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/21/Docker%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>官方文档地址：<a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></p><p>中文参考手册：<a href="https://docker_practice.gitee.io/zh-cn/">https://docker_practice.gitee.io/zh-cn/</a></p><p>笔记原作者：陈艳男 <a href="https://space.bilibili.com/352224540/">B站主页</a>，<a href="https://www.baizhiedu.xin/front/index#/main">更多笔记下载</a></p><h2 id=""></h2><p>Docker是一款开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或 Windows机器上。他基于虚拟化技术为每个镜像创建独立的容器，相互之间不干扰，可以做到秒级启动程序。</p><blockquote><p>最新官网首页：<a href="https://www.docker.com/">https://www.docker.com/</a></p></blockquote><p><img src="https://s2.loli.net/2023/11/26/GyIdrAsehtBv1ug.png" alt=""><br><img src="https://s2.loli.net/2023/11/26/nDFPC2Sv6J87fmU.png" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.官方介绍</span><br><span class="hljs-bullet">-</span> We have a complete container solution for you - no matter who you are and where you are on your containerization journey.<br><span class="hljs-bullet">-</span> 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。<br><span class="hljs-bullet">-</span> 官方定义: docker是一个容器技术。<br></code></pre></td></tr></table></figure><h2 id="为什么使用Docker">为什么使用Docker</h2><ul><li><p><strong>优势1:  一致的运行环境,更轻松的迁移</strong></p><p>我们部署一个程序需要很多东西，比如jdk、tomcat、mysql等软件环境。当其中任意一种不符合要求都可能会导致应用程序启动失败！Docker则将程序以及使用软件环境直接打包在一起，保证了运行环境一致。</p><p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p><p>如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p></li><li><p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p><p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p></li></ul><h2 id="Docker和虚拟机区别">Docker和虚拟机区别</h2><blockquote><p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p></blockquote><p><img src="https://s2.loli.net/2023/11/26/UHXtC2WqwbuN3k4.png" alt="image-20201220222456675"></p><p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p><table><thead><tr><th></th><th>传统虚拟机</th><th>Docker容器</th></tr></thead><tbody><tr><td>磁盘占用</td><td>几GB~几十个GB左右</td><td>几十MB~几百MB左右</td></tr><tr><td>CPU内存占用</td><td>虚拟操作系统非常占用CPU和内存</td><td>Docker引擎占用极低</td></tr><tr><td>启动速度</td><td>（从开机到运行项目）几分钟</td><td>（从开启容器到运行项目）几秒</td></tr><tr><td>安装管理</td><td>需要专门的运维技术</td><td>安装、管理方便</td></tr><tr><td>应用部署</td><td>每次部署都费时费力</td><td>从第二次部署开始轻松简捷</td></tr><tr><td>耦合性</td><td>多个应用服务安装到一起，容易互相影响</td><td>每个应用服务一个容器，达成隔离</td></tr><tr><td>系统依赖</td><td>无</td><td>需求相同或相似的内核，目前推荐是Linux</td></tr></tbody></table><h2 id="Docker的安装配置-CentOS7">Docker的安装配置(CentOS7)</h2><blockquote><p>安装流程：根据官方文档走一遍</p></blockquote><p><strong>1. 安装之前要保证系统中没有相关残留导致安装失败，这里先删除、清理依赖</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove docker \<br>    docker-client \<br>    docker-client-latest \<br>    docker-common \<br>    docker-latest \<br>    docker-latest-logrotate \<br>    docker-logrotate \<br>    docker-engine<br></code></pre></td></tr></table></figure><p><strong>2. 清理依赖结束后，就需要安装 docker 所需的依赖了</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y yum-utils<br></code></pre></td></tr></table></figure><p><strong>3. 依赖安装完成后需要下载 docker 程序，官方默认提供的是国外的下载地址，这里换用阿里云的比较快</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum-config-manager \<br>    --add-repo \<br>    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p><strong>4. 下载地址更换完成后就可以进行下载了，稍等片刻后 docker 就会安装成功</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><p><strong>5. 接下来就可以启动Docker服务了</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动docker服务</span><br>systemctl start docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">相对应的结束docker服务</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">systemctl stop docker</span><br></code></pre></td></tr></table></figure><blockquote><p>配置阿里云镜像加速</p></blockquote><p>在上面安装Docker的时候使用了阿里云地址下载，有经验的肯定能感觉到相对于官网速度提高了不止一点，后面希望所有镜像都通过阿里云进行下载，这里配置阿里云镜像加速：</p><ol><li>登陆/注册 阿里云官方网站</li><li>点进控制台</li><li>打开左侧侧边栏找到<code>容器镜像服务</code>并点击</li><li>找到左侧最下面的<code>镜像加速器</code></li><li>选择符合环境的代码执行即可：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">每个人的地址都不一样，我这里的镜像加速地址为：</span><br>sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;<br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>可以通过<code>docker info</code>命令来查看镜像加速是否配置成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker info<br><span class="hljs-meta prompt_">   # </span><span class="language-bash">省略一大堆，直接看最下面..........</span><br>   Registry Mirrors:<br>    &#x27;https://lz2nib3q.mirror.aliyuncs.com/&#x27;<br>   Live Restore Enabled: false<br>   Product License: Community Engine<br></code></pre></td></tr></table></figure><h2 id="Docker的核心架构">Docker的核心架构</h2><blockquote><p>基本概念了解</p></blockquote><p><img src="https://s2.loli.net/2023/11/26/so7t6n1mhCFvJQy.png" alt="docker-03"></p><ul><li><code>镜像:</code>一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li><li><code>容器:</code>镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li><li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li><li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li><li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li></ul><blockquote><p>Docker运行流程示意图</p></blockquote><p><img src="https://s2.loli.net/2023/11/26/aHxivRoycmQAIJe.png" alt="docker-05"></p><h2 id="Docker初体验">Docker初体验</h2><blockquote><p>运行 hello-world 镜像</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run hello-world<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地找不到hello-world这个镜像(:latest代表最新版本镜像)</span><br>Unable to find image &#x27;hello-world:latest&#x27; locally<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在找不到镜像的情况下默认会去到远程仓库中自动下载</span><br>latest: Pulling from library/hello-world<br>0e03bdcc26d7: Already exists <br>Digest: sha256:31b9c7d48790f0d8c50ab433d9c3b7e17666d6993084c002c2ff1ca09b96391d<br>Status: Downloaded newer image for hello-world:latest<br><span class="hljs-meta prompt_"># </span><span class="language-bash">镜像下载完成后执行运行命令，运行的结果是：</span><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>To generate this message, Docker took the following steps:<br> 1. The Docker client contacted the Docker daemon.<br> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.<br>    (amd64)<br> 3. The Docker daemon created a new container from that image which runs the<br>    executable that produces the output you are currently reading.<br> 4. The Docker daemon streamed that output to the Docker client, which sent it<br>    to your terminal.<br><br>To try something more ambitious, you can run an Ubuntu container with:<br><span class="hljs-meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span><br><br>Share images, automate workflows, and more with a free Docker ID:<br> https://hub.docker.com/<br><br>For more examples and ideas, visit:<br> https://docs.docker.com/get-started/<br></code></pre></td></tr></table></figure><h2 id="Docker常用命令">Docker常用命令</h2><blockquote><p>帮助、辅助命令</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.安装完成辅助命令</span><br>docker version -------------------------- 查看docker的信息<br>docker info  -------------------------- 查看更详细的信息<br>docker --help -------------------------- 帮助命令<br></code></pre></td></tr></table></figure><blockquote><p>Images 镜像命令</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.查看本机中所有镜像</span><br>docker images --------------------------  列出本地所有镜像<br> -a    列出所有镜像（包含中间映像层）<br>   -q    只显示镜像id<br><br><span class="hljs-section"># 2.搜索镜像</span><br>docker search [options] 镜像名 ------------  去dockerhub上查询当前镜像<br> -s 指定值     列出收藏数不少于指定值的镜像<br>   --no-trunc   显示完整的镜像信息<br><br><span class="hljs-section"># 3.从仓库下载镜像</span><br>docker pull 镜像名[:TAG|@DIGEST] --------  下载镜像<br><br><span class="hljs-section"># 4.删除镜像</span><br>docker rmi 镜像名 ------------------------  删除镜像<br> -f           强制删除<br></code></pre></td></tr></table></figure><blockquote><p>Contrainer 容器命令</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.运行容器</span><br>docker run 镜像名 -------------------------- 镜像名新建并启动容器<br> --name      为容器指定一个名称<br> -d          后台运行容器，并返回容器ID<br> -p          小写-设置端口映射【主机端口:容器端口】<br> -P          大写字母P：随机指定端口<br> -i          以交互模式运行，通常与 -t 同时使用<br> -t          为容器重新分配一个伪输入终端，通常与 -i 同时使用<br> -e          通常用于对容器内的环境进行一些设置<br> -v          绑定一个卷<br><br><span class="hljs-section"># 2.查看运行的容器</span><br>docker ps         -------------------------- 列出所有正在运行的容器<br> -a          正在运行的和历史运行过的容器<br> -q          静默模式，只显示容器编号<br><br><span class="hljs-section"># 3.停止|关闭|重启容器</span><br>docker start   容器名字或者容器id  --------------- 开启容器<br>docker restart 容器名或者容器id    --------------- 重启容器<br>docker stop    容器名或者容器id  --------------- 正常停止容器运行<br>docker kill    容器名或者容器id    --------------- 立即停止容器运行<br><br><span class="hljs-section"># 4.删除容器</span><br>docker rm -f 容器id和容器名     <br>docker rm -f $(docker ps -aq)   --------------- 删除所有容器<br><br><span class="hljs-section"># 5.查看容器内进程</span><br>docker top 容器id或者容器名        --------------- 查看容器内的进程<br><br><span class="hljs-section"># 6.查看查看容器内部细节</span><br>docker inspect 容器id      --------------- 查看容器内部细节<br><br><span class="hljs-section"># 7.查看容器的运行日志</span><br>docker logs [OPTIONS] 容器id或容器名 ------------ 查看容器日志<br><span class="hljs-code">    -t  加入时间戳</span><br><span class="hljs-code">    -f  跟随最新的日志打印</span><br><span class="hljs-code">    --tail  数字 显示最后多少条</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 8.进入容器内部</span><br>docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令<br><span class="hljs-code">    -i  以交互模式运行容器，通常与-t一起使用</span><br><span class="hljs-code">    -t  分配一个伪终端    shell窗口   bash </span><br><span class="hljs-code"></span><br><span class="hljs-section"># 9.容器和宿主机之间复制文件</span><br>docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部<br>docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上<br><br><span class="hljs-section"># 10.数据卷(volum)实现与宿主机共享目录</span><br>docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名<br>  注意: <br><span class="hljs-code">     1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容</span><br><span class="hljs-code">     2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 11.打包镜像</span><br>docker save 镜像名 -o 名称.tar<br><br><span class="hljs-section"># 12.载入镜像</span><br>docker load -i 名称.tar<br><br><span class="hljs-section"># 13.容器打包成新的镜像</span><br>docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签<br></code></pre></td></tr></table></figure><h2 id="Docker的镜像原理">Docker的镜像原理</h2><p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p><blockquote><p>为什么一个镜像会那么大？</p></blockquote><p><img src="https://s2.loli.net/2023/11/26/Ozftpb9Mm8hvNUE.png" alt="docker-06"><strong>UnionFS ( 联合文件系统 )</strong>：</p><p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。</p><blockquote><p>docker的镜像实际是由一层一层的文件系统组成。</p></blockquote><ul><li><p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p></li><li><p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。</p></li><li><p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p></li></ul><p><img src="D:%5C%E7%AC%94%E8%AE%B0%5CMarkdown-master%5CMarkdown-master%5Cimg%5Cdocker-01.jpg" alt="docker-01"></p><h2 id="Docker常用服务安装">Docker常用服务安装</h2><h3 id="简单程序安装">简单程序安装</h3><blockquote><p>安装mysql</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.拉取mysql镜像到本地</span><br> docker pull mysql:tag (tag不加默认最新版本)<br> <br><span class="hljs-section"># 2.运行mysql服务</span><br> docker run --name mysql -e MYSQL<span class="hljs-emphasis">_ROOT_</span>PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口<br><br><span class="hljs-section"># 3.进入mysql容器</span><br> docker exec -it 容器名称|容器id bash<br><br><span class="hljs-section"># 4.外部查看mysql日志</span><br> docker logs 容器名称|容器id<br><br><span class="hljs-section"># 5.使用自定义配置参数</span><br> docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL<span class="hljs-emphasis">_ROOT_</span>PASSWORD=root -d mysql:tag<br><br><span class="hljs-section"># 6.将容器数据位置与宿主机位置挂载保证数据安全</span><br>docker run -d \<br>--name mysql \<br>-v /root/mysql/data:/var/lib/mysql \<br>-v /root/mysql/conf:/etc/mysql \<br>-e MYSQL<span class="hljs-emphasis">_ROOT_</span>PASSWORD=zhang \<br>-p 3306:3306 \<br>mysql:5.7.32<br><br><span class="hljs-section"># 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问</span><br> <br><span class="hljs-section"># 8.将mysql数据库备份为sql文件</span><br> docker exec mysql|容器id sh -c &#x27;exec mysqldump --all-databases -uroot -p&quot;$MYSQL<span class="hljs-emphasis">_ROOT_</span>PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出全部数据<br> docker exec mysql sh -c &#x27;exec mysqldump --databases 库表 -uroot -p&quot;$MYSQL<span class="hljs-emphasis">_ROOT_</span>PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出指定库数据<br> docker exec mysql sh -c &#x27;exec mysqldump --no-data --databases 库表 -uroot -p&quot;$MYSQL<span class="hljs-emphasis">_ROOT_</span>PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出指定库数据不要数据<br><br><span class="hljs-section"># 9.执行sql文件到mysql中</span><br> docker exec -i mysql sh -c &#x27;exec mysql -uroot -p&quot;$MYSQL<span class="hljs-emphasis">_ROOT_</span>PASSWORD&quot;&#x27; &lt; /root/xxx.sql<br></code></pre></td></tr></table></figure><blockquote><p>安装Redis服务</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.在docker hub搜索redis镜像</span><br> docker search redis<br><br><span class="hljs-section"># 2.拉取redis镜像到本地</span><br> docker pull redis<br><br><span class="hljs-section"># 3.启动redis服务运行容器</span><br> docker run --name redis -d redis:tag (没有暴露外部端口)<br> docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) <br><br><span class="hljs-section"># 4.查看启动日志</span><br> docker logs -t -f 容器id|容器名称<br><br><span class="hljs-section"># 5.进入容器内部查看</span><br> docker exec -it 容器id|名称 bash  <br><br><span class="hljs-section"># 6.加载外部自定义配置启动redis容器</span><br> 默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件<br><span class="hljs-bullet"> 1.</span> wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包<br><span class="hljs-bullet"> 2.</span> 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件<br><span class="hljs-bullet"> 3.</span> 修改需要自定义的配置<br>   bind 0.0.0.0 开启远程权限<br>   appenonly yes 开启aof持久化<br><span class="hljs-bullet"> 4.</span> 加载配置启动<br> docker run --name redis -v /root/redis:/opt/conf -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  <br><br><span class="hljs-section"># 7.将数据目录挂在到本地保证数据安全</span><br>docker run -d \<br>--name redis \<br>-v /root/redis/data:/data \<br>-v /root/redis/conf:/opt/conf \<br>-p 6379:6379 \<br>redis:5.0.10 redis-server /opt/conf/redis.conf<br></code></pre></td></tr></table></figure><blockquote><p>安装Nginx</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.在docker hub搜索nginx</span><br> docker search nginx<br><br><span class="hljs-section"># 2.拉取nginx镜像到本地</span><br> [root@localhost ~]# docker pull nginx<br><span class="hljs-code">    Using default tag: latest</span><br><span class="hljs-code">    latest: Pulling from library/nginx</span><br><span class="hljs-code">    afb6ec6fdc1c: Pull complete </span><br><span class="hljs-code">    b90c53a0b692: Pull complete </span><br><span class="hljs-code">    11fa52a0fdc0: Pull complete </span><br><span class="hljs-code">    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097</span><br><span class="hljs-code">    Status: Downloaded newer image for nginx:latest</span><br><span class="hljs-code">    docker.io/library/nginx:latest</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 3.启动nginx容器</span><br>  docker run -p 80:80 --name nginx01 -d nginx<br><br><span class="hljs-section"># 4.进入容器</span><br>  docker exec -it nginx01 /bin/bash<br>  查找目录:  whereis nginx<br>  配置文件:  /etc/nginx/nginx.conf<br><br><span class="hljs-section"># 5.复制配置文件到宿主机</span><br>  docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录<br><br><span class="hljs-section"># 6.挂在nginx配置以及html到宿主机外部</span><br>  docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx  <br></code></pre></td></tr></table></figure><blockquote><p>安装Tomcat</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.在docker hub搜索tomcat</span><br> docker search tomcat<br><br><span class="hljs-section"># 2.下载tomcat镜像</span><br> docker pull tomcat<br><br><span class="hljs-section"># 3.运行tomcat镜像</span><br> docker run -p 8080:8080 -d --name mytomcat tomcat<br><br><span class="hljs-section"># 4.进入tomcat容器</span><br> docker exec -it mytomcat /bin/bash<br><br><span class="hljs-section"># 5.将webapps目录挂载在外部</span><br> docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat<br></code></pre></td></tr></table></figure><blockquote><p>安装MongoDB数据库</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.运行mongDB</span><br> docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限<br> docker logs -f mymongo --查看mongo运行日志<br><br><span class="hljs-section"># 2.进入mongodb容器</span><br> docker exec -it mymongo /bin/bash<br>  直接执行mongo命令进行操作<br><br><span class="hljs-section"># 3.常见具有权限的容器</span><br> docker run --name  mymongo  -p 27017:27017  -d mongo --auth<br><br><span class="hljs-section"># 4.进入容器配置用户名密码</span><br> mongo<br> use admin 选择admin库<br> db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[&#123;role:&#x27;root&#x27;,db:&#x27;admin&#x27;&#125;]&#125;)   //创建用户,此用户创建成功,则后续操作都需要用户认证<br> exit<br><br><span class="hljs-section"># 5.将mongoDB中数据目录映射到宿主机中</span><br> docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo <br></code></pre></td></tr></table></figure><h3 id="安装ElasticSearch">安装ElasticSearch</h3><p><em>注意：调高JVM线程数限制数量</em></p><h4 id="拉取镜像运行elasticsearch">拉取镜像运行elasticsearch</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.dockerhub 拉取镜像</span><br> docker pull elasticsearch:6.4.2<br><span class="hljs-section"># 2.查看docker镜像</span><br> docker images<br><span class="hljs-section"># 3.运行docker镜像</span><br> docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2<br></code></pre></td></tr></table></figure><ul><li>启动出现如下错误</li><li><img src="/img/docker-10.png" alt="image-20200602184321790"></li></ul><h4 id="预先配置">预先配置</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.在centos虚拟机中，修改配置sysctl.conf</span><br> vim /etc/sysctl.conf<br><span class="hljs-section"># 2.加入如下配置</span><br> vm.max<span class="hljs-emphasis">_map_</span>count=262144 <br><span class="hljs-section"># 3.启用配置</span><br> sysctl -p<br> 注：这一步是为了防止启动容器时，报出如下错误：<br> bootstrap checks failed max virtual memory areas vm.max<span class="hljs-emphasis">_map_</span>count [65530] likely too low, increase to at least [262144]<br><br></code></pre></td></tr></table></figure><h4 id="启动EleasticSearch容器">启动EleasticSearch容器</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 0.复制容器中data目录到宿主机中</span><br> docker cp 容器id:/usr/share/share/elasticsearch/data /root/es<br><span class="hljs-section"># 1.运行ES容器 指定jvm内存大小并指定ik分词器位置</span><br> docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES<span class="hljs-emphasis">_JAVA_</span>OPTS=&quot;-Xms128m -Xmx128m&quot; -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2<br></code></pre></td></tr></table></figure><h4 id="安装IK分词器">安装IK分词器</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.下载对应版本的IK分词器</span><br> wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip<br><br><span class="hljs-section"># 2.解压到plugins文件夹中</span><br> yum install -y unzip<br> unzip -d ik elasticsearch-analysis-ik-6.4.2.zip<br><br><span class="hljs-section"># 3.添加自定义扩展词和停用词</span><br> cd plugins/elasticsearch/config<br> vim IKAnalyzer.cfg.xml<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span></span>IK Analyzer 扩展配置<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span></span><br>  &lt;!--用户可以在这里配置自己的扩展字典 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;</span></span>ext<span class="hljs-emphasis">_dict.dic<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span></span></span><br><span class="hljs-emphasis">  &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><br><span class="hljs-emphasis">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_stopwords&quot;</span>&gt;</span></span>ext_</span>stopwords.dic<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span></span><br> <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><br><span class="hljs-section"># 4.在ik分词器目录下config目录中创建ext<span class="hljs-emphasis">_dict.dic文件   编码一定要为UTF-8才能生效</span></span><br><span class="hljs-emphasis"><span class="hljs-section"> vim ext_</span>dict.dic 加入扩展词即可</span><br><span class="hljs-section"># 5. 在ik分词器目录下config目录中创建ext<span class="hljs-emphasis">_stopword.dic文件 </span></span><br><span class="hljs-emphasis"><span class="hljs-section"> vim ext_</span>stopwords.dic 加入停用词即可</span><br><br><span class="hljs-section"># 6.重启容器生效</span><br> docker restart 容器id<br><span class="hljs-section"># 7.将此容器提交成为一个新的镜像</span><br> docker commit -a=&quot;xiaochen&quot; -m=&quot;es with IKAnalyzer&quot; 容器id xiaochen/elasticsearch:6.4.2<br></code></pre></td></tr></table></figure><h4 id="安装Kibana">安装Kibana</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.下载kibana镜像到本地</span><br> docker pull kibana:6.4.2<br><br><span class="hljs-section"># 2.启动kibana容器</span><br> docker run -d --name kibana -e ELASTICSEARCH<span class="hljs-emphasis">_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2</span><br></code></pre></td></tr></table></figure><h2 id="Dockerfile">Dockerfile</h2><h3 id="什么是Dockerfile">什么是Dockerfile</h3><p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p><p><img src="https://s2.loli.net/2023/11/26/so7t6n1mhCFvJQy.png" alt="docker-03"><strong>通过架构图可以看出通过DockerFile可以直接构建镜像</strong></p><h3 id="Dockerfile解析过程">Dockerfile解析过程</h3><h3 id="docker-13Dockerfile的保留命令"><img src="https://s2.loli.net/2023/11/26/pT5fWHrLRQmxIe8.png" alt="docker-13">Dockerfile的保留命令</h3><p>官方说明:<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><table><thead><tr><th>保留字</th><th>作用</th></tr></thead><tbody><tr><td>FROM</td><td>当前镜像是基于哪个镜像的<code>第一个指令必须是FROM</code></td></tr><tr><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr><td>RUN</td><td>构建镜像时需要运行的指令</td></tr><tr><td>EXPOSE</td><td>当前容器对外暴露出的端口号</td></tr><tr><td>WORKDIR</td><td>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</td></tr><tr><td>ENV</td><td>用来在构建镜像过程中设置环境变量</td></tr><tr><td>ADD</td><td>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</td></tr><tr><td>COPY</td><td>类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</td></tr><tr><td>VOLUME</td><td>容器数据卷，用于数据保存和持久化工作</td></tr><tr><td>CMD</td><td>指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</td></tr><tr><td>ENTRYPOINT</td><td>指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</td></tr></tbody></table><blockquote><p>FROM 命令</p></blockquote><p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span>  &lt;image&gt;<br><span class="hljs-keyword">FROM</span>  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest<br><span class="hljs-keyword">FROM</span>  &lt;image&gt;[@&lt;digest&gt;]  使用摘要<br></code></pre></td></tr></table></figure><blockquote><p>MAINTAINER  命令</p></blockquote><p>镜像维护者的姓名和邮箱地址[废弃]</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">MAINTAINER</span> &lt;name&gt;<br></code></pre></td></tr></table></figure><blockquote><p>RUN 命令</p></blockquote><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;<span class="hljs-built_in">command</span>&gt; (shell form, the <span class="hljs-built_in">command</span> is run <span class="hljs-keyword">in</span> a shell, <span class="hljs-built_in">which</span> by default is /bin/sh -c on Linux or cmd /S /C on Windows)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> hello</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>] (<span class="hljs-built_in">exec</span> form)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo hello&quot;</span>]</span><br></code></pre></td></tr></table></figure><blockquote><p>EXPOSE 命令</p></blockquote><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span>/tcp  如果没有显示指定则默认暴露都是tcp<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span>/udp<br></code></pre></td></tr></table></figure><blockquote><p>CMD 命令</p></blockquote><p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p><p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>,<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] (<span class="hljs-built_in">exec</span> form, this is the preferred form)</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] (as default parameters to ENTRYPOINT)</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2 (shell form)</span><br></code></pre></td></tr></table></figure><blockquote><p>WORKDIR 命令</p></blockquote><p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br>`注意:<span class="hljs-keyword">WORKDIR</span><span class="language-bash">指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`</span><br></code></pre></td></tr></table></figure><blockquote><p>ENV 命令</p></blockquote><p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure><blockquote><p>ADD 命令</p></blockquote><p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="language-bash"> hom* /mydir/       通配符添加多个文件</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hom?.txt /mydir/   通配符添加</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt relativeDir/  可以指定相对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt /absoluteDir/ 也可以指定绝对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> url </span><br></code></pre></td></tr></table></figure><blockquote><p>COPY 命令</p></blockquote><p>用来将context目录中指定文件复制到镜像的指定目录中</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> src dest</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><blockquote><p>VOLUME 命令</p></blockquote><p>用来定义容器运行时可以挂在到宿主机的目录</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure><blockquote><p>ENTRYPOINT命令</p></blockquote><p>用来指定容器启动时执行命令和CMD类似</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">   [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]<br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2</span><br></code></pre></td></tr></table></figure><p>ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。<br>CMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p><h2 id="高级网络配置">高级网络配置</h2><p>当 Docker 启动时，会自动在主机上创建一个 docker0`虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p><p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href="https://tools.ietf.org/html/rfc1918">RFC1918</a> 中定义）中的一个地址给<code>docker0</code>接口。比如典型的<code>172.17.42.1</code>，掩码为<code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p><p>当创建一个 Docker 容器的时候，同时会创建了一对<code>veth pair</code>接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即<code>eth0</code>；另一端在本地并被挂载到<code>docker0</code>网桥，名称以<code>veth</code>开头（例如<code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p><blockquote><p><img src="https://s2.loli.net/2023/11/26/5VrBC3LuIGOAZDe.png" alt="docker-17">查看网络信息</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># docker network ls</span><br></code></pre></td></tr></table></figure><blockquote><p>创建一个网桥</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># docker network create -d bridge 网桥名称</span><br></code></pre></td></tr></table></figure><blockquote><p>删除一个网桥</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># docker network rm 网桥名称</span><br></code></pre></td></tr></table></figure><blockquote><p>容器之前使用网络通信</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.查询当前网络配置</span><br><span class="hljs-bullet">-</span> docker network ls<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">NETWORK ID          NAME                DRIVER              SCOPE<br>8e424e5936b7        bridge              bridge              local<br>17d974db02da        docker_gwbridge     bridge              local<br>d6c326e433f7        host                host                local<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 2.创建桥接网络</span><br><span class="hljs-bullet">-</span> docker network create -d bridge info<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos ~]# docker network create -d bridge info<br>6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f<br>[root@centos ~]# docker network ls<br>NETWORK ID          NAME                DRIVER              SCOPE<br>8e424e5936b7        bridge              bridge              local<br>17d974db02da        docker_gwbridge     bridge              local<br>d6c326e433f7        host                host                local<br>6e4aaebff79b        info                bridge              local<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 3.启动容器指定使用网桥</span><br><span class="hljs-bullet">-</span> docker run -d -p 8890:80 --name nginx001 --network info nginx <br><span class="hljs-bullet">-</span> docker run -d -p 8891:80 --name nginx002 --network info nginx <br> <span class="hljs-code">`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx <br>c315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe<br>[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx<br>f8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5<br>[root@centos ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES<br>f8682db35dd7        nginx               &quot;/docker-entrypoint.…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8891-&gt;80/tcp   nginx002<br>c315bcc94e9d        nginx               &quot;/docker-entrypoint.…&quot;   7 minutes ago       Up 7 minutes        0.0.0.0:8890-&gt;80/tcp   nginx001<br>b63169d43792        mysql:5.7.19        &quot;docker-entrypoint.s…&quot;   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda<br>[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash<br>root@f8682db35dd7:/# curl http://nginx001<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>.....<br></code></pre></td></tr></table></figure><h2 id="高级数据卷配置">高级数据卷配置</h2><p><strong>数据卷</strong> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认会一直存在，即使容器被删除</li></ul><p>注：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）</p><blockquote><p>创建数据卷</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos ~]# docker volume create my-vol<br>my-vol<br></code></pre></td></tr></table></figure><blockquote><p>查看数据卷</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos ~]# docker volume inspect my-vol<br>[<br>    &#123;<br>        &quot;CreatedAt&quot;: &quot;2020-11-25T11:43:56+08:00&quot;,<br>        &quot;Driver&quot;: &quot;local&quot;,<br>        &quot;Labels&quot;: &#123;&#125;,<br>        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,<br>        &quot;Name&quot;: &quot;my-vol&quot;,<br>        &quot;Options&quot;: &#123;&#125;,<br>        &quot;Scope&quot;: &quot;local&quot;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><blockquote><p>挂载数据卷</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx<br>[root@centos ~]# docker inspect web<br>    &quot;Mounts&quot;: [<br>            &#123;<br>                &quot;Type&quot;: &quot;volume&quot;,<br>                &quot;Name&quot;: &quot;my-vol&quot;,<br>                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,<br>                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,<br>                &quot;Driver&quot;: &quot;local&quot;,<br>                &quot;Mode&quot;: &quot;z&quot;,<br>                &quot;RW&quot;: true,<br>                &quot;Propagation&quot;: &quot;&quot;<br>            &#125;<br>        ],<br></code></pre></td></tr></table></figure><blockquote><p>删除数据卷</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume rm my-vol<br></code></pre></td></tr></table></figure><hr><h2 id="12-Docker-Compose">12.Docker Compose</h2><p><code>Compose</code>项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟<code>OpenStack</code>中的<code>Heat</code>十分类似。</p><p>其代码目前在 <a href="https://github.com/docker/compose">https://github.com/docker/compose</a> 上开源。</p><p><code>Compose</code>定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p><p>通过第一部分中的介绍，我们知道使用一个<code>Dockerfile</code>模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p><code>Compose</code>恰好满足了这样的需求。它允许用户通过一个单独的<code>docker-compose.yml</code>模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p><code>Compose</code>中有两个重要的概念：</p><ul><li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在<code>docker-compose.yml</code>文件中定义。</li></ul><p><code>Compose</code>的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p><code>Compose</code>项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用<code>Compose</code>来进行编排管理。</p><h3 id="安装与卸载">安装与卸载</h3><blockquote><p>linux</p></blockquote><p>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`<span class="hljs-built_in">uname</span> -s`-`<span class="hljs-built_in">uname</span> -m`&gt; /usr/local/bin/docker-compose<br>sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><blockquote><p>macos、window</p></blockquote><p>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</p><blockquote><p>卸载</p></blockquote><p>如果是二进制包方式安装的，删除二进制文件即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo rm /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>测试安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose --version</span><br> docker-compose version 1.25.5, build 4667896b<br></code></pre></td></tr></table></figure><h3 id="docker-compose使用">docker compose使用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.相关概念</span><br></code></pre></td></tr></table></figure><p>首先介绍几个术语。</p><ul><li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code>面向项目进行管理。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 2.场景</span><br></code></pre></td></tr></table></figure><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p><ul><li>springboot应用</li><li>mysql服务</li><li>redis服务</li><li>elasticsearch服务</li><li>…</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 3.docker-compose模板</span><br><span class="hljs-bullet">-</span> 参考文档:https://docker<span class="hljs-emphasis">_practice.gitee.io/zh-cn/compose/compose_</span>file.html<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.0&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysqldb:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7.19</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/mysql/conf:/etc/mysql/conf.d</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/mysql/logs:/logs</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/mysql/data:/var/lib/mysql</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ems</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:4.0.14</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6379:6379&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ems</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/redis/data:/data</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span><br>    <br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">ems:</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 4.通过docker-compose运行一组容器</span><br><span class="hljs-bullet">-</span> 参考文档:https://docker<span class="hljs-emphasis">_practice.gitee.io/zh-cn/compose/commands.html</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@centos ~]<span class="hljs-comment"># docker-compose up           //前台启动一组服务</span><br>[root@centos ~]<span class="hljs-comment"># docker-compose up -d        //后台启动一组服务</span><br></code></pre></td></tr></table></figure><hr><h3 id="docker-compose-模板文件">docker-compose 模板文件</h3><p>模板文件是使用<code>Compose</code>的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟<code>docker run</code>相关参数的含义都是类似的。</p><p>默认的模板文件名称为<code>docker-compose.yml</code>，格式为 YAML 格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">webapp:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">examples/web</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/data&quot;</span><br></code></pre></td></tr></table></figure><p>注意每个服务都必须通过<code>image</code>指令指定镜像或<code>build</code>指令（需要 Dockerfile）等来自动构建生成镜像。</p><p>如果使用<code>build</code>指令，在<code>Dockerfile</code>中设置的选项(例如：<code>CMD</code>,<code>EXPOSE</code>,<code>VOLUME</code>,<code>ENV</code>等) 将会自动被获取，无需在<code>docker-compose.yml</code>中重复设置。</p><p>下面分别介绍各个指令的用法。</p><h4 id="build"><code>build</code></h4><p>指定<code>Dockerfile</code>所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。<code>Compose</code>将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">webapp:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./dir</span><br></code></pre></td></tr></table></figure><p>你也可以使用<code>context</code>指令指定<code>Dockerfile</code>所在文件夹的路径。</p><p>使用<code>dockerfile</code>指令指定<code>Dockerfile</code>文件名。</p><p>使用<code>arg</code>指令指定构建镜像时的变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">webapp:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">./dir</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">Dockerfile-alternate</span><br>      <span class="hljs-attr">args:</span><br>        <span class="hljs-attr">buildno:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="command"><code>command</code></h4><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">command:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><h4 id="container-name"><code>container_name</code></h4><p>指定容器名称。默认将会使用<code>项目名称_服务名称_序号</code>这样的格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">container_name:</span> <span class="hljs-string">docker-web-container</span><br></code></pre></td></tr></table></figure><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p></blockquote><h4 id="depends-on"><code>depends_on</code></h4><p>解决容器的依赖、启动先后的问题。以下例子中会先启动<code>redis``db</code>再启动<code>web</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">../../../新建文件夹</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：<code>web</code>服务不会等待<code>redis``db</code>「完全启动」之后才启动。</p></blockquote><h4 id="env-file"><code>env_file</code></h4><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过<code>docker-compose -f FILE</code>方式来指定 Compose 模板文件，则<code>env_file</code>中变量的路径会基于模板文件路径。</p><p>如果有变量名称与<code>environment</code>指令冲突，则按照惯例，以后者为准。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">env_file: .<span class="hljs-built_in">env</span><br><br>env_file:<br>  - ./common.env<br>  - ./apps/web.env<br>  - /opt/secrets.env<br></code></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持<code>#</code>开头的注释行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># common.env: Set development environment</span><br>PROG_ENV=development<br></code></pre></td></tr></table></figure><h4 id="environment"><code>environment</code></h4><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">environment:</span><br>  <span class="hljs-attr">RACK_ENV:</span> <span class="hljs-string">development</span><br>  <span class="hljs-attr">SESSION_SECRET:</span><br><br><span class="hljs-attr">environment:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">RACK_ENV=development</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">SESSION_SECRET</span><br></code></pre></td></tr></table></figure><p>如果变量名称或者值中用到<code>true|false，yes|no</code>等表达 <a href="https://yaml.org/type/bool.html">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">y|Y|<span class="hljs-built_in">yes</span>|Yes|YES|n|N|no|No|NO|<span class="hljs-literal">true</span>|True|TRUE|<span class="hljs-literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF<br></code></pre></td></tr></table></figure><h4 id="healthcheck"><code>healthcheck</code></h4><p>通过命令检查容器是否健康运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">healthcheck:</span><br>  <span class="hljs-attr">test:</span> [<span class="hljs-string">&quot;CMD&quot;</span>, <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;http://localhost&quot;</span>]<br>  <span class="hljs-attr">interval:</span> <span class="hljs-string">1m30s</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span><br>  <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="image"><code>image</code></h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code>将会尝试拉取这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">image:</span> <span class="hljs-string">ubuntu</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">orchardup/postgresql</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">a4bc65fd</span><br></code></pre></td></tr></table></figure><h4 id="networks"><code>networks</code></h4><p>配置容器连接的网络。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">some-service:</span><br>    <span class="hljs-attr">networks:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">some-network</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">other-network</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">some-network:</span><br>  <span class="hljs-attr">other-network:</span><br></code></pre></td></tr></table></figure><h4 id="ports"><code>ports</code></h4><p>暴露端口信息。</p><p>使用宿主端口：容器端口<code>(HOST:CONTAINER)</code>格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ports:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000&quot;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8000:8000&quot;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;49100:22&quot;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;127.0.0.1:8001:8001&quot;</span><br></code></pre></td></tr></table></figure><p><em>注意：当使用<code>HOST:CONTAINER</code>格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为<code>YAML</code>会自动解析<code>xx:yy</code>这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p><h4 id="sysctls"><code>sysctls</code></h4><p>配置容器内核参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sysctls:</span><br>  <span class="hljs-attr">net.core.somaxconn:</span> <span class="hljs-number">1024</span><br>  <span class="hljs-attr">net.ipv4.tcp_syncookies:</span> <span class="hljs-number">0</span><br><br><span class="hljs-attr">sysctls:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">net.core.somaxconn=1024</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">net.ipv4.tcp_syncookies=0</span><br></code></pre></td></tr></table></figure><h4 id="ulimits"><code>ulimits</code></h4><p>指定容器的 ulimits 限制值。</p><p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ulimits:</span><br>  <span class="hljs-attr">nproc:</span> <span class="hljs-number">65535</span><br>  <span class="hljs-attr">nofile:</span><br>    <span class="hljs-attr">soft:</span> <span class="hljs-number">20000</span><br>    <span class="hljs-attr">hard:</span> <span class="hljs-number">40000</span><br></code></pre></td></tr></table></figure><h4 id="volumes"><code>volumes</code></h4><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">volumes:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">/var/lib/mysql</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">cache/:/tmp/cache</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">~/configs:/etc/configs/:ro</span><br></code></pre></td></tr></table></figure><p>如果路径为数据卷名称，必须在文件中配置数据卷。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">my_src:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql_data:/var/lib/mysql</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mysql_data:</span><br></code></pre></td></tr></table></figure><hr><blockquote><p>docker-compose 常用命令</p></blockquote><h5 id="1-命令对象与格式">1. 命令对象与格式</h5><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p><p>执行<code>docker-compose [COMMAND] --help</code>或者<code>docker-compose help [COMMAND]</code>可以查看具体某个命令的使用格式。</p><p><code>docker-compose</code>命令的基本的使用格式是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]<br></code></pre></td></tr></table></figure><h5 id="2-命令选项">2. 命令选项</h5><ul><li><code>-f, --file FILE</code>指定使用的 Compose 模板文件，默认为<code>docker-compose.yml</code>，可以多次指定。</li><li><code>-p, --project-name NAME</code>指定项目名称，默认将使用所在目录名称作为项目名。</li><li><code>--x-networking</code>使用 Docker 的可拔插网络后端特性</li><li><code>--x-network-driver DRIVER</code>指定网络后端的驱动，默认为<code>bridge</code></li><li><code>--verbose</code>输出更多调试信息。</li><li><code>-v, --version</code>打印版本并退出。</li></ul><h5 id="3-命令使用说明">3.命令使用说明</h5><h5 id="up"><code>up</code></h5><p>格式为<code>docker-compose up [options] [SERVICE...]</code>。</p><ul><li><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p></li><li><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p></li><li><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p></li><li><p>默认情况，<code>docker-compose up</code>启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p></li><li><p>当通过<code>Ctrl-C</code>停止命令时，所有容器将会停止。</p></li><li><p>如果使用<code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p></li><li><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code>将会尝试停止容器，然后重新创建（保持使用<code>volumes-from</code>挂载的卷），以保证新启动的服务匹配<code>docker-compose.yml</code>文件的最新内容</p></li></ul><hr><h5 id="down"><code>down</code></h5><ul><li>此命令将会停止<code>up</code>命令所启动的容器，并移除网络</li></ul><hr><h5 id="exec"><code>exec</code></h5><ul><li>进入指定的容器。</li></ul><hr><h5 id="ps"><code>ps</code></h5><p>格式为<code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li><code>-q</code>只打印容器的 ID 信息。</li></ul><hr><h5 id="restart"><code>restart</code></h5><p>格式为<code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code>指定重启前停止容器的超时（默认为 10 秒）。</li></ul><hr><h5 id="rm"><code>rm</code></h5><p>格式为<code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行<code>docker-compose stop</code>命令来停止容器。</p><p>选项：</p><ul><li><code>-f, --force</code>强制直接删除，包括非停止状态的容器。一般尽量不要使用</li></ul>]]></content>
    
    
    <categories>
      
      <category>运维技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.JS简单了解</title>
    <link href="/2022/11/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Node.JS%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/11/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Node.JS%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1>Node.JS简单了解</h1><p>node.js 是基于Chrome JavaScript 运行时建立的一个平台，简单说就是不需要浏览器就可以执行 javascript 代码</p><h2 id="安装及配置">安装及配置</h2><h3 id="下载安装-Node-js">下载安装 Node.js</h3><p>访问官网下载安装合适的 node.js：<a href="https://nodejs.org/zh-cn/%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%A5%BD%E5%90%8E%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85%EF%BC%8C%E5%85%A8%E7%A8%8B%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%8D%B3%E5%8F%AF">https://nodejs.org/zh-cn/，下载好后双击安装，全程下一步即可</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用cmd检测node是否安装成功</span><br>C:\Users\Administrator&gt;node -v   # 查看node版本<br>v10.16.3<br>C:\Users\Administrator&gt;npm -v    # 查看npm版本<br>6.9.0<br></code></pre></td></tr></table></figure><h3 id="修改安装及缓存路径">修改安装及缓存路径</h3><p>默认情况下，当我们安装了某个全局包的时候，是存放在C盘的，具体存放路径可在控制台输入<code>npm root -g</code>查看，但是我们想要将目录修改为自己的，需要进行以下操作：</p><p>**1.**在 node 的安装目录新建两个文件夹   全局包下载 <code>node_global</code>，node缓存 <code>node_cache</code></p><p><img src="..//img/node-01.jpg" alt=""></p><p>**2.**执行命令修改两个目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config set prefix &quot;node_global目录&quot;<br>npm config set cache &quot;node_cache目录&quot;<br></code></pre></td></tr></table></figure><h3 id="修改环境变量">修改环境变量</h3><p>当我们修改了全局安装路径及缓存后，环境变量还是没有修改的，需要去修改环境变量</p><p>**1.**在用户变量 <code>path</code> 中添加自己创建的 <code>node_global</code> 目录</p><p>**2.**系统变量中新建 <code>NODE_PATH</code> 为 node 安装目录下的 <code>modules</code> 目录</p><p>**3.**在系统变量中的 <code>path</code> 中添加 node 的安装目录，这个一般在安装的时候就会自动添加，如果没有就手动添加</p><h2 id="NPM-简单介绍">NPM 简单介绍</h2><h3 id="NPM-简单了解">NPM 简单了解</h3><p>npm 是用来辅助 node.js 的包管理工具，类似 maven 一样可以下载各种包/依赖，目前的 node 基本在安装的时候就将 npm 一并安装好了</p><blockquote><p>npm 的简单命令</p></blockquote><table><thead><tr><th>命令语法</th><th>解释</th></tr></thead><tbody><tr><td>npm -v</td><td>查看当前安装的 npm 的版本</td></tr><tr><td>npm install npm -g</td><td>升级 npm 版本号</td></tr><tr><td>npm config set proxy [location]</td><td>设置代理服务器，null 代表关闭代理</td></tr></tbody></table><blockquote><p>全局安装与本地安装</p></blockquote><p><strong>本地安装</strong> 是安装在当前目录下的 <code>node_modules</code> 目录中，如果目标目录不存在的话会自动生成，语法为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install @vue/cli<br></code></pre></td></tr></table></figure><p><strong>全局安装</strong> 是安装在之前配置的两个目录中，<code>-g</code> 代表 global 全局的意思</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g @vue/cli<br></code></pre></td></tr></table></figure><blockquote><p>更多命令</p></blockquote><table><thead><tr><th>命令语法</th><th>解释</th></tr></thead><tbody><tr><td>npm init</td><td>初始化简单的 package.json 文件</td></tr><tr><td>npm init --yes|-y</td><td>初始化简单的 package.json 文件，偷懒不用一直按enter</td></tr><tr><td>npm inistall 包名</td><td>本地安装，安装到项目目录下，不在 package.json 中写入依赖</td></tr><tr><td>npm inistall 包名 -g</td><td>全局安装，安装在 Node 安装目录下的 node_modules 下</td></tr><tr><td>npm inistall 包名 -s</td><td>本地安装，并在 package.json 文件的 dependencies 中写入依赖</td></tr><tr><td>npm inistall 包名 -D</td><td>本地安装，等价于–save -dev</td></tr><tr><td>npm uninstall 包名</td><td>本地卸载</td></tr><tr><td>npm uninstall 包名 -g</td><td>全局卸载</td></tr><tr><td>npm info 包名</td><td>可以查看指定包的历史版本</td></tr><tr><td>npm inistall 包名@x.x.x</td><td>在安装指定包的时候使用@可以指定安装的版本</td></tr></tbody></table><h3 id="安装淘宝镜像">安装淘宝镜像</h3><p>我们在使用 npm 安装某些依赖的时候，会发现安装非常的慢，因为 npm 默认的国外的下载地址，这个时候我们就可以通过安装淘宝镜像来解决这个问题，淘宝镜像对应的是 <code>cnpm</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">全局安装淘宝镜像</span><br>npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>安装完成之后简单使用一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">一般安装vue</span><br>npm install -g @vue/cli<br><span class="hljs-meta prompt_"># </span><span class="language-bash">淘宝镜像安装vue</span><br>cnpm install -g @vue/cli<br></code></pre></td></tr></table></figure><h3 id="安装-NRM-源管理器">安装 NRM 源管理器</h3><p>除了安装 cnpm 淘宝镜像之外还有一种方法可以安装淘宝镜像，那就是 nrm 源管理器，首先我们来安装 nrm 源管理器：</p><blockquote><p>全局安装 nrm 源管理器</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i nrm -g    # 这里也可以使用cnpm安装，当前前提得安装淘宝镜像<br></code></pre></td></tr></table></figure><p>等待安装完成之后我们可以通过查看版本号来检测是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">看到版本号，安装成功</span><br>C:\Users\Administrator&gt;nrm -V<br>1.2.1<br></code></pre></td></tr></table></figure><p>接下来我们通过源管理器来更管 npm 的源设置 <code>nrm use taobao</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">use代表选择，选择使用淘宝的镜像</span><br>C:\Users\Administrator&gt;nrm use taobao<br>   Registry has been set to: https://registry.npm.taobao.org/<br></code></pre></td></tr></table></figure><p>这样一来我们继续使用 npm 进行下载的时候，使用的就是淘宝的源了，除开淘宝之外还可以切换一些其他的源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">taobao 前面带有*就表示当前选择是淘宝镜像，第一个npm就是默认的国外镜像</span><br>C:\Users\Administrator&gt;nrm ls<br><br>  npm -------- https://registry.npmjs.org/<br>  yarn ------- https://registry.yarnpkg.com/<br>  cnpm ------- http://r.cnpmjs.org/<br>* taobao ----- https://registry.npm.taobao.org/<br>  nj --------- https://registry.nodejitsu.com/<br>  npmMirror -- https://skimdb.npmjs.com/registry/<br>  edunpm ----- http://registry.enpmjs.org/<br></code></pre></td></tr></table></figure><h2 id="Node-JS-体验">Node.JS 体验</h2><blockquote><p>写一个 helloword 程序</p></blockquote><p>我们新建一个  <code>hello.js</code> 文件，在里面书写 js 的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello Node.js!&quot;</span>);<br></code></pre></td></tr></table></figure><p>让我们来运行刚刚创建好的程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">程序成功执行了！</span><br>PS D:\Workspase\VScode\Node&gt; node hello.js<br>Hello Node.js!<br></code></pre></td></tr></table></figure><blockquote><p>写一个 helloword 的接口</p></blockquote><p>还是和刚才一样创建一个 <code>http1.js</code> 文件，书写以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);  <span class="hljs-comment">// 引入HTTP模块</span><br><span class="hljs-keyword">let</span> port = <span class="hljs-number">8000</span>;   <span class="hljs-comment">// 设置启动端口</span><br><br><span class="hljs-comment">// 创建一个HTTP服务</span><br>http.<span class="hljs-title function_">createServer</span>( <span class="hljs-function">(<span class="hljs-params">req, resp</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// 设置响应头【状态码，响应类型等等】</span><br>    resp.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;);<br>    <span class="hljs-comment">// 发送响应数据 &quot;HelloWorld, Http&quot;</span><br>    resp.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;HelloWorld, Http&#x27;</span>);<br>&#125;).<span class="hljs-title function_">listen</span>(port); <span class="hljs-comment">// 在目标端口启动</span><br><br><span class="hljs-comment">// 打印一个启动成功的提示，不然什么提示都没有很尴尬</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Http server runing! at port &quot;</span> + port);<br></code></pre></td></tr></table></figure><p>让我们来执行并访问一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">PS D:\Workspase\VScode\Node&gt; node http1.js<br>Http server runing! at port 8000<br></code></pre></td></tr></table></figure><p><img src="..//img/node-02.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Json &amp; Ajax 笔记</title>
    <link href="/2022/11/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Json&amp;Ajax/"/>
    <url>/2022/11/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Json&amp;Ajax/</url>
    
    <content type="html"><![CDATA[<h1>Json &amp; Ajax 笔记</h1><h2 id="Json-数据对象">Json 数据对象</h2><h3 id="1-了解-Json">1. 了解 Json</h3><p>Json是基于JavaScript语言用来<font color="red">传输数据</font>的一种手段，相比曾经的xml传输数据的手段，Json更高效，更轻便，更灵活，他是以<font color="red">键值对</font>的形式出现的，<font color="red">一个key对应一个value，中间用 <strong>:</strong> 连接</font>，其中所有的数据与的key必须都是双引号的字符串形式，而value的值可以是：</p><p>【数值】【字符串】【布尔】【数组】【对象】【Json】【null】</p><p>Json的代码表现：</p><ol><li><p>使用大括号封装 { }  ( 代表 Json 对象 )</p></li><li><p>使用中括号封装 [ ]（ 代表 Json 数组 ）</p></li></ol><h3 id="2-声明-Json-对象">2. 声明 Json 对象</h3><p>声明一个Json对象，其中 a 为 Object 类型的 Json 对象，通过 alert 语句可以访问到指定 key 的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a =&#123; <span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">1</span> , <span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-number">2</span> , <span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-number">3</span> &#125;<br><span class="hljs-title function_">alert</span>(a.<span class="hljs-property">a</span>)；<br></code></pre></td></tr></table></figure><p>Json 中的 value 中还可以套用 Json</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;<br> <span class="hljs-string">&quot;aa&quot;</span> : &#123; <span class="hljs-string">&quot;bb&quot;</span>:&#123; <span class="hljs-string">&quot;cc&quot;</span>:<span class="hljs-string">&quot;一个嵌套的Json的值&quot;</span> &#125; &#125;<br>&#125;<br><span class="hljs-title function_">alert</span>(a.<span class="hljs-property">aa</span>.<span class="hljs-property">bb</span>.<span class="hljs-property">cc</span>)<br></code></pre></td></tr></table></figure><p>使用 for-in 来遍历该 Json 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> json = &#123;<br>    <span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;字符串a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-string">&quot;字符串b&quot;</span>,<br>    <span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-string">&quot;字符串c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>: <span class="hljs-string">&quot;字符串d&quot;</span><br>&#125;<br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> a <span class="hljs-keyword">in</span> json )&#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(json.<span class="hljs-property">a</span> + <span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>)<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 使用这种遍历的方法是错误的</span><br><span class="hljs-comment">     * json.a这里的.a并没有当作变量来用，而是作为属性来用的</span><br><span class="hljs-comment">     * 他代表的是访问json下key为a的value</span><br><span class="hljs-comment">     * 想把a作为变量来用需要使用[]</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>( json[a] + <span class="hljs-string">&quot;&lt;br /&gt;&quot;</span> )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Json-数组操作">3. Json 数组操作</h3><p>使用 [ ] 声明的 Json 是 Object 类型的数组，里面可以存放 ≥1 数量的 Json，通过下标可以访问到 Json 以及 Json 中某个 key 具体的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> json[<br>    &#123; <span class="hljs-string">&quot;课程&quot;</span>:<span class="hljs-string">&quot;Java&quot;</span> , <span class="hljs-string">&quot;价格&quot;</span>:<span class="hljs-string">&quot;21300.00￥&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;课程&quot;</span>:<span class="hljs-string">&quot;PHP&quot;</span> , <span class="hljs-string">&quot;价格&quot;</span> : <span class="hljs-string">&quot;16300.00￥&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;课程&quot;</span>:<span class="hljs-string">&quot;Python&quot;</span> , <span class="hljs-string">&quot;价格&quot;</span> : <span class="hljs-string">&quot;23100.00￥&quot;</span> &#125;<br>]<br></code></pre></td></tr></table></figure><blockquote><p>在数组中追加元素</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">json.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-string">&quot;课程&quot;</span>: <span class="hljs-string">&quot;Webpack&quot;</span>, <span class="hljs-string">&quot;价格&quot;</span>: <span class="hljs-string">&quot;18000￥&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>查询，删除某个元素</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// indexOf 查询当前对象是否存在，如果存在返回该对象所在的下标，不存在则返回-1</span><br><span class="hljs-keyword">if</span>( json.<span class="hljs-title function_">indexOf</span>(json[<span class="hljs-number">0</span>])!=-<span class="hljs-number">1</span> )<br>    <span class="hljs-comment">// 从当前位置开始，删除1个元素，也就是他本身</span><br>    json.<span class="hljs-title function_">splice</span>(json.<span class="hljs-title function_">indexOf</span>(json[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p>遍历该 Json 数组</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">for( var a in json )<span class="hljs-punctuation">&#123;</span><br>    for( var b in json<span class="hljs-punctuation">[</span>a<span class="hljs-punctuation">]</span> )<br>     document.write( b + <span class="hljs-string">&quot;：&quot;</span> + json<span class="hljs-punctuation">[</span>a<span class="hljs-punctuation">]</span><span class="hljs-punctuation">[</span>b<span class="hljs-punctuation">]</span> + <span class="hljs-string">&quot; ， &quot;</span> )<br> document.write(<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>)<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="4-Json的数据转换">4.  Json的数据转换</h3><h4 id="js-中互相转换">js 中互相转换</h4><blockquote><p>在 js 中有一个 JSON 对象，里面封装了两个方法，针对于 Json 与 JS 的格式转换</p></blockquote><h5 id="Json-→-JS">Json → JS</h5><p>使用 JSON 对象中提供的 stringify( json ) 方法将 Json 类型的对象装换为 js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 声明一个Json对象</span><br><span class="hljs-keyword">var</span> json1 = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张涵哲&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;20&quot;</span>,<span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;男&quot;</span>&#125;<br><span class="hljs-keyword">var</span> json2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(json1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json2);<br></code></pre></td></tr></table></figure><h5 id="JS-→-Json">JS → Json</h5><p>使用 JSON 中提供的 parse ( str ) 方法将 Json 类型的对象装换为 js</p><blockquote><p>字符串类型的Json必须时单引号扩着双引号</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 声明一个Js对象</span><br><span class="hljs-keyword">var</span> js1 = <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;张&quot;,&quot;age&quot;:&quot;20&quot; &#125;&#x27;</span>;<br><span class="hljs-comment">// JS转换为JSON</span><br><span class="hljs-keyword">var</span> js2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(js1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(js2)<br></code></pre></td></tr></table></figure><h4 id="Java-中相互转换">Java 中相互转换</h4><blockquote><p>而如果想在 <strong>Java</strong> 中实现 Json 和对象之间的转换，需要借助一个依赖 jar 包，通过 ObjectMapper 的实例对象 om 进行操作</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="Java-→-Json">Java → Json</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;张涵哲&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;男&quot;</span>);<br><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;  msg = om.writeValueAsString(user); &#125; <br><span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;  System.out.println(<span class="hljs-string">&quot;解析失败！&quot;</span>); &#125;<br>System.out.pringln( msg )<br></code></pre></td></tr></table></figure><h5 id="Json-→-Java">Json → Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里没有现成的Json对象，就用String拼接一个出来</span><br><span class="hljs-type">String</span> <span class="hljs-variable">json2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;张涵哲\&quot;,\&quot;age\&quot;:20,\&quot;sex\&quot;:\&quot;男\&quot;&#125;&quot;</span>;<br><span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> om.readValue(json2, User.class);<br>System.out.println(user2);<br></code></pre></td></tr></table></figure><h5 id="List-→-Json">List → Json</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;啊啊&quot;</span>);<br>list.add(<span class="hljs-string">&quot;嘿嘿&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">json3</span> <span class="hljs-operator">=</span> om.writeValueAsString(list);<br>System.out.println(json3);<br></code></pre></td></tr></table></figure><h5 id="Map-→-Json">Map → Json</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String,String&gt; hm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,String&gt;();<br>hm.put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);<br>hm.put(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">json4</span> <span class="hljs-operator">=</span> om.writeValueAsString(hm);<br>System.out.println(json4);<br></code></pre></td></tr></table></figure><h3 id="5-MVC-中-Json-中文乱码解决">5. MVC 中 Json 中文乱码解决</h3><p>在向客户端返回Json数据的时候，会产生中文乱码的情况，需要使用@RequestMapping中的produces属性解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody()</span><br><span class="hljs-meta">@RequestMapping(path = &quot;/json1&quot; , produces = &quot;application/json;charset=utf-8&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">json1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;张涵哲&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        msg = om.writeValueAsString(user);<br>    &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;解析失败！&quot;</span>);<br>        System.exit(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> msg;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Ajax-异步处理">Ajax 异步处理</h2><p>ajax 是基于JavaScript 语言，它实现在不刷新页面的情况下向服务器发出请求，达到异步交互，主要依靠的核心对象是 <strong>XMLHttpRequest</strong></p><h3 id="ajax-对象常用属性">ajax 对象常用属性</h3><ol><li><p><strong>onreadystatechange</strong></p><p>设置回调函数，当发起请求的时候，服务器会处理请求，在处理结束后会返回一个信号，紧接着调用回调函数，他是在服务器处理完请求后执行的一个函数</p></li><li><p><strong>readyState</strong>，代表着与服务器交互的过程的变化，通过 0-4 五个数字来表示</p><table><thead><tr><th style="text-align:center">数字</th><th>解释</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td>刚刚创建了XMLHttpRequest对象</td></tr><tr><td style="text-align:center">1</td><td>打开了与服务器的连接（调用了open方法）</td></tr><tr><td style="text-align:center">2</td><td>向服务器发出了请求（调用了send方法）</td></tr><tr><td style="text-align:center">3</td><td>服务器将请求处理完毕</td></tr><tr><td style="text-align:center">4</td><td>交互正常结束</td></tr></tbody></table></li><li><p><strong>status</strong>，服务器相应的状态码，等同于http协议的状态码</p><table><thead><tr><th>状态吗</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>表示服务器正常工作</td></tr><tr><td>303</td><td>表示服务器内部出现了错误</td></tr><tr><td>404</td><td>找不到请求的目标资源</td></tr><tr><td>500</td><td>发生了重定向</td></tr></tbody></table></li><li><p><strong>responseText</strong>，封装服务器给客户端响应的文本数据</p></li><li><p><strong>responseXML</strong>，封装服务器给客户端相应的xml文件类型数据</p></li></ol><h3 id="ajax-的方法函数">ajax 的方法函数</h3><ol><li><p>open( string str1 , string str2 , boolean b )，打开与服务器的连接，open方法中的三个属性</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>string str1</td><td>请求的方式，get-post等</td></tr><tr><td>string str2</td><td>请求的资源路径</td></tr><tr><td>boolean b</td><td>是否开启异步处理，true为开启，false为不开启</td></tr></tbody></table></li><li><p>send( string str )，向服务器发出请求，在执行open方法后运行，有一个属性</p><p>str：如果请求方式为post，可以传入 key=value&amp;key=value 的字符串作为参数</p><p>如果为 get 请求，参数可以留空或 null，get 请求传参在打开连接时拼接字符串即可</p></li><li><p>setRequestHeader( str1 , str2 )</p><p>​ 修改请求头信息，==只有post请求需要修改==，get可以忽略，应在打开连接后，发出请求前设置</p><p>​    str1：被修改的请求头【”Content-type”】</p><p>​    str2：修改后的值：【”application/x-www-form-urlencoded”】</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 笔记</title>
    <link href="/2022/11/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/vue%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/vue%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>Vue 笔记</h1><h2 id="基本-vue-页面">基本 vue 页面</h2><p>基本的 vue 页面，需要引用 vue.js 才可以运行，引用地址如下，也可以下载后引用本地文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://cdn.staticfile.org/vue/<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span>/vue.min.js<br></code></pre></td></tr></table></figure><h3 id="EL挂载点">EL挂载点</h3><p>el 挂载点，是 ELement（元素）单词的缩写，在new Vue对象的时候需要指定一个标签为挂载点，基于这个挂载点展开操作</p><p>挂载点有三种：</p><ol><li>id 挂载点</li><li>class 挂载点</li><li>元素挂载点</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;one&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span> 这个标签已经被vue接管 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#one&quot;</span> <span class="hljs-comment">// id挂载点</span></span><br><span class="language-javascript">   <span class="hljs-comment">// el: &quot;.two&quot; // class挂载点</span></span><br><span class="language-javascript">   <span class="hljs-comment">// el: &quot;div&quot; ,  // 元素挂载点</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>挂载点也可以理解为作用域，被挂载的标签连同他的子标签都是作用域内有效，挂载点之外Vue不起作用</p><p>挂载点可以书写在HTML任何标签上，但唯独<strong>不可以写在 html 和 body 标签上</strong></p><h3 id="data-数据对象">data 数据对象</h3><p>在绑定挂载点之后，就可以使用 data 数据对象，需要在 vue 实例中声明 data 数据对象，然后在 data 中声明变量名及对应的值，声明规则以 JSON 为基准</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#good&quot;</span> ,<span class="hljs-comment">// id挂载点</span><br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;vue中的数据&quot;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>想要调用并使用 data 数据需要使用 <strong>差值表达式 { {  } }</strong> ，他的效果类似 java 中的 print 方法，负责打印</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;good&quot;</span>&gt;</span> &#123;&#123; message &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#good&quot;</span> ,<span class="hljs-comment">// id挂载点</span></span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;vue中的数据&quot;</span></span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>data 数据对象中可以封装简单类型及复杂类型的对象，但是要遵守 JS 的语法规则</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fon&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!-- 普通数据对象可以直接用双大括号取值 --&gt;</span><br>   1.<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <span class="hljs-comment">&lt;!-- 嵌套Json对象需要使用.来指定某个属性 --&gt;</span><br>   2.<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>&#123;&#123; person.name&#125;&#125; , &#123;&#123; person.age &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <span class="hljs-comment">&lt;!-- 如果时数组的话需要使用 [ ] 来指定要取指定下标上对应的值 --&gt;</span><br>   3.<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>&#123;&#123; tel[0] &#125;&#125;-&#123;&#123; tel[1] &#125;&#125;-&#123;&#123; tel[2] &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <span class="hljs-comment">&lt;!-- 对象中也可以嵌套数组 --&gt;</span> <br>   4.<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>&#123;&#123; test.demo1.arr[0] &#125;&#125;&#123;&#123; test.demo1.arr[1] &#125;&#125;，<br>    &#123;&#123; test.demo2.arr[0] &#125;&#125;&#123;&#123; test.demo2.arr[1] &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <span class="hljs-comment">&lt;!-- 数组内也可以嵌套Json对象 --&gt;</span><br>   5.<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>&#123;&#123; test.demo3.arr[0].name &#125;&#125;，&#123;&#123; test.demo3.arr[1].name &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#fon&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李云龙&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">person</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;爱新觉罗·溥仪&quot;</span> , <span class="hljs-attr">age</span>: <span class="hljs-number">88</span> &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">tel</span>: [ <span class="hljs-number">155</span> , <span class="hljs-number">8555</span> , <span class="hljs-number">7724</span> ],</span><br><span class="language-javascript">    <span class="hljs-attr">test</span>: &#123;</span><br><span class="language-javascript">     <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;测试对象&quot;</span>,</span><br><span class="language-javascript">     <span class="hljs-attr">demo1</span>: &#123; <span class="hljs-attr">arr</span>: [<span class="hljs-string">&quot;中国&quot;</span>,<span class="hljs-string">&quot;男足&quot;</span>] &#125;,</span><br><span class="language-javascript">     <span class="hljs-attr">demo2</span>: &#123; <span class="hljs-attr">arr</span>: [<span class="hljs-string">&quot;中国&quot;</span>,<span class="hljs-string">&quot;女乒&quot;</span>] &#125;,</span><br><span class="language-javascript">     <span class="hljs-attr">demo3</span>: &#123; <span class="hljs-attr">arr</span>: [ &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;第一个元素&quot;</span>&#125;,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;第二个元素&quot;</span>&#125; ] &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="methods-方法">methods 方法</h3><p>Vue 实例中可以写 el 挂载点，也可以写 data 数据对象，同时也可以写 methods，等同于 js 的函数，定义方法的格式为：<code>name: function()&#123;&#125;</code>，也可以使用缩写 <code>name()&#123;&#125;</code>，效果是一致的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>   &#123;&#123; func1() &#125;&#125;  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   &#123;&#123; func1 &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;div&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">          func1 : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">           <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;函数的返回值&quot;</span>;</span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">                <span class="hljs-comment">// 等同于 func1()&#123; return &quot;函数的返回值&quot;; &#125;</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在页面调用 func1() 的时候，会调用并执行指定的函数，而调用 func1 的时候，仅仅调用的是他的内存地址</li></ul><h3 id="Vue-基础注意事项">Vue 基础注意事项</h3><h4 id="data-与-methods-之间的调用问题">data 与 methods 之间的调用问题</h4><p>在 vue 中，data 就相当于 java 中的一个变量，变量有自己的值，且能够在函数中被使用，在 vue 中也要留意调用问题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;func1()&quot;</span>&gt;</span>弹窗测试1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;func2()&quot;</span>&gt;</span>弹窗测试2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   &#123;&#123; text &#125;&#125; , &#123;&#123; value1 &#125;&#125; , &#123;&#123; value2 &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#roor&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">func1</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;func1: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">func2</span>())</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">func2</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;func2: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span>)</span><br><span class="language-javascript">     <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;方法2的返回值&quot;</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;data数据&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">value1</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">value2</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">func1</span></span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>经测试可以得出结论</p><ul><li>data 中声明的变量可以在函数中使用 <code>this.变量名</code> 调用</li><li>data 中不可以调用函数获得返回值</li><li>data 中后声明的变量并不能调用先声明的变量</li><li>methods 中声明的函数可以互相调用，不分声明的顺序</li><li>data 和 methds 的调用之前不分声明的顺序</li></ul><h2 id="Vue-指令学习">Vue 指令学习</h2><h3 id="一般指令">一般指令</h3><h4 id="v-text-指令">v-text 指令</h4><p>设置标签内容的指令，使用方法如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; zuoyong &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123;  &quot;插值表达式中字符串的拼接：&quot; + date &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;text1&quot;</span>&gt;</span>原有内容<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; text2 &#125;&#125;原有内容<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;text3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; text3 &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;text4 + text5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br> <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#ul&quot;</span>,<br> <span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;通过v-text指令&quot;</span>,<br>  <span class="hljs-attr">zuoyong</span>: <span class="hljs-string">&quot;通过差值表达式&quot;</span>,<br>  <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2019-11-27&quot;</span>,<br>  <span class="hljs-attr">text1</span>: <span class="hljs-string">&quot;v-text覆盖原有内容&quot;</span>,<br>  <span class="hljs-attr">text2</span>: <span class="hljs-string">&quot;差值表达式不会覆盖&quot;</span>,<br>  <span class="hljs-attr">text3</span>: <span class="hljs-string">&quot;&lt;font color=&#x27;red&#x27;&gt;我会变红嘛&lt;/font&gt;&quot;</span>,<br>  <span class="hljs-attr">text4</span>: <span class="hljs-string">&quot;两个v-text&quot;</span>,<br>  <span class="hljs-attr">text5</span>: <span class="hljs-string">&quot;的字符串拼接&quot;</span><br> &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="v-html-指令">v-html 指令</h4><p>无论是差值表达式还是v-text，输出解析的都只是普通文本，如果想让文本可以解析为html标签，就需要v-html指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ul1&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br> <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#ul1&quot;</span>,<br> <span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;&lt;font color=&#x27;red&#x27;&gt;font标签的红色字体&lt;/font&gt;&quot;</span><br> &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="v-on-指令">v-on 指令</h4><p>v-on为事件指令，像绑定JS事件一样来绑定Vue的事件，例如【单击事件】【双击事件】【鼠标滑过】等等</p><ol><li><p>被绑定的事件关键字删除前置的on字母，使用v-on:代替，例如：onclick → v-on:click</p></li><li><p>还有一种简化的写法，同样删除事件关键字前置的on关键字，用@符号代替</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;func1&quot;</span>&gt;</span>一般v-on单击事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;func1&quot;</span>&gt;</span>简化v-on单击事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">dblclick</span>=<span class="hljs-string">&quot;func1&quot;</span>&gt;</span>简化v-on双击事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br> <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;div&quot;</span>,<br> <span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">text1</span>: <span class="hljs-string">&quot;v-on事件&quot;</span><br> &#125;,<br> <span class="hljs-attr">methods</span>: &#123;<br>  func1 : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">text1</span>);<br>  &#125;<br> &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="v-show-指令">v-show 指令</h4><p>v-show通过操作样式来控制元素是否显示的指令，里面可以写boolean值，true为显示，false为不显示，也可以写表达式，最终会计算为boolean</p><p>未满十八周岁禁止注册的小例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;d1&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>未满十八周岁禁止注册<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br> 您当前的年龄：<br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sub()&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add()&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;age&gt;=18&quot;</span>&gt;</span>点击注册<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br> <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#d1&quot;</span> ,<br> <span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">15</span><br> &#125;,<br> <span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>++; &#125;,<br>  <span class="hljs-attr">sub</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>--; &#125;<br> &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>通过操作元素的display属性来控制元素是否显示</p><p>&lt;/img src=“.//img/vue-03.png” style=“float: left” /&gt;</p><h4 id="v-if-指令">v-if 指令</h4><p>v-if通过操作Dom来控制元素是否存在达到显示和隐藏的效果，效果类似与v-show，但是本质上有着区别，v-show是操作元素的display属性，而v-if操作的是当前标签是否存在</p><p>还是未满18周岁禁止注册的例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">new Vue(&#123;<br> el: &quot;#d1&quot; ,<br> data: &#123;<br>  age: 15<br> &#125;,<br> methods: &#123;<br>  add: function() &#123; this.age++; &#125;,<br>  sub: function() &#123; this.age--; &#125;<br> &#125;<br>&#125;)<br>-------------------------------------------------------------<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;d1&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>未满十八周岁禁止注册<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br> 您当前的年龄：<br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sub()&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add()&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;age&gt;=18&quot;</span>&gt;</span>点击注册<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>通过操作Dom控制元素是否存在来达到显示效果，如果某一个元素需要频繁的隐藏或切换的话，那么请使用v-show，相对v-if来说，频繁切换的情况下v-show的效率更高一些</p><p>&lt;/img src=“.//img/vue-04.png” /&gt;</p><h4 id="v-bind-指令">v-bind 指令</h4><p>元素绑定属性，可以控制某个元素的属性的值，当数据发生改变时视图对应的也会发生改变，但视图发生改变时数据不会发生改变</p><p>使用方法：</p><p>​    1. 直接绑定元素 v-bind:width=“”</p><p>​    2. 简单绑定元素 :width=“”</p><p>代码演示：为div填色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#div</span> &#123;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;<br> <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br><span class="hljs-selector-class">.d1</span> &#123;<br> <span class="hljs-attribute">background-color</span>: bisque;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 通过三元表达式来控制class属性是否显示 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot; bool ? &#x27;d1&#x27; : &#x27; &#x27; &quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;setClass()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 也可以使用：的缩写进行绑定 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot; bool ? &#x27;d1&#x27; : &#x27; &#x27; &quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;setClass()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br> <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#div&quot;</span>,<br> <span class="hljs-attr">data</span>: &#123;<br>  bool : <span class="hljs-literal">false</span><br> &#125;,<br> <span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-attr">setClass</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">bool</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">bool</span>;<br>  &#125;<br> &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="v-model-指令">v-model 指令</h4><ul><li><strong>双向绑定更新数据</strong></li></ul><p>双向绑定，主要用于表单数据和 vue 数据互相绑定，更改 data 的值的时候，data 所对应的视图也会更改，而视图进行更改时，对应的 data 也会发生更改</p><p>代码演示-动态验证密码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;message&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>&#123;&#123; message == password ? &#x27;输入正确&#x27; : &#x27;输入错误&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br> <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#div&quot;</span>,<br> <span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;11223344&quot;</span>,<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;&quot;</span><br> &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><font color="red"><strong># 监听表单状态</strong></font></li></ul><p>v-model 指令最强大的功能是可以监听页面中表单的数据状态</p><blockquote><p>分别监听 文本框 单选框 复选框 下拉框 日期 时间 的小案例</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">   <span class="hljs-selector-class">.color</span> &#123;  <span class="hljs-attribute">color</span>: red;  &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.size</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;  &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.italic</span> &#123;  <span class="hljs-attribute">font-style</span>: italic;  &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>vue监听: &#123;&#123; text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span> /&gt;</span>男<br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span> /&gt;</span>女<br>   <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>vue监听: &#123;&#123; gender &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;游泳&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;likes&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;likes&quot;</span> /&gt;</span>游泳<br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;健身&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;likes&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;likes&quot;</span> /&gt;</span>健身<br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;音乐&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;likes&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;likes&quot;</span> /&gt;</span>音乐<br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;打游戏&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;likes&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;likes&quot;</span> /&gt;</span>打游戏<br>   <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>vue监听: &#123;&#123; likes &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>广东<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>vue监听: &#123;&#123; address &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;data&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>vue监听: &#123;&#123; data &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;time&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;time&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>vue监听: &#123;&#123; time &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;text文本框&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;男&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">likes</span>: [<span class="hljs-string">&quot;健身&quot;</span>,<span class="hljs-string">&quot;打游戏&quot;</span>],</span><br><span class="language-javascript">    <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;北京&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;2020-02-02&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">time</span>: <span class="hljs-string">&quot;12:20&quot;</span></span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-for-指令">v-for 指令</h4><p>循环当前标签及子标签，循环的次数是指定数组的长度</p><p>使用方法：</p><p>​    1. 【(代表数组内的每个值/对象 , 下标 ) in 数组名)】</p><p>​    2.  也可以不使用下标【代表数组内的每个值/对象 in 数组名】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;add()&quot;</span>&gt;</span>点击添加&quot;神舟电脑&quot;商品<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;del()&quot;</span>&gt;</span>点击删除第一个商品<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1px&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0px&quot;</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;5px&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in arr&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>第 &#123;&#123; index+1 &#125;&#125; 个商品<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br> <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#div&quot;</span>,<br> <span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">arr</span>: [<br>   &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;iPhone 11&quot;</span>&#125;,<br>   &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Xiaomi cc9 pro&quot;</span>&#125;,<br>   &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Redmi Note4X&quot;</span>&#125;,<br>   &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;VIVO X30&quot;</span>&#125;,<br>   &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;OPPO Reno Ace&quot;</span>&#125;<br>  ]<br> &#125;,<br> <span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-comment">// 向arr(数组)尾部追加元素</span><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>.<span class="hljs-title function_">push</span>( &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;神舟电脑&quot;</span>&#125;);<br>  &#125;,<br>  <span class="hljs-attr">del</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-comment">// 删除第一个元素</span><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>.<span class="hljs-title function_">shift</span>();<br>  &#125;<br> &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="v-bind-高级绑定">v-bind 高级绑定</h4><p>可以绑定至class后可以直接输入数组，数组内存放需要使用的class，也可以直接输入对象，对象的key为class，value为Boolean值，为true则生效，false则不生效</p><p>绑定至style后，也可以直接将对象输入进去，也可以将对象放进数组中然后输入数组，同样生效</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">   <span class="hljs-selector-class">.color</span> &#123;  <span class="hljs-attribute">color</span>: red;  &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.size</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;  &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.italic</span> &#123;  <span class="hljs-attribute">font-style</span>: italic;  &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;msg1&quot;</span>&gt;</span>我是一个font标签<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;msg2&quot;</span>&gt;</span>我是一个font标签<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;sty&quot;</span>&gt;</span>我是一个font标签<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">msg1</span>: [ <span class="hljs-string">&quot;size&quot;</span> , <span class="hljs-string">&quot;italic&quot;</span> ],</span><br><span class="language-javascript">    <span class="hljs-attr">msg2</span>: &#123;</span><br><span class="language-javascript">     <span class="hljs-string">&quot;color&quot;</span>:<span class="hljs-literal">true</span>,</span><br><span class="language-javascript">     <span class="hljs-string">&quot;size&quot;</span>:<span class="hljs-literal">true</span>,</span><br><span class="language-javascript">     <span class="hljs-string">&quot;italic&quot;</span>:<span class="hljs-literal">false</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">sty</span>: &#123; <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;blue&quot;</span> , <span class="hljs-string">&quot;font-size&quot;</span>: <span class="hljs-string">&quot;20px&quot;</span> &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="内部指令">内部指令</h3><h4 id="v-pre-指令">v-pre 指令</h4><p>v-pre 指令的作用是将代码原样输出，例如以下情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    我们在学习vue的时候可以使用差值表达式来显示值，<br>    使用方法是<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-pre</span>&gt;</span>&#123;&#123;good&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>，显示出来的值就是&#123;&#123;good&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-string">&quot;good&quot;</span>: <span class="hljs-number">123</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="v-cloak-指令">v-cloak 指令</h4><p>使用差值表达式的时候，如果在网速较慢的情况下，会看到在 vue 绑定的值出现之前会把差值表达式的 <code>&#123;&#123; &#125;&#125;</code> 展现出来，等待加载出来后才会把值替换过来，针对这种可以使用 v-cloak 指令配合 css 来解决</p><blockquote><p>v-cloak 特点：在页面请求的过程中存在，请求结束并收到响应后消失，配合 display 样式可以达到最终效果</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[v-cloak]</span>&#123;<br> <span class="hljs-attribute">display</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fon&quot;</span> <span class="hljs-attr">v-cloak</span>&gt;</span>&#123;&#123;aaa&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br> <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#fon&quot;</span>,<br> <span class="hljs-attr">data</span>:&#123; <span class="hljs-attr">aaa</span>: <span class="hljs-string">&quot;123&quot;</span> &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在这里可以设置网络速度，用来测试</p><p>&lt;/img src=“.//img/vue-02.png” /&gt;</p><h4 id="v-once-指令">v-once 指令</h4><p>v-once 指令内的变量只会渲染一次</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-once</span>&gt;</span>第一次绑定的值：&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Vue-自定义指令">Vue 自定义指令</h3><p>在 vue 中，除开官方提供的几个指令 ( v-if , v-for 等 )，还可以通过自定义指令达到某种效果，自定义指令分别有【全局指令】【局部指令】两种，<font color='red'>自定义指令不能包含大写字母，可能会失效</font></p><p>定义指令需要两个参数：</p><ul><li>第一个 指令名称，字符串体现，书写指令名称的时候要省略掉 v- 标识符，但是在使用的时候要加上 v- 标识符</li><li>第二个 指令对象，可以使用匿名对象，有两个<ul><li>第一个 el 固定参数，代表当前指令所在标签的 DOM 对象</li><li>第二个 binding 传入参数，当使用自定义指令时传入了参数，binding 就是传入参数的对象，常用属性有<ul><li>name：代表当前指令名称</li><li>value：获取接收参数的表达式的值 ( 例如传入表达式 2+3，得到的就是 5 )</li><li>oldValue：指令绑定的上一个值，仅在 update 和 componentUpdated 钩子中可用</li><li>expression：获取当前参数的字符串表达形式 ( 例如传入表达式 2+3，得到的就是 2+3 )</li></ul></li></ul></li></ul><p>传入参数是需要注意，如果传入的参数是</p><blockquote><p>自定义 全局指令及使用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">v-setcolor</span>=<span class="hljs-string">&quot;&#x27;blue&#x27;&quot;</span>&gt;</span>测试数据<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&quot;setcolor&quot;</span>, &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">bind</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"> el, binding </span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name=&quot;</span> + binding.<span class="hljs-property">name</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;value=&quot;</span> + binding.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;oldValue=&quot;</span> + binding.<span class="hljs-property">oldValue</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;expression=&quot;</span> + binding.<span class="hljs-property">expression</span>);</span><br><span class="language-javascript">    el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span>;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span> &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>自定义 局部指令及使用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-fontcolor</span>&gt;</span>测试局部指令<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; </span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">directives</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&quot;fontcolor&quot;</span>: &#123;</span><br><span class="language-javascript">     <span class="hljs-attr">bind</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">el</span>)&#123;</span><br><span class="language-javascript">      el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;blue&quot;</span>;</span><br><span class="language-javascript">     &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>钩子函数</strong></p><ul><li>bind：指令第一次绑定到元素时调用，只调用一次<ul><li>函数运行时指令刚刚与 DOM 节点绑定，这是只能使用一些 DOM 的属性操作，例如字体颜色等</li></ul></li><li>inserted：当前 DOM 对象放入父节点时调用<ul><li>函数运行时当前 DOM 已经插入到 DOM 树中，可以进行例如 获取焦点 等</li></ul></li><li>update：被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新</li></ul><p><strong>缩写指令</strong></p><p>当自定义一个指令的时候需要指定其中的 bind 或 inserted 等等的钩子函数，但是这么写比较麻烦，可以缩写</p><p><font color="red">缩写的代码同时作用在 ==bind== 和 ==updated== 两个钩子函数中</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>、<br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-fontweight</span>=<span class="hljs-string">&quot;900&quot;</span>&gt;</span>缩写指令测试<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 创建局部命令</span></span><br><span class="language-javascript">  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&quot;fontweight&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">el, binding</span>)&#123;</span><br><span class="language-javascript">   el.<span class="hljs-property">style</span>.<span class="hljs-property">fontWeight</span> = binding.<span class="hljs-property">value</span>;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span> &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Vue-的生命周期">Vue 的生命周期</h2><p>vue 的生命周期，又被称为钩子函数，是指 vue 实例从开始到销毁的过程，在生命周期函数中可以运行一些逻辑代码，常用的生命周期函数需要知道以下 8 种即可</p><p>按照加载的先后顺序排列：</p><ol><li>==初始化==的生命周期</li></ol><ul><li>beforeCreate，这个时候的 vue 只是一个空对象，还没有初始化，el，data，methods 等不可用</li><li>created，vue 初始化完成，可以使用 el，data，methods 等等</li></ul><ol start="2"><li>==挂载页面==的生命周期<ul><li>beforeMount，vue 已经在内存中加载完成，但并没有挂载到页面中，无法在页面上使用 vue</li><li>mounted，当 mounted 运行后，vue就已经完全创建好且已经挂在到页面中了，可以正常使用</li></ul></li><li>==更新页面==的生命周期<ul><li>beforeUpdate，此时 vue 中的数据被更改，但是页面上的数据还没有同步</li><li>updated，vue中的数据被更改，页面上已同步完成</li></ul></li><li>==页面销毁==的生命周期<ul><li>beforeDestroy，当前 vue 实例将被销毁，但是还没有被销毁，data，methods 等可以继续使用</li><li>destroyed，当前 vue 实例已被销毁，data，methods 等将不可用</li></ul></li></ol><p>代码演示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;msg = &#x27;嘿嘿&#x27;&quot;</span>&gt;</span>修改为 嘿嘿<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dd&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#roor&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;哈哈哈哈&quot;</span></span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;beforeCreate: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>)</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;cerated: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>)</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;beforeMount: &quot;</span> +  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;dd&quot;</span>).<span class="hljs-property">innerText</span>)</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;beforeMount: &quot;</span> +  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;dd&quot;</span>).<span class="hljs-property">innerText</span>)</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;beforeUpdate: vue的msg已经改为 &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span> + <span class="hljs-string">&quot;，页面上显示的是 &quot;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;dd&quot;</span>).<span class="hljs-property">innerText</span>)</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;beforeUpdate: vue的msg已经改为 &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span> + <span class="hljs-string">&quot;，页面上显示的是 &quot;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;dd&quot;</span>).<span class="hljs-property">innerText</span>)</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">            <span class="hljs-comment">// 没法演示，，，</span></span><br><span class="language-javascript">   <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>)&#123;&#125;,</span><br><span class="language-javascript">   <span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>)&#123;&#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>控制台图示：</p><p>&lt;/img src=“.//img/vue-11.png” /&gt;</p><h2 id="Vue-的组件">Vue 的组件</h2><p>vue 的组件可以理解为一个通用的模板，当一段重复的 html 代码反复的出现在页面中，这个时候就可以将这些重复的代码封装成为一个组件，通过调用组件来实现代码的复用</p><h3 id="创建一个组件">创建一个组件</h3><p>vue 的组件就是一个对象，里面有有几个常用的属性，例如 template 属性是控制组件内的元素的，<font color="red" >在template中有且只能由一个根元素，如有多个元素需要放在一个标签 ( 例如 div ) 内</font></p><blockquote><p>创建一个组件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> com1 = &#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h1&gt;123&lt;/h1&gt;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其中 template 的标签可以放在HTML中书写，而后通过 id 调用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp1&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">zhe</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">zhe</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> zhe = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;#temp1&quot;</span>  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#roor&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">components</span>: &#123;  <span class="hljs-string">&quot;zhe&quot;</span>: zhe  &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="全局组件与局部组件">全局组件与局部组件</h3><p>vue 的组件分为全局组件和局部组件两种，全局组件在所有 vue 实例中都可以使用，而局部组件只能在指定的 vue 实例中使用</p><ol><li><p>声明全局组件：组件注册到 component 之后就会称为全局组件，全局组件有两种调用的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 1. 将组件名以标签的形式发放在html中 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">com1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com1</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 2. 使用component标签，is的属性为组件的名称 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">is</span>=<span class="hljs-string">&quot;com1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 创建一个组件</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> zhe = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;font color=&#x27;green&#x27;&gt;绿色-组件&lt;/font&gt;&quot;</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-comment">// 将组件注册到component称为了全局组件</span></span><br><span class="language-javascript">  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;com1&quot;</span>, zhe)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>声明局部组件：放在 vue 实例中就是指定实例的局部组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> zhe = &#123;<br>    <span class="hljs-comment">// 创建组件</span><br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;font color=&#x27;red&#x27;&gt;红色-局部组件&lt;/font&gt;&quot;</span><br>&#125;<br><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>    <span class="hljs-attr">components</span>: &#123;<br>        <span class="hljs-comment">// 使用componens注册组件，左侧为组件名称，右侧为组件对象</span><br>        <span class="hljs-string">&quot;com2&quot;</span>: zhe<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><p>测试代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app1&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">com1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com1</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">com2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app2&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">com1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com1</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">com2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> a = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;font color=&#x27;red&#x27;&gt;红色-局部组件&lt;/font&gt;&quot;</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;com1&quot;</span>, &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;font color=&#x27;green&#x27;&gt;绿色-全局组件&lt;/font&gt;&quot;</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app1&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&quot;com2&quot;</span>: a</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app2&quot;</span>,</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>要在组件创建完成后才可以创建Vue对象设置挂载点</li></ul><h3 id="动态组件切换">动态组件切换</h3><p>在页面中显示组件的方法，除开使用组件名称作为标签名，还可以使用动态标签进行组件的引用</p><blockquote><p>使用 component 标签来显示组件，然后使用标签内的 is 属性引用组件名，is 可以被绑定实现动态显示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../static/js/vue.min.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>动态组件标签<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;flag = !flag&quot;</span>&gt;</span>切换组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;flag?&#x27;com1&#x27;:&#x27;com2&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> com1 = &#123; <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h1&gt;我是com1组件&lt;/h1&gt;&quot;</span> &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> com2 = &#123; <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h1&gt;我是com2组件&lt;/h1&gt;&quot;</span> &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">flag</span>: <span class="hljs-literal">true</span> &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-string">&quot;com1&quot;</span>: com1,</span><br><span class="language-javascript">      <span class="hljs-string">&quot;com2&quot;</span>: com2</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="组件中的-data">组件中的 data</h3><p>在组件中同样拥有 data ，只不过和 vue 中的 data 不同，组件中的 data 必须是个函数，且必须有返回值，返回值类型必须是key: value的 { } 对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">zhe</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">zhe</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">zhe</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">zhe</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">zhe</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">zhe</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">  Vue.component(&quot;zhe&quot;, &#123;</span></span><br><span class="language-xml"><span class="language-handlebars">   template: &quot;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">font</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">a</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;a++&#x27;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&quot;,</span></span><br><span class="language-xml"><span class="language-handlebars">   data: function()&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">    return &#123; a: 0 &#125;</span></span><br><span class="language-xml"><span class="language-handlebars">   &#125;</span></span><br><span class="language-xml"><span class="language-handlebars">  &#125;)</span></span><br><span class="language-xml"><span class="language-handlebars">  var v = new Vue(&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">   el: &quot;#app&quot;</span></span><br><span class="language-xml"><span class="language-handlebars">  &#125;)</span></span><br><span class="language-xml"><span class="language-handlebars"> </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>vue 中的 data 与组件中的 data 的区别</p><ul><li><p>vue 中的 data：当你重复使用该组件时，修改其中一个data 的值，其他使用这个变量的组件都会发生改变，类似 java 中的 static 公共变量</p></li><li><p>组件中的 data：当你重复使用该组件时，修改其中一个 data 的值，其他使用这个变量的组件都不会发生改变，每组件中都有自己的 data，互不影响</p></li></ul><h3 id="组件通信">组件通信</h3><h4 id="父传子-属性">父传子-属性</h4><p>在子组件中可以通过 props 定义变量名，然后通过标签的属性对子组件进行传值，属性名就是子组件 props 的值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">zhe</span> <span class="hljs-attr">:ha</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">zhe</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;zhe&quot;</span>, &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;ha&quot;</span>],</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;font&gt;接收到传来的值为: &#123;&#123;ha&#125;&#125;&lt;/font&gt;&quot;</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; </span><br><span class="language-javascript">            <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span></span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">             <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;哈哈哈哈&quot;</span></span><br><span class="language-javascript">         &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>当子组件内 data 中定义的值与 prop 接受的值得 key 重复的话，那么使用  会优先调用 prop 中的</li><li>当父组件中的值发生改变时，子组件同时也会受到影响，但是子组件内修改却不会影响父组件</li><li>在向子组件传值时只能使用单向绑定。</li></ul><p>子组件中修改接受到的值只对子组件有影响，而不会对父组件产生影响，如果想要实现父子同步的话，可以将传入的值封装为一个对象，调用对象内的值，这样父子就可以同步了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../static/js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>子组件修改prop值<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tmp1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      从父组件中获取到的值：&#123;&#123; msg.a &#125;&#125;<br>      <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>      修改父组件的值为：<br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg.a&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    父组件中的msg：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg.a&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> com = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;msg&quot;</span>],</span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;#tmp1&quot;</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">msg</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-string">&quot;com&quot;</span>: com</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="父传子-方法">父传子-方法</h4><p>父组件在向子组件传值的时候，需要通过属性，那么<font color="red">传递方法需要通过事件</font>，事件的名称自定义即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">com1</span> @<span class="hljs-attr">abc</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> com1 = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;button @click=&#x27;good()&#x27;&gt;点击触发父组件方法&lt;/button&gt;&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">good</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;abc&quot;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是父组件的方法&quot;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&quot;com1&quot;</span>: com1</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>@事件名 是自定义的，之后需要在子组件中的 $emit() 中使用事件的名字来获取引用</li><li>在事件内如果使用 func() 则是调用方法，但如果是 func 则是传递该方法的引用地址，通过这点来传递方法</li><li>获取父组件方法并不会使原方法有变化，该执行照样执行</li><li>在调用父组件的函数时如果需要参数，那么追加在 $emit() 的参数列表中</li></ul><h4 id="子传父-属性">子传父-属性</h4><p>子组件中的 data 传递给父组件，需要使用到父传子方法，在父组件中定义一个 data 属性和一个方法，将方法传递给子组件，但是子组件使用这个方法需要一个参数，将参数放入后就传给父组件了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   父亲的钱包余额：&#123;&#123;rmb&#125;&#125;元<br>   <span class="hljs-tag">&lt;<span class="hljs-name">com1</span> @<span class="hljs-attr">func</span>=<span class="hljs-string">&quot;getRmb&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> com1 = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;button @click=&#x27;toSuper()&#x27;&gt;给父亲100元钱&lt;/button&gt;&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">toSuper</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;func&quot;</span>, <span class="hljs-number">100</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">rmb</span>: <span class="hljs-number">0</span> &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">getRmb</span>(<span class="hljs-params"> rmb </span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-variable language_">this</span>.<span class="hljs-property">rmb</span> += rmb;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">components</span>: &#123; <span class="hljs-string">&quot;com1&quot;</span>: com1 &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="子传父-方法">子传父-方法</h4><p>子组件向父组件传方法，需要在子组件所在的标签中使用 <code>ref</code> 属性来为当前组件起个别名，然后使用 <code>$refs</code> 来调用子组件中的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">com1</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;com1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com1</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getAndroid()&quot;</span>&gt;</span>点击查看儿子手机<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> com1 = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2&gt;老爸，我在这&lt;/h2&gt;&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">android</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;小黄片儿&quot;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">rmb</span>: <span class="hljs-number">0</span></span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">getAndroid</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">com1</span>.<span class="hljs-title function_">android</span>();</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&quot;com1&quot;</span>: com1</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="组件传值注意事项">组件传值注意事项</h4><p>无论是传 data 数据还是传 methods 方法，都不是真正的传给了子组件，而是借助父组件的引用来实现调用</p><blockquote><p>例如：在父组件中修改 data 的值，对应的子组件也会被修改</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;good&quot;</span>&gt;</span><br>   修改父组件中的msg: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">zhe</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">zhe</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#good&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;  <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;哈哈哈哈&quot;</span>  &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">func1</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span> )  &#125;</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&quot;zhe&quot;</span>: &#123;</span><br><span class="language-javascript">     <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;div&gt;子组件中的msg：&#123;&#123;msg&#125;&#125;&lt;/div&gt;&quot;</span>,</span><br><span class="language-javascript">     <span class="hljs-attr">props</span>:[<span class="hljs-string">&quot;msg&quot;</span>]</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>例如：在子组件中调用父组件传来的方法，方法中调用父和子中同名的 data，被调用的一定是父中的 data</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;good&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">zhe</span> @<span class="hljs-attr">func1</span>=<span class="hljs-string">&quot;func1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">zhe</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#good&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;  <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;父组件中的msg&quot;</span>  &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">func1</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span> )  &#125;</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&quot;zhe&quot;</span>: &#123;</span><br><span class="language-javascript">     <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;button @click=&#x27;func1&#x27;&gt; 点击测试 &lt;/button&gt;&quot;</span>,</span><br><span class="language-javascript">     <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;  <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;子组件的msg&quot;</span>  &#125;</span><br><span class="language-javascript">     &#125;,</span><br><span class="language-javascript">     <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">func1</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;func1&quot;</span>)  &#125;</span><br><span class="language-javascript">     &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Vue-全局-API">Vue 全局 API</h2><h3 id="mixins-混入">mixins 混入</h3><p>如果当前项目已经开发完毕，这时突然要求要新增一个功能，但是你已经不想在源代码的基础上在去乱改了，这是可以使用到混入的功能，<font color="red">混入，添加其他对象到当前 vue 实例中 ( 按照 vue 的规范书写 )</font></p><blockquote><p>mixins 混入是一个数组，可以混入多个对象，可以混入普通函数，也可以混入生命周期函数等等，</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add()&quot;</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mixins1 = &#123;<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">good</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;新增加的功能&quot;</span>);<br>        &#125;<br>    &#125;,<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;项目初始化！&quot;</span>)<br>    &#125;,<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了add方法&quot;</span>);<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">good</span>();<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">mixins</span>: [mixins1]<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>混入的生命周期函数和本身的生命周期函数相比优先级较高，但如果当前实例中已经存在了混入的同名方法，那么会默认调用本身的而不调用混入的</li></ul><h3 id="extends-扩展">extends 扩展</h3><p>extend 扩展，和混入几乎一模一样</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add()&quot;</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> extend1 = &#123;<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">good</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;新增加的功能&quot;</span>);<br>        &#125;<br>    &#125;,<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;项目初始化！&quot;</span>)<br>    &#125;,<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了add方法&quot;</span>);<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">good</span>();<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">extends</span>: extend1<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>混入的生命周期函数和本身的生命周期函数相比优先级较高，但如果当前实例中已经存在了混入的同名方法，那么会默认调用本身的而不调用混入的</li></ul><h3 id="修改差值表达式符号">修改差值表达式符号</h3><p>在 vue 中使用插值表达式 <code>&#123;&#123; &#125;&#125;</code> 可以直接输入实例中的 data 数据，但是当 vue 框架的差值表达式和其他框架的表达式发成冲突，这时可以使用 <code>delimiters</code> 修改插值表达式的使用规则</p><blockquote><p><code>delimiters</code> 是一个数组，需要两个参数做为头尾，使用 *[ 做为开始标记，] 做为结束标记</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span> *[msg] <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;测试数据&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">delimiters</span>: [<span class="hljs-string">&quot;*[&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>]<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="computed-计算属性">computed 计算属性</h3><p>计算属性，就像名字一样，可以和 data 中的数据一样作为属性直接调用，但是与 data 不同的是，计算属性向方法一样，可以将值提前计算好，在使用时直接调用计算好的值</p><p>methods完全可以代替 computed，但是 computed 和 methods 不同的是，computed 是依赖于缓存，只要缓存数据不变，那么就不工作</p><p>相比来说 computed 性能更高，但是如果想避免缓存问题还是要使用 methods</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;哈哈哈&quot;</span></span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">msgFunc</span>: &#123;</span><br><span class="language-javascript">     <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>;</span><br><span class="language-javascript">     &#125;,</span><br><span class="language-javascript">     <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"> value </span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = value;</span><br><span class="language-javascript">     &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;set前：&quot;</span> + v.<span class="hljs-property">message</span>);</span><br><span class="language-javascript">  <span class="hljs-comment">// 执行set方法</span></span><br><span class="language-javascript">  v.<span class="hljs-property">msgFunc</span> = <span class="hljs-string">&quot;嘿嘿嘿&quot;</span>;</span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;br /&gt;set后：&quot;</span> + v.<span class="hljs-property">message</span>);</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="watch-监听属性">watch 监听属性</h3><p>在 vue 中可以使用两种不同的方法监听</p><ol><li><p>vue 对象内的 watch 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">s</span>: <span class="hljs-number">0</span><br>    &#125;,<br>    <span class="hljs-attr">watch</span>: &#123;<br>        <span class="hljs-comment">// 通过watch进行监听</span><br>        <span class="hljs-attr">s</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"> value </span>)&#123;<br>            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;s 修改后的值为：&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>通过 vue 对象调用监听实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">s</span>: <span class="hljs-number">0</span><br>    &#125;<br>&#125;)<br><span class="hljs-comment">// 第一个参数是被监听的对象，第二个参数是回调函数，回调函数在监听到数据被修改的一瞬间执行</span><br><span class="hljs-comment">// 回调函数的第一个参数是修改后的值，第二个参数是修改前的值，变量名随便起</span><br>v.$watch(<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">end, begin</span>)&#123;<br>    <span class="hljs-title function_">alert</span>( begin + <span class="hljs-string">&quot;→&quot;</span> + end );<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><p>小练习：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"> <span class="hljs-selector-tag">input</span>&#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;&#125; </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   千米：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;km&quot;</span> /&gt;</span><br>   米：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;m&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">km</span>: <span class="hljs-number">0</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">m</span>: <span class="hljs-number">0</span></span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">   <span class="hljs-attr">watch</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 通过watch进行监听</span></span><br><span class="language-javascript">    <span class="hljs-attr">km</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"> value </span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-variable language_">this</span>.<span class="hljs-property">m</span> = value * <span class="hljs-number">1000</span>;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">m</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"> value </span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-variable language_">this</span>.<span class="hljs-property">km</span> = value / <span class="hljs-number">1000</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-comment">// 调用监听的实例方法，回调函数在监听到数据被修改的一瞬间执行</span></span><br><span class="language-javascript">  v.$watch(<span class="hljs-string">&quot;km&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">end, begin</span>)&#123;</span><br><span class="language-javascript">   <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;info&quot;</span>).<span class="hljs-property">innerText</span> = </span><br><span class="language-javascript">     <span class="hljs-string">&quot;千米从&quot;</span> + begin + <span class="hljs-string">&quot;变成了&quot;</span> + end;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Vue-动画">Vue 动画</h2><p>在 vue 中可以通过 v-if 或者 v-show 指令，来对元素进行显示和隐藏的效果，但是表现太过生硬，这里需要使用到vue 中的动画</p><h3 id="进场和离场过渡">进场和离场过渡</h3><p>在元素显示和隐藏的过程中添加一个透明度的过渡，针对进场和离场，Vue 提供了四个样式</p><table><thead><tr><th style="text-align:center">class样式</th><th style="text-align:center">对应时间点</th></tr></thead><tbody><tr><td style="text-align:center">.v-enter</td><td style="text-align:center">进场 首部时间点</td></tr><tr><td style="text-align:center">.v-enter-to</td><td style="text-align:center">进场 尾部时间点</td></tr><tr><td style="text-align:center">.v-leave</td><td style="text-align:center">离场 首部时间点</td></tr><tr><td style="text-align:center">.v-leave-to</td><td style="text-align:center">离场 尾部时间点</td></tr></tbody></table><p>进场的两个时间点之间的过程叫做 <code>v-enter-active</code>，离场的两个时间点的过程叫 <code>v-leave-active</code></p><p>通过四个样式对应的时间点，配合 css 的 transition 样式来完成进场和离场的过渡效果，<font color="red">被 vue 控制的动画必须要在 transition 标签内才有效果</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">   <span class="hljs-selector-class">.v-enter</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100px</span>);</span><br><span class="language-css">   &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.v-leave-to</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100px</span>);</span><br><span class="language-css">   &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.v-enter-active</span> &#123; <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.5s</span> ease; &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.v-leave-active</span> &#123; <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1.0s</span> ease; &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">center</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;flag=!flag&quot;</span>&gt;</span>显示/隐藏<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;flag&quot;</span>&gt;</span>哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#roor&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">flag</span>: <span class="hljs-literal">false</span> &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="区分多个动画">区分多个动画</h3><p>当我们定义多个标签进行进场和入场时，他们会共用同一个过渡动画，需要区分过渡动画</p><p>可以发现无论时进场的样式还是离场的样式都有一个 v- 作为前缀，v- 前缀是 vue 的默认全局样式，这里可以通过自定义的样式来区分不同的动画</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">   <span class="hljs-selector-class">.v-enter</span>, <span class="hljs-selector-class">.v-leave-to</span>&#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;  &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.v-enter-active</span>, <span class="hljs-selector-class">.v-leave-active</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.5s</span> ease;</span><br><span class="language-css">   &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.a-enter</span>, <span class="hljs-selector-class">.a-leave-to</span>&#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>; &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.a-enter-active</span>, <span class="hljs-selector-class">.a-leave-active</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1.0s</span> ease;</span><br><span class="language-css">   &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;flag1=!flag1&quot;</span>&gt;</span>显示/隐藏<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;flag1&quot;</span>&gt;</span>哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;flag2=!flag2&quot;</span>&gt;</span>显示/隐藏<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;flag2&quot;</span>&gt;</span>哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#roor&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">flag1</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">flag2</span>: <span class="hljs-literal">false</span></span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="red">使用不同的前缀，在 transition 标签中的 name 属性设置前缀，如不设置 name 则默认 -v</font></p><h3 id="切换效果">切换效果</h3><p>在使用 vue 动画设置进场和离场的过渡时融入组件的切换，实现 <font color="red">先离场，再进场</font> 的淡入淡出</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">   <span class="hljs-selector-class">.v-enter</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">40px</span>);</span><br><span class="language-css">   &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.v-leave-to</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">40px</span>);</span><br><span class="language-css">   &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.v-enter-active</span>, <span class="hljs-selector-class">.v-leave-active</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span> ease;</span><br><span class="language-css">   &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;flag=!flag&quot;</span>&gt;</span>切换组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;out-in&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;flag?&#x27;com1&#x27;:&#x27;com2&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">  var zhe1 = &#123; template: &quot;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&#x27;4&#x27;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&#x27;green&#x27;</span>&gt;</span>绿色-组件<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&quot; &#125;</span></span><br><span class="language-xml"><span class="language-handlebars">  var zhe2 = &#123; template: &quot;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&#x27;4&#x27;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&#x27;red&#x27;</span>&gt;</span>红色-组件<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&quot; &#125;</span></span><br><span class="language-xml"><span class="language-handlebars">  Vue.component(&quot;com1&quot;, zhe1)</span></span><br><span class="language-xml"><span class="language-handlebars">  Vue.component(&quot;com2&quot;, zhe2)</span></span><br><span class="language-xml"><span class="language-handlebars">  var v = new Vue(&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">      el: &quot;#app&quot;,</span></span><br><span class="language-xml"><span class="language-handlebars">   data: &#123; flag: true &#125;</span></span><br><span class="language-xml"><span class="language-handlebars">  &#125;)</span></span><br><span class="language-xml"><span class="language-handlebars"> </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="router-路由">router 路由</h2><p>vue 的路由需要引用他的 js 文件才可以使用，文件位置：<a href="https://unpkg.com/vue-router/dist/vue-router.min.js">https://unpkg.com/vue-router/dist/vue-router.min.js</a></p><h3 id="路由的引与使用">路由的引与使用</h3><p>vue-router 被称为前端路由，他负责在前端组件之间来回切换实现跳转的功能，使用前端路由后网页的地址栏会有 <code>#/</code> 的标识，这就代表这路由引用成功了，<font color="red">一定要优先引用 vue.js，然后在引用 vue-router 才可以正常使用</font></p><blockquote><p>模拟登陆和注册</p></blockquote><p>&lt;/img src=“.//img/vue-09.png” /&gt;</p><ul><li>当多个组件匹配了同一个 path 时，只有第一个匹配成功的生效，后面的将被覆盖</li></ul><h3 id="网页跳转实现">网页跳转实现</h3><p>上面就是一个简单的路由的实例，通过修改地址栏达到访问不同组件的跳转，下面将使用超链接实现跳转，因为时基于路由实现跳转，所以要在 /login 前面加上 # 代表访问的是路由</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/login&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/regis&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>针对链接跳转，vue-router 提供了专属的 router-link 标签：</p><ul><li>to: 属性代表跳转的目标地址，不需要携带 #</li><li>tag: 代表他在网页的表现形式，默认会被渲染为 a 标签</li><li>to，tag 属性都可以被 vue 进行绑定传值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/regis&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="设置首页-默认显示组件">设置首页-默认显示组件</h3><p>默认情况下当我们访问首页的时候应该是提示我们登陆，然后我们手动的切换登陆和注册，而不是访问首页时显示空白，这里可以设置默认显示的组件</p><blockquote><p>第一种方法：当访问根目录时也跳转到 login 组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">var router = new VueRouter(&#123;<br>    routes: [<br>        &#123; path: &quot;/&quot;, component: login &#125;,<br>        &#123; path: &quot;/login&quot;, component: login &#125;,<br>        &#123; path: &quot;/regis&quot;, component: regis &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>第二种方法：使用重定向的方法进行跳转</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>: [<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/login&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-attr">component</span>: login &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/regis&quot;</span>, <span class="hljs-attr">component</span>: regis &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="设置路由访问高亮">设置路由访问高亮</h3><p>当一个页面有多个路由跳转链接时，例如导航栏，这个时候希望被选择的链接有高亮显示：</p><p>我们可以通过控制台发现，当有多个超链接路由时，被选中的那个超链接会动态的绑定一个class属性：</p><p>&lt;/img src=“.//img/vue-10.png” /&gt;</p><blockquote><p>可以利用这一特点来对被点击的链接进行修饰：↓ ↓ ↓</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue-router.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">   <span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">text-decoration</span>: none;  &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.router-link-active</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">   &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list1&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list2&quot;</span>&gt;</span>账户<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list3&quot;</span>&gt;</span>个人信息<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list4&quot;</span>&gt;</span>关于我们<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> list1 = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h1&gt;这个是首页的组件&lt;/h1&gt;&quot;</span>  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> list2 = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h1&gt;这个是账户的组件&lt;/h1&gt;&quot;</span>  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> list3 = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h1&gt;这个是个人信息的组件&lt;/h1&gt;&quot;</span>  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> list4 = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h1&gt;这个是关于我们的组件&lt;/h1&gt;&quot;</span>  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">routes</span>: [</span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/list1&quot;</span> &#125;, <span class="hljs-comment">// 默认是首页</span></span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list1&quot;</span>, <span class="hljs-attr">component</span>: list1 &#125;,</span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list2&quot;</span>, <span class="hljs-attr">component</span>: list2 &#125;,</span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list3&quot;</span>, <span class="hljs-attr">component</span>: list3 &#125;,</span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list4&quot;</span>, <span class="hljs-attr">component</span>: list4 &#125;</span><br><span class="language-javascript">   ]</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#roor&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">router</span>: router</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的 <code>router-link-active</code> 是 vue-router 提供的样式名称，我们在创建对象的时候修改他的默认 class 名称</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>: [<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/list1&quot;</span> &#125;, <span class="hljs-comment">// 默认是首页</span><br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list1&quot;</span>, <span class="hljs-attr">component</span>: list1 &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list2&quot;</span>, <span class="hljs-attr">component</span>: list2 &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list3&quot;</span>, <span class="hljs-attr">component</span>: list3 &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list4&quot;</span>, <span class="hljs-attr">component</span>: list4 &#125;<br>    ],<br> <span class="hljs-comment">// 创建对象的时候修改他的默认 class 名称，这里可以配合Bootstrap使用</span><br>    <span class="hljs-attr">linkActiveClass</span>: <span class="hljs-string">&quot;zhe-active&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="组件切换动画效果">组件切换动画效果</h3><p>结合 vue 四个时间段的动画和组件切换的知识点，实现组件切换淡入淡出的效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue-router.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">   <span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">text-decoration</span>: none;  &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.router-link-active</span>, <span class="hljs-selector-class">.zhe-active</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">   &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.v-enter</span>, <span class="hljs-selector-class">.v-leave-to</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100px</span>);</span><br><span class="language-css">   &#125;</span><br><span class="language-css">   <span class="hljs-selector-class">.v-enter-active</span>, <span class="hljs-selector-class">.v-leave-active</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.5s</span> ease, transform <span class="hljs-number">0.5s</span> ease;</span><br><span class="language-css">   &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list1&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list2&quot;</span>&gt;</span>账户<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;out-in&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> list1 = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h1&gt;这个是首页的组件&lt;/h1&gt;&quot;</span>  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> list2 = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h1&gt;这个是账户的组件&lt;/h1&gt;&quot;</span>  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">routes</span>: [</span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/list1&quot;</span> &#125;, <span class="hljs-comment">// 默认是首页</span></span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list1&quot;</span>, <span class="hljs-attr">component</span>: list1 &#125;,</span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list2&quot;</span>, <span class="hljs-attr">component</span>: list2 &#125;</span><br><span class="language-javascript">   ],</span><br><span class="language-javascript">   <span class="hljs-attr">linkActiveClass</span>: <span class="hljs-string">&quot;zhe-active&quot;</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#roor&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">router</span>: router</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="route-路由传参">$route 路由传参</h3><p>$router 是 VueRouter 的一个对象，在跳转至一个组件的时候如果携带了一些参数，可以通过他获取到传递的参数，获取传递参数有两种方法</p><h4 id="通过-query-获取参数">通过 query 获取参数</h4><p>$router 对象中的 query 属性可以接受这种拼接字符串的传参</p><blockquote><p>当前请求 #/login?user=admin 时</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue-router.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login?user=哈哈&quot;</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> login = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;div&gt;登陆成功！&#123;&#123;$route.query.user&#125;&#125;&lt;/div&gt;&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>)</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">routes</span>: [</span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-attr">component</span>:login &#125;</span><br><span class="language-javascript">   ]</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#roor&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">router</span>: router</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&lt;/img src=“.//img/vue-12.png” /&gt;</p><h4 id="通过-params-属性获取">通过 params 属性获取</h4><p>使用 query 可以获取到以 ? &amp; 拼接字符串形式的参数，除开这种方式还可以使用 params 属性获取，使用 params 获取的参数需要以 :占位符 的形式来进行传参</p><blockquote><p>当访问 #/login/:id/:name 时</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue-router.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login/001/张涵哲&quot;</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> login = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;div&gt;登陆成功！&#123;&#123;$route.params.id&#125;&#125;--&#123;&#123;$route.params.name&#125;&#125;&lt;/div&gt;&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>)</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">routes</span>: [</span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/login/:id/:name&quot;</span>, <span class="hljs-attr">component</span>:login &#125;</span><br><span class="language-javascript">   ]</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#roor&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">router</span>: router</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="路由嵌套">路由嵌套</h3><p>一般在项目中，不会只使用一层路由，往往会有好几层路由嵌套使用，例如 <code>首页</code> 是一个组件，，然后首页中又有 <code>登陆</code> 和 <code>注册</code> 两个组件，这时的 <code>登陆</code> 和 <code>注册</code>就是首页的 <font color='red'>子路由</font></p><p>实现 <strong>子路由</strong> 需要在实例化路由对象中使用 <strong>children</strong> 实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue-router.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>这里是首页，有登陆和注册两个功能<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/index/login&quot;</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/index/regis&quot;</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roor&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/index&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> index = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;#index&quot;</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> login = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;font color=&#x27;red&#x27;&gt;登陆的组件&lt;/font&gt;&quot;</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> regis = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;font color=&#x27;red&#x27;&gt;注册的组件&lt;/font&gt;&quot;</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">routes</span>: [</span><br><span class="language-javascript">    &#123; </span><br><span class="language-javascript">     <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/index&quot;</span>, <span class="hljs-attr">component</span>: index,</span><br><span class="language-javascript">     <span class="hljs-attr">children</span>: [</span><br><span class="language-javascript">      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;login&quot;</span>, <span class="hljs-attr">component</span>:login &#125;,</span><br><span class="language-javascript">      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;regis&quot;</span>, <span class="hljs-attr">component</span>:regis &#125;</span><br><span class="language-javascript">     ]</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   ]</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#roor&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">router</span>: router</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在使用路由嵌套时需要注意：</p><ul><li>children 中的子路由的中的 path 不能以 / 开头，以 / 开头默认匹配的根目录</li></ul><h3 id="视图命名">视图命名</h3><p>在 vue 的路由中，可以定义一个组件显示在某一个页面上，如果两个组件匹配了同一个路径，同时当前路径中有两个 router-view，那么处理方法就是：</p><ol><li>将相同路径的组件放在 components 中，为每个组件命名</li><li>通过视图中的 name  属性来区分显示的组件</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue-router.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 如果不指定name，那么默认显示default --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> com1 = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2 style=&#x27;color: red&#x27;&gt;组件 1&lt;h2&gt;&quot;</span>  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> com2 = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2 style=&#x27;color: red&#x27;&gt;组件 2&lt;h2&gt;&quot;</span>  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">routes</span>: [</span><br><span class="language-javascript">    &#123; </span><br><span class="language-javascript">     <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">                        <span class="hljs-comment">// 左侧为组件命名，在右侧指定目标组件，default表示默认值</span></span><br><span class="language-javascript">      <span class="hljs-string">&quot;default&quot;</span>: com1,</span><br><span class="language-javascript">      <span class="hljs-string">&quot;/&quot;</span>: com2</span><br><span class="language-javascript">     &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   ]</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#root&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">router</span>: router</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="编程式导航">编程式导航</h3><p>一般在一个项目中，不可能完全依靠 <code>&lt;router-link /&gt;</code> 标签进行路由跳转的，当逻辑代码执行完成后可能会有一个跳转功能，例如登陆成功后会跳转到网站首页，这个时候就需要用到编程式导航了</p><p>编程式导航有三个操作点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 类似于浏览器中的 上一页</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 类似于浏览器中的 下一页</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">go</span>(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 将页面跳转到指定导航页面</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="监听路由地址变化">监听路由地址变化</h3><p>监听器最强大的地方不是监听 data 数据，而是 vue 中任何数据都可以被他监听，例如路由中的地址</p><blockquote><p>$route 中的 path 属性对应的就是请求地址</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue-router.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/regis&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> login = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2&gt;这个是登陆的组件&lt;/h2&gt;&quot;</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> regis = &#123;</span><br><span class="language-javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2&gt;这个是注册的组件&lt;/h2&gt;&quot;</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">routes</span>: [</span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-attr">component</span>: login &#125;,</span><br><span class="language-javascript">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/regis&quot;</span>, <span class="hljs-attr">component</span>: regis &#125;</span><br><span class="language-javascript">   ]</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#root&quot;</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">router</span>: router,</span><br><span class="language-javascript">   <span class="hljs-attr">watch</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&quot;$route.path&quot;</span>( newVal, oldVal )&#123;</span><br><span class="language-javascript">     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( oldVal + <span class="hljs-string">&quot; → &quot;</span> + newVal )</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   &#125;,</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在监听 path 属性的时候，由于有一个点 <strong>.</strong> 为特殊符号，所以要用引号将其引起来规避语法错误</li></ul><h2 id="vue-异步请求">vue 异步请求</h2><p>异步请求又叫 Ajax，是指在不刷新网页的前提下向后台发送请求并获取到响应数据，以此来加强用户体验</p><h3 id="resource-请求">resource 请求</h3><p>vue-resource 的互联网地址如下，可以下载至本地引用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://cdn.staticfile.org/vue-resource/<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span>/vue-resource.min.js<br></code></pre></td></tr></table></figure><p>发起 get 请求的步骤，携带参数直接在 url 后面跟上 ?key=value&amp;key=value 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;URL&#x27;</span>).<span class="hljs-title function_">then</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)<br></code></pre></td></tr></table></figure><p>发起 post 请求的步骤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span>.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;URL&#x27;</span>, &#123;<span class="hljs-string">&#x27;key&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;key&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>&#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">body</span>)<br> &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="Vue-Cli-2-x-脚手架">Vue-Cli 2.x 脚手架</h2><h3 id="安装-vue-cli"><strong>安装 vue-cli</strong></h3><p>在控制台全局安装 vue-cli，这里需要说一点关于安装 vue 时的版本问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用下面这段代码安装 vue-cli 的版本最高不会超过 3</span><br>npm install vue-cli -g<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果想要使用 3 以上的版本请按照下面这段代码进行安装</span><br>npm install @vue/cli -g<br></code></pre></td></tr></table></figure><p>安装成功后可以使用 <code>vue -V</code> 来查询版本号信息， -V 的 V 一定要是大写字母</p><h3 id="项目创建流程">项目创建流程</h3><p>创建项目目录，使用 cmd 打开当前目录，输入 <font color="red">vue init webpack 项目名</font> 开始创建</p><blockquote><p>上述指令中项目名可以省略不写，默认以当前所在的文件夹的名称作为项目名</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">是否在在当前目录中生成项目？</span><br>? Generate project in current directory? (Y/n)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">项目名称，最好不要有大写字母，不然会报错</span><br>? Project name (vuecli1)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">项目描述</span><br>? Project description (A Vue.js project)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">作者</span><br>? Author<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个选择第一个默认，显示standalone即可</span><br>? Vue build <br><span class="hljs-meta prompt_"># </span><span class="language-bash">是否安装vue路由，否</span><br>? Install vue-router? (Y/n)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">是否使用ESLint对代码进行lint  否</span><br>? Use ESLint to lint your code? (Y/n)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">是否设置单元测试  否</span><br>? Set up unit tests (Y/n)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">是否安装e2e  否</span><br>? Setup e2e tests with Nightwatch?<br><span class="hljs-meta prompt_"># </span><span class="language-bash">是否为您运行<span class="hljs-string">&quot;npm install&quot;</span>命令安装依赖 是</span><br>Should we run `npm install` for you after the project has been created?<br></code></pre></td></tr></table></figure><blockquote><p>创建完成后运行项目：npm run dev，编译运行后便可以在 localhost:8080 访问当前项目了</p></blockquote><h3 id="项目配置修改">项目配置修改</h3><ul><li><p>修改项目运行端口号：</p><p>在当前项目下的 config 目录下的 index.js 文件中，找到 port 修改为指定的端口号</p></li></ul><h3 id="使用路由组件">使用路由组件</h3><p>在创建项目的时候，是否使用路由的选项选择是，这样 vue 就会自动将路由安装并配置完成了，如果没有选择安装，也可以手动安装，在当前项目目录下，控制台输入以下命令，就可以安装路由</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install vue-router --save<br></code></pre></td></tr></table></figure><p>在路由安装完成之后，新建一个 js 文件作为路由的配置文件，暂且命名为 router.js，在里面进行环境搭建</p><blockquote><p>需要使用 import 引用 vue 和 vue-router 组件并使用才是路由配置文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><span class="hljs-keyword">import</span> hello <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/hello&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>: [<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-attr">component</span>: hello &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>将文件配置完成之后在 main.js 中将路由配置进来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./coms/router&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-string">&quot;app&quot;</span>: <span class="hljs-title class_">App</span><br>  &#125;,<br>  <span class="hljs-attr">router</span>: router,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;app&gt;&lt;/app&gt;&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>然后在页面默认显示的位置添加上 <code>&lt;router-view /&gt;</code> 标签即可</p><h3 id="Axios-请求">Axios 请求</h3><p>resource 在 vue 2.0 之后就停止更新和维护了，所以才有了 Axios，它的互联网地址如下，可以下载本地引用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">https://unpkg.com/axios@0.19.2/dist/axios.min.js<br></code></pre></td></tr></table></figure><p>使用 axiox 调用 get 或 post 方法发起相应的请求，其中：</p><ul><li>.then 是回调函数，result 是请求后的相应数据，在函数体内对数据进行操作</li><li>.catch 是异常函数，当请求发生异常的时候回调用该函数进行善后工作</li></ul><p>GET 请求操作：</p><blockquote><p>get 请求传输参数的时候直接在 url 后面跟上 ?key=value&amp;key=value 即可</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;URL&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出錯了，，，&quot;</span>)<br> &#125;<br>)<br></code></pre></td></tr></table></figure><p>POST 请求操作：</p><blockquote><p>post 请求携带参数需要在参数列表传入一个 json，通过 json 携带参数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;URL&#x27;</span>, &#123;<span class="hljs-string">&#x27;key&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>&#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"> result </span>) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br> &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"> error </span>) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br> &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="vue-扩展程序">vue 扩展程序</h2><p>百度下载谷歌扩展程序 <code>vue-devtools</code>下载，然后将扩展名改成 <code>.zip</code> 的压缩文件并将其解压，得到文件：</p><p>&lt;/img src=“.//img/vue-05.png” /&gt;</p><p>将文件放在一个不会被改变的位置，然后打开 Google 浏览器右上角的设置，更多工具，扩展程序</p><p>&lt;/img src=“.//img/vue-06.png” /&gt;</p><p>紧接着点击开启扩展程序页面右上角的 <code>开发者模式</code> ，然后多出来三个选项，点击 <code>加载已解压的扩展程序</code>，找到之前存放扩展程序的位置即可添加成功</p><p><font color="red">想使用vue增强工具需要编辑vue.js文件，将其中的 <code>devtools: !1</code> 中的 ！删除，否则工具可能会失效</font></p><p>&lt;/img src=“.//img/vue-07.png” /&gt;</p><p>vue-devtools 的正常工作截图 <strong>↓</strong></p><p>&lt;/img src=“.//img/vue-08.png” /&gt;</p><h3 id="vuex状态管理">vuex状态管理</h3><p>一般我们在写登陆页面的时候，登陆成功会将相关全局信息放在 session 中进行保管，vuex 就是相当于 session 的一个技术，用来存放全局的变量</p><h4 id="vuex-简单实例">vuex 简单实例</h4><ol><li>安装 vuex 状态管理：在当前项目目录下使用一下命令进行安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install vuex --save<br></code></pre></td></tr></table></figure><ol start="2"><li>在安装完成之后，在项目中创建 vuex 的 js 文件并配置：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>: &#123;<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;vuex中的数据&quot;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>不要忘记将文件引入到 main.js 中</p></blockquote><ol start="3"><li>在组件中使用 vuex 中定义的数据</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 不需要再组件中进行多余操作，直接通过$store引用就可以 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;$store.state.msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="state-状态对象">state 状态对象</h4><p>在 store.js 中定义全局变量的时候可以发现，变量都是定义在 state 中的，state 是状态对象，所有变量都会放在state 中进行存放</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>: &#123;<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;vuex中的数据&quot;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>将 store.js 引用到 mainj.js 后，vuex 就可以全局使用了，获取 vuex 中数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在页面中获取数据</span><br>&#123;&#123;$store.<span class="hljs-property">state</span>.<span class="hljs-property">msg</span>&#125;&#125;<br><span class="hljs-comment">// 在组件中获取数据</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">msg</span><br></code></pre></td></tr></table></figure><p>通过 <code>store.state.name</code> 可以获取到 state 中存放的数据，但是这样一来前缀有点太多了，我们可以利用计算属性将 state 来存储起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">computed</span>: &#123;<br>        <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样以后想要调用 vuex 中的 msg 就直接使用 <code>state.msg</code> 就可以了</p><h4 id="mutations-修改状态">mutations 修改状态</h4><p>在 state 中可以存放变量，那么针对变量进行修改也一定是可以的，vuex 中除了有 state 之外还有 mutations，他用来存储公共的函数，可以利用函数来对 state 中的数据进行修改</p><p>在 mutations 中定义方法，将 state 作为参数穿进去，通过 state 来对变量进行修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>: &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">10</span><br>    &#125;,<br>    <span class="hljs-attr">mutations</span>: &#123;<br>        <span class="hljs-title function_">setCount</span>(<span class="hljs-params"> state </span>)&#123;<br>            state.<span class="hljs-property">count</span> ++;<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>方法定义完成之后需要在页面中引用，在组件中创建一个按钮，创建事件调用该方法</p><blockquote><p>$store 中的 commit 代表要调用方法，然后将想要调用的方法的名称作为参数传过去即可</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        &#123;&#123;state.msg&#125;&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$store.commit(&#x27;setCount&#x27;)&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果在定义方法的时候需要接受参数，例如 <code>setCount( state, number )</code>，参数需要跟在方法名的后面</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        &#123;&#123;state.msg&#125;&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$store.commit(&#x27;setCount&#x27;, 123)&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="axios-异步请求">axios 异步请求</h3><p>在脚手架中使用 axios 异步请求，首先要在当前项目下安装请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install axios --save<br></code></pre></td></tr></table></figure><p>然后在项目中加以使用，注意在使用的时候有一个小技巧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在 mian.js 中</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-comment">// 挂在到vue实例原型</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">axios</span> = axios<br></code></pre></td></tr></table></figure><p>当把 axios 挂载到实例原型后，就可以在实例中直接使用 <code>this.axios</code> 进行调用使用了</p><p><font color="red"><strong># 注意！</strong></font>在 vue-cli 开发过程中，不可避免的会产生跨域请求，但是跨域请求在 post 请求携带参数时会出问题，这时候需要额外添加一个依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install qs --save<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> qs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qs&#x27;</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$qs</span> = qs;<br></code></pre></td></tr></table></figure><p>然后在传入参数时使用 qs 对参数进行解析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">axios</span>.<span class="hljs-title function_">post</span>( (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">server_url</span>+<span class="hljs-string">&quot;user/login&quot;</span>),<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$qs</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>  <span class="hljs-string">&#x27;userId&#x27;</span>: this_.<span class="hljs-property">login</span>.<span class="hljs-property">username</span>,<br>  <span class="hljs-string">&#x27;userPwd&#x27;</span>: this_.<span class="hljs-property">login</span>.<span class="hljs-property">password</span><br> &#125;)<br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 笔记</title>
    <link href="/2022/10/19/Redis%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/19/Redis%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>Redis 笔记</h1><p>redis 是一款 NoSQL 数据库，是最常见的一款非关系型数据库，主要使用 key - value 的形式存储数据，和 mysql 不同，redis 并不会直接把数据存储到硬盘中，而是存储在内存中，也正是这样的设定让 redis 的存取操作特别的快。</p><h2 id="Redis-的下载及安装">Redis 的下载及安装</h2><blockquote><p>redis 的下载</p></blockquote><p>首先要去 redis 的官网下载他的压缩包，官网 [ 中文 ] 直连地址如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.redis.cn/</span><br></code></pre></td></tr></table></figure><p>进入官网后直接下载即可，然后远程连接 服务器/虚拟机 将下载好的文件上传至 <code>/usr/local</code> 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入到usr/local目录</span><br>cd /usr/local<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上传文件后，执行解压命令</span><br>tar -zxvf redis-5.0.5.tar.gz<br></code></pre></td></tr></table></figure><blockquote><p>redis 的安装</p></blockquote><p>在执行安装命令之前，首选需要安装 gcc 的依赖，如已安装请忽略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install gcc<br></code></pre></td></tr></table></figure><p>然后切换到 redis 目录下开始执行安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">切换目录到redis下</span><br>cd redis-5.0.5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行安装命令</span><br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>这样一来，安装就顺利结束了，如果提示 -bash: make: command not found 则代表 gcc 没有装，需要重新安装 gcc 环境</p><blockquote><p>redis 的配置</p></blockquote><p>实际上这个时候 redis 已经可以正常运行了，运行 redis 的命令为 <code>redis-server</code>，但是当我们运行的时候会发现，redis 直接将窗口锁定了，我们不能进行任何的操作，一旦解锁也就意味着 redis 停止工作了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">19196:C 15 Jun 2020 22:13:31.574 <span class="hljs-comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br>19196:C 15 Jun 2020 22:13:31.574 <span class="hljs-comment"># Redis version=5.0.8, bits=64, commit=0000</span><br>0000, modified=0, pid=19196, just started<br>19196:C 15 Jun 2020 22:13:31.574 <span class="hljs-comment"># Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span><br>                _._                                                  <br>           _.-``__ <span class="hljs-string">&#x27;&#x27;</span>-._                                             <br>      _.-``    `.  `_.  <span class="hljs-string">&#x27;&#x27;</span>-._           Redis 5.0.8 (00000000/0) 64 bit<br>  .-`` .-```.  ```\/    _.,_ <span class="hljs-string">&#x27;&#x27;</span>-._                                   <br> (    <span class="hljs-string">&#x27;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="hljs-string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="hljs-string">&#x27;|     Port: 6379</span><br><span class="hljs-string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 19196<br>  `-._    `-._  `-./  _.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br> |`-._`-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>_.-<span class="hljs-string">&#x27;|                                  </span><br><span class="hljs-string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="hljs-string">&#x27;    |           http://redis.io        </span><br><span class="hljs-string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br> |`-._`-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>_.-<span class="hljs-string">&#x27;|                                  </span><br><span class="hljs-string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="hljs-string">&#x27;    |                                  </span><br><span class="hljs-string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br>      `-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                       <br>          `-._        _.-<span class="hljs-string">&#x27;                                           </span><br><span class="hljs-string">              `-.__.-&#x27;</span>                                               <br><br>19196:M 15 Jun 2020 22:13:31.575 <span class="hljs-comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br>19196:M 15 Jun 2020 22:13:31.575 <span class="hljs-comment"># Server initialized</span><br>..................<br></code></pre></td></tr></table></figure><p>这时我们需要对配置文件做一些手脚</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 建议弄个备份，玩儿备份就好，redis 的配置文件还是很重要的</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制配置文件</span><br>cp redis.conf /root/redis.conf<br>cd /root<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑配置文件信息</span><br>vim redis.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改为daemonize为<span class="hljs-built_in">yes</span>，可以后台运行 redis，否则会锁定命令行</span><br>daemonize yes<br></code></pre></td></tr></table></figure><blockquote><p>运行 redis 并创建连接</p></blockquote><p>首先我们来运行服务端 <code>redis-sever</code>，需要注意的是这里要指定配置文件进行启动，否则还是会以默认配置执行，还是会锁定当前窗口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 默认执行，会锁定窗口</span><br>redis-server<br><span class="hljs-comment"># 指定配置文件执行，咱们配置了后台运行，不会锁定窗口</span><br>redis-server redis.conf<br><span class="hljs-comment">## 出现下面这堆东西就代表执行成功了 ##</span><br>19203:C 15 Jun 2020 22:15:09.851 <span class="hljs-comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br>19203:C 15 Jun 2020 22:15:09.851 <span class="hljs-comment"># Redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=19203, just started</span><br>19203:C 15 Jun 2020 22:15:09.851 <span class="hljs-comment"># Configuration loaded</span><br></code></pre></td></tr></table></figure><p>接下来让我们启动客户端 <code>redis-cli</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果直接输入则默认连接本地的6379端口</span><br>redis-cli<br>127.0.0.1:6379&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以通过参数来指定目标IP地址或端口号</span><br>redis-cli -h 127.0.0.1 -p 6379<br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure><p>尝试输入一个 ping 命令，测试服务是否正常工作，如果返回 PONG 就证明一切正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; PING<br>PONG<br></code></pre></td></tr></table></figure><blockquote><p>关闭 redis</p></blockquote><p>如果不时用任何配置让他默认启动的话，直接 Ctrl + C 就可以关闭 redis，那么后台运行应该怎么关？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 连接到指定的服务后，执行关闭命令即可</span><br>127.0.0.1:6379&gt; shutdown<br><span class="hljs-comment"># 也可以在不连接的情况下直接通过redis-cli执行关闭命令</span><br>redis-cli shutdown<br></code></pre></td></tr></table></figure><h2 id="设置访问密码">设置访问密码</h2><p>我们刚刚成功连接到了 redis 服务器，但是这仅仅是本地的，我们目前并不能够远程 ip 地址直接访问，因为我们的 redis 默认开启了保护模式，将来我们的项目是要跑在网络上要用 java 代码操作的，想要远程连接必须要先设置密码！</p><blockquote><p>临时设置密码</p></blockquote><p>为了可以远程操作，我们可以设置一个临时的密码，连接上 redis 客户端，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置密码</span><br>127.0.0.1:6379&gt; config <span class="hljs-built_in">set</span> requirepass 123456<br>OK<br><span class="hljs-comment"># 设置密码是实时的，需要登录才可以进行操作</span><br>127.0.0.1:6379&gt; keys *<br>(error) NOAUTH Authentication required.<br><span class="hljs-comment"># 验证redis密码</span><br>127.0.0.1:6379&gt; auth 123456<br>OK<br><span class="hljs-comment"># 获取密码</span><br>127.0.0.1:6379&gt; config get requirepass<br>1) <span class="hljs-string">&quot;requirepass&quot;</span><br>2) <span class="hljs-string">&quot;zhang&quot;</span><br><span class="hljs-comment"># 取消之前设置的密码，留空即可</span><br>127.0.0.1:6379&gt; config <span class="hljs-built_in">set</span> requirepass <span class="hljs-string">&#x27;&#x27;</span><br>OK<br></code></pre></td></tr></table></figure><p>这样一个临时的密码就设置成功了，只要 redis 始终保持正常运行，秘密是不会失效的</p><blockquote><p>设置永久性密码</p></blockquote><p>如果觉得临时密码并不能够满足你的安全感，那么可以通过修改配置文件来设置密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在redis.conf中找到requirepass然后在后面追加密码，重启redis即可</span><br>requirepass 你的密码<br></code></pre></td></tr></table></figure><h2 id="配置文件讲解">配置文件讲解</h2><p>学习 redis 最好是跟着官方文档走，记笔记只是为了让自己更加熟练，推荐 redis 中文网：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.redis.net.cn<span class="hljs-regexp">/order/</span><br></code></pre></td></tr></table></figure><p>刚刚在安装 redis 的时候简单修改了一下 daemonize 属性的值，让他可以不锁定当前命令行且后台运行，redis 有很多需要了解的常规性配置，这里大概记个笔记：</p><p>redis 的配置文件中注释非常多，官方很友好的将模块划分开来，这里就记几个我个人觉得常用的配置</p><blockquote><p>######################## NETWORK ######################## 网络</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#### 绑定客户端IP</span><br><span class="hljs-comment"># 如果需要远程连接redis的话，要么在这里添加你的IP地址，要么将这句话注释掉</span><br><span class="hljs-comment"># 注释掉之后，所有的IP就都可以访问了</span><br><span class="hljs-built_in">bind</span> 127.0.0.1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#### 保护模式</span><br><span class="hljs-comment"># redis没有设置访问密码的情况下，如果开启了保护模式就不能远程连接了</span><br>protected-mode <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#### 启动端口号，不多赘述</span><br>port 6379<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#### 客户端超时时间/s</span><br><span class="hljs-comment"># 当客户端连接服务端的时候，超出 n 秒没有任何操作就自动切断连接</span><br><span class="hljs-comment"># 设置为 0 代表无超时时间</span><br><span class="hljs-built_in">timeout</span> 0<br></code></pre></td></tr></table></figure><blockquote><p>######################## GENERAL ######################## 常用</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#### 守护进程</span><br><span class="hljs-comment"># 这个就是之前设置的后台运行</span><br><span class="hljs-comment"># 守护进程就是Windows系统中的服务，将redis以服务的形式运行</span><br>daemonize <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#### PID文件</span><br><span class="hljs-comment"># 如果开启了守护进程后台运行redis，那么这个就一定要有</span><br>pidfile /var/run/redis_6379.pid<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#### 日志级别</span><br><span class="hljs-comment"># 记录执行日志时可选择的记录级别，选项分别有：</span><br><span class="hljs-comment"># debug，verbose，notice，warning，具体描述配置文件中有，一般不用设置这个</span><br>loglevel notice<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#### 日志文件名称</span><br>logfile <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#### 默认数据库个数</span><br><span class="hljs-comment"># 可以在这里手动对数据库数量进行设置，我就改成5个啦，闲的没事儿</span><br>databases 16<br></code></pre></td></tr></table></figure><blockquote><p>######################## SECURITY ######################## 安全</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#### 密码</span><br><span class="hljs-comment"># 安全中最常用的就是密码设置了，访问数据库必须要密码，不然就乱套了</span><br><span class="hljs-comment"># 默认是注释的，也就是没有密码</span><br>requirepass foobared<br></code></pre></td></tr></table></figure><h2 id="Redis-基础命令">Redis 基础命令</h2><p>redis 中也有库的概念，初始数量为 16 个，可以在配置文件中进行修改，他是按照从 0 开始的递增顺序命名的，和 mysql 不同，redis 不支持为某个数据库单独命名，也不支持为每个数据库设置单独的访问密码，默认我们启动 redis 时使用的是第 0 个数据库。</p><p>==切换数据库==应该怎么操作呢？只需要执行 select 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当我们使用select切换到其他数据库的时候，端口号后面会提示当前使用数据库 [1]，默认库就不会提示</span><br>127.0.0.1:6379&gt; <span class="hljs-keyword">select</span> 1<br>OK<br>127.0.0.1:6379[1]&gt;<br></code></pre></td></tr></table></figure><p>在我们学习 mysql 的时候，需要通过使用 sql 语句对数据进行 CRUD，而在 redis 我们需要记的是命令</p><blockquote><p>验证登录密码</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; auth 123456<br>OK<br></code></pre></td></tr></table></figure><blockquote><p>数据的简单 CRUD</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># set命令，因为key是唯一的，所以set既是添加，也是修改，如果有空格需要用双引号引起来</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> user zhang<br>OK<br><span class="hljs-comment"># get命令，就是查询喽</span><br>127.0.0.1:6379&gt; get user<br><span class="hljs-string">&quot;zhang&quot;</span><br><span class="hljs-comment"># del命令，就是删除喽</span><br>127.0.0.1:6379&gt; del user<br>(<span class="hljs-built_in">integer</span>) 1<br><span class="hljs-comment"># 删除之后查不到了</span><br>127.0.0.1:6379&gt; get user<br>(nil)<br></code></pre></td></tr></table></figure><blockquote><p>查看当前库数据总计数</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379[1]&gt; dbsize<br>(<span class="hljs-built_in">integer</span>) 4<br></code></pre></td></tr></table></figure><blockquote><p>查看当前库所有的 key，* 代表通配符</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379[1]&gt; keys *<br>1) <span class="hljs-string">&quot;user&quot;</span><br>2) <span class="hljs-string">&quot;sex&quot;</span><br>3) <span class="hljs-string">&quot;name&quot;</span><br>4) <span class="hljs-string">&quot;age&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>清空当前数据库</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379[1]&gt; flushdb<br>OK<br></code></pre></td></tr></table></figure><blockquote><p>清空所有数据库</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushall<br>OK<br></code></pre></td></tr></table></figure><blockquote><p>查看当前库是否存在该 key，只要不返回 0 就代表存在，exists 是否存在</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; exists name<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><blockquote><p>将当前库的数据移动到其他库 move 移动，name 为 key，1 为目标数据库</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; move name 1<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><blockquote><p>设置消亡时间 ( 过期时间 )，expire 单位/秒，ttl 查询</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置user</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> user zhanghanzhe<br>OK<br><span class="hljs-comment"># 设置user的消亡时间为10秒</span><br>127.0.0.1:6379&gt; expire user 10<br>(<span class="hljs-built_in">integer</span>) 1<br><span class="hljs-comment"># 一开始的时候还是可以获取的 </span><br>127.0.0.1:6379&gt; get user<br><span class="hljs-string">&quot;zhanghanzhe&quot;</span><br><span class="hljs-comment"># 查询过期时间，还剩3秒</span><br>127.0.0.1:6379&gt; tll user<br>(<span class="hljs-built_in">integer</span>) 3<br><span class="hljs-comment"># 这会变-2了</span><br>127.0.0.1:6379&gt; tll user<br>(<span class="hljs-built_in">integer</span>) -2<br><span class="hljs-comment"># 获取不到了</span><br>127.0.0.1:6379&gt; get user<br>(nil)<br></code></pre></td></tr></table></figure><blockquote><p>查看 key 的数据类型</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; type name<br>string<br></code></pre></td></tr></table></figure><h2 id="五大基本类型">五大基本类型</h2><p>在上面我们介绍了最后一个命令，是一个 <code>type</code> 命令，使用它可以查看指定 key 的数据类型，这里接触了一个新的知识，就是数据类型，redis 中有有多少数据类型呢？</p><h3 id="String-字符串">String 字符串</h3><p>string 就是字符串啦，我们使用简单的 set 命令设置的数据，如果没有指定，默认就是 string 类型的，就像 java 的 api 一样，string 类型有自己专属的命令</p><p><em>string 类型的命令大多是都是以 str 开头的</em></p><p>字符串操作就是之前学习的 get set 命令，就不多赘述了</p><blockquote><p>组合命令 返回并修改</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 组合命令，修改新的value同时返回修改前的value</span><br>getset name hanzhe<br></code></pre></td></tr></table></figure><blockquote><p>数据的批量操作</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; mset user zhang name hanzhe age 21<br>OK<br>127.0.0.1:6379&gt; mget user name age<br>1) <span class="hljs-string">&quot;zhang&quot;</span><br>2) <span class="hljs-string">&quot;hanzhe&quot;</span><br>3) <span class="hljs-string">&quot;21&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>带有验证的 setnx</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 同样是设置值，因为key是唯一的，所以他在设置之前会有一个效验，如果已存在就不修改</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name zhang<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; setnx name hanzhe<br>(<span class="hljs-built_in">integer</span>) 0<br><span class="hljs-comment"># 批量操作也是一样，因为原子性的原因，他们要么全都成功，要么全都失败。</span><br>127.0.0.1:6379&gt; msetnx view 123 name hanzhe<br>(<span class="hljs-built_in">integer</span>) 0<br></code></pre></td></tr></table></figure><blockquote><p>追加字符 append</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name zhang<br>OK<br>127.0.0.1:6379&gt; append name <span class="hljs-string">&quot; &quot;</span><br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; append name hanzhe<br>(<span class="hljs-built_in">integer</span>) 12<br>127.0.0.1:6379&gt; get name<br><span class="hljs-string">&quot;zhang hanzhe&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>返回字符串长度 strlen</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; strlen name<br>(<span class="hljs-built_in">integer</span>) 12<br></code></pre></td></tr></table></figure><blockquote><p>自增，自减 incr decr</p></blockquote><p>在 java 中，如果想要对字符串 +1 需要转换类型，而在 redis 中他们自动为我们进行了处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> view 1<br>OK<br><span class="hljs-comment"># 自增 +1</span><br>127.0.0.1:6379&gt; incr view<br>(<span class="hljs-built_in">integer</span>) 2<br><span class="hljs-comment"># 自减 -1</span><br>127.0.0.1:6379&gt; decr view<br>(<span class="hljs-built_in">integer</span>) 1<br><span class="hljs-comment"># 自增，指定步长为3</span><br>127.0.0.1:6379&gt; incrby view 3<br>(<span class="hljs-built_in">integer</span>) 4<br><span class="hljs-comment"># 自减，指定步长为2</span><br>127.0.0.1:6379&gt; decrby view 2<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><blockquote><p>截取字符串 getrange，==截取是将获取的结果进行截取，并不会对 key 本身造成改变==</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name zhanghanzhe<br>OK<br><span class="hljs-comment"># 从下标0开始，截取到4，共截取了5位，包头包尾，如果是0到-1则代表获取全部的字符串</span><br>127.0.0.1:6379&gt; getrange name 0 4<br><span class="hljs-string">&quot;zhang&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>替换字符串 setrange</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从下标5开始替换，直至替换结束，这个会对name进行修改。</span><br>127.0.0.1:6379&gt; setrange name 5 chunde<br>(<span class="hljs-built_in">integer</span>) 11<br>127.0.0.1:6379&gt; get name<br><span class="hljs-string">&quot;zhangchunde&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>设置消亡时间 ( 过期时间 ) setex 单位/秒</p></blockquote><p>之前我们使用过一个叫 <code>expire</code> 的命令，也是用来设置消亡时间的，但是他执行设置已存在的 key，而这个命令可以在设置变量的同时设置消亡时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; setex name 10 zhang<br>OK<br></code></pre></td></tr></table></figure><h3 id="List-列表集合">List 列表集合</h3><p>list 是用来存储 string 的一个列表, ==redis 的列表是双向的==，list 默认从右向左延伸，也就是每次添加元素都会添加在左面，==list 列表允许重复元素的出现==</p><p><em>list中的命令，大多数都是以小写字母 L 开头的</em></p><blockquote><p>创建-添加元素 lpush，rpush</p></blockquote><p>lpush 默认从左侧添加，如需从右侧添加可以使用 <code>r</code> 开头声明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lpush name han<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lpush name zhang<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; rpush name zhe<br>(<span class="hljs-built_in">integer</span>) 3<br></code></pre></td></tr></table></figure><blockquote><p>查看列表 lrange</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看之前创建的list，仅支持从左侧查看</span><br>127.0.0.1:6379&gt; lrange name 0 -1<br>1) <span class="hljs-string">&quot;zhang&quot;</span><br>2) <span class="hljs-string">&quot;han&quot;</span><br>3) <span class="hljs-string">&quot;zhe&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>添加，追加元素 2</p></blockquote><p>之前介绍了 <code>push</code> 命令可以添加元素，通过 l 开头或者 r 开头可以控制左侧添加还是右侧添加，其实添加元素还可以使用 <code>linsert</code> 命令，和 <code>push</code> 不同的是， <code>push</code> 是在首位添加，而 <code>linsert</code> 是从 <strong>左面开始在第一个目标 key 的前后添加</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lpush name han<br>(<span class="hljs-built_in">integer</span>) 1<br><span class="hljs-comment"># 在name中的han前面添加zhang</span><br>127.0.0.1:6379&gt; linsert name before han zhang<br>(<span class="hljs-built_in">integer</span>) 2<br><span class="hljs-comment"># 在name中的han后面添加zhe</span><br>127.0.0.1:6379&gt; linsert name after han zhe<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lrange name 0 -1<br>1) <span class="hljs-string">&quot;zhang&quot;</span><br>2) <span class="hljs-string">&quot;han&quot;</span><br>3) <span class="hljs-string">&quot;zhe&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>修改指定下标的 value</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lrange name 0 -1<br>1) <span class="hljs-string">&quot;zhe&quot;</span><br>2) <span class="hljs-string">&quot;han&quot;</span><br>3) <span class="hljs-string">&quot;zhe&quot;</span><br><span class="hljs-comment"># 修改下标0的值为zhang</span><br>127.0.0.1:6379&gt; lset name 0 zhang<br>OK<br>127.0.0.1:6379&gt; lrange name 0 -1<br>1) <span class="hljs-string">&quot;zhang&quot;</span><br>2) <span class="hljs-string">&quot;han&quot;</span><br>3) <span class="hljs-string">&quot;zhe&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>移除首尾 pop，移除多个 lrem</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移除左侧第一个，返回被移除的数据</span><br>127.0.0.1:6379&gt; lpop name<br><span class="hljs-string">&quot;zhang&quot;</span><br><span class="hljs-comment"># 移除右侧第一个，返回被移除的数据</span><br>127.0.0.1:6379&gt; rpop name<br><span class="hljs-string">&quot;zhe&quot;</span><br>127.0.0.1:6379&gt; lpush name one<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; rpush name one one<br>(<span class="hljs-built_in">integer</span>) 6<br><span class="hljs-comment"># 移除多个元素，仅支持从左侧移除，2数量，one为具体要移除的值，精确匹配，不支持通配符</span><br>127.0.0.1:6379&gt; lrem name 2 one<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><blockquote><p>返回长度 llen</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lpush name han zhang<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; rpush name zhe<br>(<span class="hljs-built_in">integer</span>) 3<br><span class="hljs-comment"># 获取集合长度</span><br>127.0.0.1:6379&gt; llen name<br>(<span class="hljs-built_in">integer</span>) 3<br></code></pre></td></tr></table></figure><blockquote><p>获取指定下标的value</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lrange name 0 -1<br>1) <span class="hljs-string">&quot;zhang&quot;</span><br>2) <span class="hljs-string">&quot;han&quot;</span><br>3) <span class="hljs-string">&quot;zhe&quot;</span><br>127.0.0.1:6379&gt; lindex name 0<br><span class="hljs-string">&quot;zhang&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>截取列表 ltrim</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;five&quot;</span><br>2) <span class="hljs-string">&quot;four&quot;</span><br>3) <span class="hljs-string">&quot;three&quot;</span><br>4) <span class="hljs-string">&quot;two&quot;</span><br>5) <span class="hljs-string">&quot;one&quot;</span><br><span class="hljs-comment"># 从下标1开始截取到2，会修改变量中的值</span><br>127.0.0.1:6379&gt; ltrim list 1 2<br>OK<br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;four&quot;</span><br>2) <span class="hljs-string">&quot;three&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>获取排序结果 sort，不会影响本体，<code>字母排序/alpha</code>，<code>倒序排序/desc</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lpush num 10 30 20 40<br>(<span class="hljs-built_in">integer</span>) 4<br><span class="hljs-comment"># 默认从小到大</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> num<br>1) <span class="hljs-string">&quot;10&quot;</span><br>2) <span class="hljs-string">&quot;20&quot;</span><br>3) <span class="hljs-string">&quot;30&quot;</span><br>4) <span class="hljs-string">&quot;40&quot;</span><br><span class="hljs-comment"># 可以从大到小</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> num desc<br>1) <span class="hljs-string">&quot;40&quot;</span><br>2) <span class="hljs-string">&quot;30&quot;</span><br>3) <span class="hljs-string">&quot;20&quot;</span><br>4) <span class="hljs-string">&quot;10&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 字母排序</span><br>127.0.0.1:6379&gt; lpush En python java switch<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> En alpha<br>1) <span class="hljs-string">&quot;java&quot;</span><br>2) <span class="hljs-string">&quot;python&quot;</span><br>3) <span class="hljs-string">&quot;switch&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>组合命令：移动元素</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lrange name 0 -1<br>1) <span class="hljs-string">&quot;han&quot;</span><br>2) <span class="hljs-string">&quot;zhe&quot;</span><br>3) <span class="hljs-string">&quot;zhang&quot;</span><br><span class="hljs-comment"># 移除目标元素并添加到目标位置</span><br>127.0.0.1:6379&gt; rpoplpush name name<br><span class="hljs-string">&quot;zhang&quot;</span><br>127.0.0.1:6379&gt; lrange name 0 -1<br>1) <span class="hljs-string">&quot;zhang&quot;</span><br>2) <span class="hljs-string">&quot;han&quot;</span><br>3) <span class="hljs-string">&quot;zhe&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Set-无序集合">Set 无序集合</h3><p>set 集合是 string 类型的 ==无序集合==，且==不允许存入重复数据==，如果重复存入相同的值会报错</p><p><em>还是老规矩，set 集合的命令特点，就是以 s 开头</em></p><blockquote><p>set 集合的 CRUD</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加 sadd</span><br>127.0.0.1:6379&gt; sadd code java<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd code python switch<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 smembers，这里就可以看出，set集合是无序的</span><br>127.0.0.1:6379&gt; smembers code<br>1) <span class="hljs-string">&quot;python&quot;</span><br>2) <span class="hljs-string">&quot;java&quot;</span><br>3) <span class="hljs-string">&quot;switch&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除元素</span><br>127.0.0.1:6379&gt; srem code switch<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><blockquote><p>查看目标 set 集合长度 scard</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; scard code<br>(<span class="hljs-built_in">integer</span>) 3<br></code></pre></td></tr></table></figure><blockquote><p>检查 set 集合中是否包含指定的值 sismember，存在返回 1，不存在返回 0</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; sismember code java<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><blockquote><p>随机性的获取和移除</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; sadd num 1 2 3 4 5 6 7 8 9<br>(<span class="hljs-built_in">integer</span>) 9<br><span class="hljs-comment"># 随机获取一个值</span><br>127.0.0.1:6379&gt; srandmember num 1<br>1) <span class="hljs-string">&quot;7&quot;</span><br>127.0.0.1:6379&gt; srandmember num 1<br>1) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-comment"># 随机移除一个值</span><br>127.0.0.1:6379&gt; spop num 1<br>1) <span class="hljs-string">&quot;2&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>获取多个集合中的 ==差集==，==交集==，==并集==</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 前置条件--拥有三个set集合</span><br>127.0.0.1:6379&gt; sadd key1 1 2 3 4<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; sadd key2 3 4 5 6<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; sadd key3 1 6 7 8<br>(<span class="hljs-built_in">integer</span>) 4<br></code></pre></td></tr></table></figure><p>差集 <code>sdiff</code>，取出两个集合中不同的元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以第一个key为主，依次与每个key取差集</span><br>127.0.0.1:6379&gt; sdiff key1 key2<br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; sdiff key1 key2 key3<br>1) <span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; sdiff key2 key1 key3<br>1) <span class="hljs-string">&quot;5&quot;</span><br></code></pre></td></tr></table></figure><p>交集 <code>sinter</code>，取出两个集合中相同的元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以第一个key为主，依次与每个key取交集</span><br>127.0.0.1:6379&gt; sinter key1 key2<br>1) <span class="hljs-string">&quot;3&quot;</span><br>2) <span class="hljs-string">&quot;4&quot;</span><br>127.0.0.1:6379&gt; sinter key1 key3<br>1) <span class="hljs-string">&quot;1&quot;</span><br>127.0.0.1:6379&gt; sinter key1 key2 key3<br>(empty list or <span class="hljs-built_in">set</span>)<br></code></pre></td></tr></table></figure><p>并集 <code>sunion</code>，取出两个集合中所有的元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以第一个key为主，依次与每个key取并集</span><br>127.0.0.1:6379&gt; sunion key1 key2<br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;3&quot;</span><br>4) <span class="hljs-string">&quot;4&quot;</span><br>5) <span class="hljs-string">&quot;5&quot;</span><br>6) <span class="hljs-string">&quot;6&quot;</span><br>127.0.0.1:6379&gt; sunion key1 key2 key3<br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;3&quot;</span><br>4) <span class="hljs-string">&quot;4&quot;</span><br>5) <span class="hljs-string">&quot;5&quot;</span><br>6) <span class="hljs-string">&quot;6&quot;</span><br>7) <span class="hljs-string">&quot;7&quot;</span><br>8) <span class="hljs-string">&quot;8&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Hash-散列集合">Hash 散列集合</h3><p>hash 类型就像 map，是由一个个的 key-value 组成的对象，而且 ==key 不能重复==，<strong>存入相同的 key 和 value 后，最后一个存入的会覆盖之前存入的结果</strong></p><p><em>老规矩，几乎所有 hash 的指令都以 h 开头</em></p><blockquote><p>添加，批量添加，hash 没有修改，覆盖就是修改</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hash">127.0.0.1:6379&gt; hset user name zhanghanzhe<br>(integer) 1<br>127.0.0.1:6379&gt; hmset user sex nan age 21<br>OK<br></code></pre></td></tr></table></figure><blockquote><p>获取，批量获取</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过key获取value</span><br>127.0.0.1:6379&gt; hget user name<br><span class="hljs-string">&quot;zhanghanzhe&quot;</span><br>127.0.0.1:6379&gt; hmget user name sex age<br>1) <span class="hljs-string">&quot;zhanghanzhe&quot;</span><br>2) <span class="hljs-string">&quot;nan&quot;</span><br>3) <span class="hljs-string">&quot;21&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取所有key</span><br>127.0.0.1:6379&gt; hkeys user<br>1) <span class="hljs-string">&quot;name&quot;</span><br>2) <span class="hljs-string">&quot;sex&quot;</span><br>3) <span class="hljs-string">&quot;age&quot;</span><br><span class="hljs-comment"># 获取所有value</span><br>127.0.0.1:6379&gt; hvals user<br>1) <span class="hljs-string">&quot;zhanghanzhe&quot;</span><br>2) <span class="hljs-string">&quot;nan&quot;</span><br>3) <span class="hljs-string">&quot;21&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取所有的key和value</span><br>127.0.0.1:6379&gt; hgetall user<br>1) <span class="hljs-string">&quot;name&quot;</span><br>2) <span class="hljs-string">&quot;zhanghanzhe&quot;</span><br>3) <span class="hljs-string">&quot;sex&quot;</span><br>4) <span class="hljs-string">&quot;nan&quot;</span><br>5) <span class="hljs-string">&quot;age&quot;</span><br>6) <span class="hljs-string">&quot;21&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>删除指令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hdel user name<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hdel user sex age<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><blockquote><p>自增和自减</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hset map key1 5<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hincrby map key1 2<br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; hincrby map key1 -3<br>(<span class="hljs-built_in">integer</span>) 4<br></code></pre></td></tr></table></figure><blockquote><p>判断是否存在，存在返回 1，不存在返回 2</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hexists map key1<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><h3 id="Zset-有序集合">Zset 有序集合</h3><p>zset 有序集合和 set 集合类似，都是不允许重复的值出现，只不过相比于 set 集合，zset 多了一个排序的功能，在添加值得时候需要给他一个 <code>分值</code>，<font color="red"><code>分值</code> 可以重复但 <code>value</code> 不允许重复</font>，默认按照分值从小到大排序</p><p><em>老规矩，几乎所有 zset 的指令都以 z开头</em></p><blockquote><p>添加元素 zadd，第一个是分值，第二个是 value</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd user 1 zhang<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd user 2 han 3 zhe<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><blockquote><p>删除元素</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zrem user zhang han zhe<br>(<span class="hljs-built_in">integer</span>) 3<br></code></pre></td></tr></table></figure><blockquote><p>查看集合</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 正常查看集合</span><br>127.0.0.1:6379&gt; zrange user 0 -1<br>1) <span class="hljs-string">&quot;zhang&quot;</span><br>2) <span class="hljs-string">&quot;han&quot;</span><br>3) <span class="hljs-string">&quot;zhe&quot;</span><br><span class="hljs-comment"># 倒序查看集合</span><br>127.0.0.1:6379&gt; zrevrange user 0 -1<br>1) <span class="hljs-string">&quot;zhe&quot;</span><br>2) <span class="hljs-string">&quot;han&quot;</span><br>3) <span class="hljs-string">&quot;zhang&quot;</span><br><span class="hljs-comment"># 查看带有分值的集合</span><br>127.0.0.1:6379&gt; zrange user 0 -1 withscores<br>1) <span class="hljs-string">&quot;zhang&quot;</span><br>2) <span class="hljs-string">&quot;1&quot;</span><br>3) <span class="hljs-string">&quot;han&quot;</span><br>4) <span class="hljs-string">&quot;2&quot;</span><br>5) <span class="hljs-string">&quot;zhe&quot;</span><br>6) <span class="hljs-string">&quot;3&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>获取集合内元素的数量 zcard zcount</p></blockquote><p>这里需要注意：==- inf 代表无穷小，+ inf 代表无穷大==</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd user 10 zhang 12 wang 18 li 20 zhao 28 bai 30 guo<br>(<span class="hljs-built_in">integer</span>) 6<br><span class="hljs-comment"># 获取当前集合数量</span><br>127.0.0.1:6379&gt; zcard user<br>(<span class="hljs-built_in">integer</span>) 6<br><span class="hljs-comment"># 获取当前集合分值符合区间内的数量</span><br>127.0.0.1:6379&gt; zcount user -inf +inf<br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; zcount user 10 20<br>(<span class="hljs-built_in">integer</span>) 4<br></code></pre></td></tr></table></figure><h2 id="三大特殊类型">三大特殊类型</h2><h3 id="地理位置">地理位置</h3><p><code>Geospatial</code> 类型用来存储有关经纬度的地理位置信息，默认经度第一位，维度第二位，redis 中针对经纬度的存储范围有一定的限制：</p><ul><li>经度有效范围：-180 ~ 180</li><li>维度有效范围：-85.05112878 ~ 85.05112878</li></ul><p><em>老规矩，几乎所有指令都是以 geo开头的</em></p><blockquote><p>添加地理位置信息 geoadd</p></blockquote><p>在添加经纬度的时候如果超出了范围会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geoadd point 126.64 45.75 hei<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; geoadd point 125.32 43.88 ji 123.42 41.79 liao<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><blockquote><p>查看指定地区的经纬度 ( 已存入的 )，同理，添加也是修改</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geopos point ji<br>1) 1) <span class="hljs-string">&quot;125.32000154256820679&quot;</span><br>   2) <span class="hljs-string">&quot;43.87999897829567431&quot;</span><br>127.0.0.1:6379&gt; geopos point hei ji liao<br>1) 1) <span class="hljs-string">&quot;126.64000242948532104&quot;</span><br>   2) <span class="hljs-string">&quot;45.74999965248261447&quot;</span><br>2) 1) <span class="hljs-string">&quot;125.32000154256820679&quot;</span><br>   2) <span class="hljs-string">&quot;43.87999897829567431&quot;</span><br>3) 1) <span class="hljs-string">&quot;123.41999977827072144&quot;</span><br>   2) <span class="hljs-string">&quot;41.78999971580505246&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>计算两地的距离 geodist</p></blockquote><p>使用 <code>geodist</code> 获取距离是通过经纬度计算出来的 <strong>直线距离</strong>，并不是路途距离，默认获取单位是米，可以通过制定后缀来设置获取的单位： <code>m/米</code>，<code>km/千米</code>，<code>mi英里</code>，<code>ft英尺</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取吉林到黑龙江的直线距离</span><br>127.0.0.1:6379&gt; geodist point hei ji<br><span class="hljs-string">&quot;232604.0065&quot;</span><br>127.0.0.1:6379&gt; geodist point hei ji km<br><span class="hljs-string">&quot;232.6040&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>雷达方式获取目标经纬度附近的地理位置 georadius</p></blockquote><p>雷达方式，以经纬度为中心，距离为半径按照圆形扫描，类似微信附近的人功能</p><p><code>withdist距离km</code>，<code>withdist经纬度</code>，<code>count 1 显示第一个符合要求的</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 返回经度125维度43附近300km的位置信息</span><br>127.0.0.1:6379&gt; georadius point 125 43 300 km<br>1) <span class="hljs-string">&quot;ji&quot;</span><br>2) <span class="hljs-string">&quot;liao&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 多要求获取</span><br>127.0.0.1:6379&gt; georadius point 125 43 300 km withdist withcoord count 1<br>1) 1) <span class="hljs-string">&quot;ji&quot;</span><br>   2) <span class="hljs-string">&quot;101.2331&quot;</span><br>   3) 1) <span class="hljs-string">&quot;125.32000154256820679&quot;</span><br>      2) <span class="hljs-string">&quot;43.87999897829567431&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用已存在的地理位置进行获取</span><br>127.0.0.1:6379&gt; georadiusbymember point ji 250 km<br>1) <span class="hljs-string">&quot;ji&quot;</span><br>2) <span class="hljs-string">&quot;hei&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>移除元素</p></blockquote><p><code>Geospatial</code> 类型比较特殊，他没有给咱们提供移除的指令，但是 <code>Geospatial</code> 的底层是基于 <code>zset</code> 实现的，我们可以通过 <code>zset</code> 来移除指定的 key 即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zrange point 0 -1<br>1) <span class="hljs-string">&quot;liao&quot;</span><br>2) <span class="hljs-string">&quot;ji&quot;</span><br>3) <span class="hljs-string">&quot;hei&quot;</span><br>127.0.0.1:6379&gt; zrem point hei<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; geopos point hei<br>1) (nil)<br></code></pre></td></tr></table></figure><h3 id="基数统计">基数统计</h3><p><code>hyperloglog</code> 他是一种专门用来统计及基数的类型，当然其中的元素不允许重复，相比于 set 集合，例如计算网站访问量时，可以交给 <code>hyperloglog</code> 进行处理，他的内存占用是固定的 12KB。</p><p>但是因为他仅仅是计算基数的类型，所以并不能像 set 集合一样，获取到元素的具体的值，而且该类型有一定的误差，如果对精准度没有太大要求，那么推荐使用 <code>hyperloglog</code></p><p><em>老规矩，几乎所有指令都是以 pf开头的</em></p><blockquote><p>添加元素 pfadd</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; pfadd num1 1 2 3 4 5<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; pfadd num2 3 4 5 6 7<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><blockquote><p>查看元素个数</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; pfcount num1<br>(<span class="hljs-built_in">integer</span>) 5<br></code></pre></td></tr></table></figure><blockquote><p>将两个集合合并为一个集合</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; pfmerge num3 num1 num2<br>OK<br>127.0.0.1:6379&gt; pfcount num3<br>(<span class="hljs-built_in">integer</span>) 7<br></code></pre></td></tr></table></figure><h3 id="进制存储">进制存储</h3><p><code>bitmap</code> 是基于二进制进行存储的，二进制只有 0 和 1 两个值，可以分别用来代表两种相对不同的状态，例如 打卡 &lt;=&gt; 未打卡，可以抽象的理解为 boolean 类型中的 true 和 false 的感觉。</p><p><em>命令几乎都以 bit 结尾</em></p><blockquote><p>添加元素 [ 0 代表未打卡，1 代表打卡 ]</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; setbit sign 0 1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; setbit sign 1 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 2 0<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; setbit sign 3 1<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><blockquote><p>查看某个状态 – 返回 1 代表打卡，0 代表未打卡</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; getbit sign 1<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><blockquote><p>查看多少人符合条件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; bitcount sign<br>(<span class="hljs-built_in">integer</span>) 3<br></code></pre></td></tr></table></figure><h2 id="Redis-的事务">Redis 的事务</h2><p>事务就是一组命令的集合，将平时多次执行的命令放在一起，然后按照命令顺序依次执行，而且执行过程中不会被干扰，事务执行结束后不会保留，也就意味着每次执行事务都需要重新创建，可得出 redis 事务的三个特点：<font color="red">顺序性</font>，<font color="red">排他性</font>，<font color="red">一次性</font>。</p><p>还有几点需要注意：==redis 的事务中，没有原子性和隔离性的概念，也不包含回滚==，所有命令在加入事务的时候，并没有直接执行，而是被放在了执行的队列中，也就不存在隔离性。</p><p>事务涉及到的关键字：<code>开启/multi</code>，<code>执行/exec</code>，<code>放弃/discard</code>，<code>监视/watch</code>，<code>关闭监视/unwatch</code></p><h3 id="使用事务">使用事务</h3><blockquote><p>事务的执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当输入multi的时候就表示事务开始了，当使用exec的时候，就表示要执行了</span><br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; mset k2 v2 k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>1) OK<br>2) OK<br>127.0.0.1:6379&gt; mget k1 k2 k3<br>1) <span class="hljs-string">&quot;v1&quot;</span><br>2) <span class="hljs-string">&quot;v2&quot;</span><br>3) <span class="hljs-string">&quot;v3&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当我事务添加中途，不想执行了，那么可以使用discard命令来放弃当前事务</span><br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 zhang<br>QUEUED<br>127.0.0.1:6379&gt; discard<br>OK<br>127.0.0.1:6379&gt; get k1<br><span class="hljs-string">&quot;v1&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>事务的异常处理机制</p></blockquote><p>和 java 有点类似，redis 针对事务也分所谓的 <code>编译时异常</code> 和 <code>运行时异常</code>，只不过这里的 <code>编译时异常</code> 指的是命令是否正确，针对不同的异常，redis 事务处理的方式也不一致</p><ul><li>命令错误的处理方式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当我在执行命令的时候，命令输入有误，这时整个事务都不会执行</span><br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> user zhang<br>QUEUED<br>127.0.0.1:6379&gt; sett name hanzhe<br>(error) ERR unknown <span class="hljs-built_in">command</span> `sett`, with args beginning with: `name`, `hanzhe`, <br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>(error) EXECABORT Transaction discarded because of previous errors.<br><span class="hljs-comment"># 因为事务报错，所以user并没有存进去，哪怕他是第一条命令</span><br>127.0.0.1:6379&gt; get user<br>(nil)<br></code></pre></td></tr></table></figure><ul><li>逻辑错误的处理方式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 自增的变量是字符而不是数字</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> money zhang<br>OK<br><span class="hljs-comment"># 然后我们再来执行事务</span><br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; incrby money 3000<br>QUEUED<br>127.0.0.1:6379&gt; decrby money 188<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> user zhang<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span> <span class="hljs-comment"># 他会直接提示前两句执行失败，但是第三句执行成功</span><br>1) (error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range<br>2) (error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range<br>3) OK<br><span class="hljs-comment"># 这里也是可以获取到的，哪怕他是最后一条，不符合原子性</span><br>127.0.0.1:6379&gt; get user<br><span class="hljs-string">&quot;zhang&quot;</span><br></code></pre></td></tr></table></figure><p>因为 redis 的事务管理并不严格，所以 redis 的事务又被人戏称 <strong>伪事务</strong></p><h3 id="乐观锁">乐观锁</h3><p>在我们执行事务的时候，如果是处在多线程的环境下，我通过事务对某个数据进行改变，但是在我命令缓存完成还没有执行的时候，另一条线程进来对这个数据进行了修改，那么就会发生难以想象的改变。</p><blockquote><p>模拟举例说明：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 线程1 启动事务</span><br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; incrby money 3000<br>QUEUED<br>127.0.0.1:6379&gt; decrby money 188 <br>QUEUED<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 线程2 中途插入</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> money 200000<br>(<span class="hljs-built_in">integer</span>) 200100<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 线程1 这时刚刚提交事务</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>1) (<span class="hljs-built_in">integer</span>) 203000<br>2) (<span class="hljs-built_in">integer</span>) 202812<br></code></pre></td></tr></table></figure><p>可以发现，在事务执行的过程中数据被改变了，结果也造成影响了</p><blockquote><p>什么是乐观锁？</p></blockquote><p>关于锁，有两个概念，一个是 <code>悲观锁</code>，还有一个是 <code>乐观锁</code>，悲观锁类似 java 中的多线程锁 <code>synchronized</code>，将整个方法上锁，无论是否有多条线程访问都会工作，在安全的前提下影响了性能，而 <code>乐观锁</code> 是在指令添加前将被操作的那个 key 监视起来，如果在执行的时候发现目标 key 发生了改变，那么就将当前事务取消不执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 线程1</span><br><span class="hljs-comment"># 在启动事务之前，监视目标key</span><br>127.0.0.1:6379&gt; watch money<br>OK<br><span class="hljs-comment"># 启动事务</span><br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; incrby money 3000<br>QUEUED<br>127.0.0.1:6379&gt; decrby money 188<br>QUEUED<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 线程2 中途插入</span><br>127.0.0.1:6379&gt; incrby money 200000<br>(<span class="hljs-built_in">integer</span>) 200100<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 线程1 这时刚刚提交事务</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>(nil)<br></code></pre></td></tr></table></figure><p>可以发现，被监视的 key 发生改变后，事务执行就被中断了，那么之后应该如何处理呢？</p><blockquote><p>乐观锁善后</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.关闭当前事务</span><br>127.0.0.1:6379&gt; discard<br>OK<br><span class="hljs-comment"># 关闭监控</span><br>127.0.0.1:6379&gt; unwatch<br>OK<br><span class="hljs-comment">## 重新监控，再走一遍事务逻辑.....</span><br><span class="hljs-comment">## 在执行前在进行比对....</span><br></code></pre></td></tr></table></figure><h2 id="持久化保存策略">持久化保存策略</h2><p>我们都是到，redis 是操作内存的数据库，正因为这样的特点才让他的存取速度特别快，但是在内存中存放的数据，当我们重新启动服务器的时候就会丢失，这个时候就需要接触到 <code>持久化</code> 这个技术了，持久化就是把当前进程数据生成快照保存到硬盘的过程。</p><p>redis 的持久化操作分为两种，分别为 <code>RDB</code> 和 <code>AOF</code>，两种方式只能同时使用一种，redis 使用的 <strong>默认持久化方式为 RDB</strong>，</p><h3 id="RDB-方式">RDB 方式</h3><p>RDB ( Redis DataBase ) 持久方式，会单起一条线程，在指定的时间间隔内将内存中的数据以二进制形式写入、临时文件中，写入成功后默认存放到 redis 的安装目录下的 <code>dump.rdb</code> 文件中，如果你使用自己的配置启动的 redis，那么 <code>dump.rdb</code> 会和你的配置文件同级。</p><p>RDB 的持久化有两种触发机制，一种是手动命令持久化，一种是自动持久化。</p><blockquote><p>手动持久化 <code>save</code>，<code>bgsave</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; save<br>OK<br>127.0.0.1:6379&gt; bgsave<br>Background saving started<br></code></pre></td></tr></table></figure><ul><li><code>save</code> 命令会阻塞当前 redis 服务器，期间不能正常提供服务，这一现象直至数据保存完毕后恢复正常。</li><li><code>bgsave</code> 会执行 fork 子进程负责持久化操作，在创建子进程的时候会有短暂的阻塞，时间很短。</li></ul><p>除开这种主动的持久化之外，一些其他的命令也会完成持久化的操作，例如：<code>flushall</code>，<code>shutdown</code> 等等。</p><blockquote><p>自动持久化</p></blockquote><p>配置文件中的 SNAPSHOTTING 模块就是用来做 RDB 持久化的，里面有这样几句配置命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">################################ SNAPSHOTTING  ################################ 快照</span><br><span class="hljs-comment"># save 时间/s 数据修改次数</span><br><span class="hljs-comment"># 例如 save 900 1，如果数据只修改了一次，那么就900秒持久化一次</span><br>save 900 1<br>save 300 10<br>save 60 10000<br><span class="hljs-comment"># 当RDB最后一次保存失败后，是否停止接受数据，默认yes (否则没人知道它坏了)</span><br>stop-writes-on-bgsave-error <span class="hljs-built_in">yes</span><br><span class="hljs-comment"># 是否以压缩形式保存，默认为yes</span><br>rdbcompression <span class="hljs-built_in">yes</span><br><span class="hljs-comment"># 是否效验数据完整性，默认为yes</span><br>rdbchecksum <span class="hljs-built_in">yes</span><br><span class="hljs-comment"># 持久化保存文件名</span><br>dbfilename dump.rdb<br><span class="hljs-comment"># 持久化文件保存路径</span><br><span class="hljs-built_in">dir</span> ./<br></code></pre></td></tr></table></figure><p>一般我们不需要该他的配置文件，预设的就够用了。</p><h3 id="AOF-方式">#####AOF 方式#####</h3><p>同样还是在配置文件中，APPEND ONLY MODE 模块就是负责 AOF 持久化的，和 RDB 不同， AOF 的原理是将所有曾经使用过的存入操作的命令都记录下来，存放到 <code>appendonly.aof</code> 文件中，是可以看个模糊的大概的。</p><blockquote><p>AOF 持久化配置</p></blockquote><p>AOF 也可以手动触发，只需要执行 <code>bgrewriteaof</code> 命令即可，但是一般都用配置文件管理，配置信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">############################## APPEND ONLY MODE ############################### 仅附加模式</span><br><span class="hljs-comment"># 是否开启AOF，默认为no</span><br>appendonly no<br><span class="hljs-comment"># 指定更新条件，可以选择三个值：</span><br> <span class="hljs-comment"># no：每次修改都同步，数据完整性强，性能偏低</span><br> <span class="hljs-comment"># always：每秒同步一次，数据完整性较好</span><br> <span class="hljs-comment"># everysec：让操作系统自己同步数据，消耗资源最低</span><br>appendfsync everysec<br><span class="hljs-comment"># 百分比，如果数据文件大小占据了指定百分比，会触发重写。</span><br>auto-aof-rewrite-percentage 100<br><span class="hljs-comment"># 必须满足最小大小才可以重写</span><br>auto-aof-rewrite-min-size 64mb<br></code></pre></td></tr></table></figure><blockquote><p>AOF 重写</p></blockquote><ul><li>##########################################################################</li></ul><p>有关于持久化策略，以后再细学</p><h3 id="比较RDB和AOF">比较RDB和AOF</h3><p><code>RDB</code>：RDB 是二进制文件，按照时间进行数据同步，每次同步都会执行 fork 操作，如果为了追求数据数据完整性不停的同步，会极大的影响 redis 工作效率，更==适合做定期备份，用于灾难恢复==</p><p><code>AOF</code>：AOF 通过记录命令实现持久化，通过控制参数可以精确到秒级。</p><ul><li>##########################################################################</li></ul><p>有关于持久化策略，以后再细学</p><h3 id="文件损坏修复">文件损坏修复</h3><p>当我们的数据文件损坏导致 redis 无法启动的时候，我们可以尝试运行 redis 的修复工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-check-aof --fix 配置文件<br>redis-check-rdb --fix 配置文件<br></code></pre></td></tr></table></figure><ul><li>##########################################################################</li></ul><p>有关于持久化策略，以后再细学</p><h2 id="Redis-整合">Redis 整合</h2><p>所有程序均是以 maven 为基础搭建的</p><h3 id="原生-Java-整合">原生 Java 整合</h3><p>使用 java 项目整合 redis 进行操作，首先要添加 maven 依赖</p><blockquote><p>正常操作 redis</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加依赖完成后，便可以直接通过 java 代码创建连接并操作数据库了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建连接</span><br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">redis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;IP地址&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">// 验证连接密码</span><br>        redis.auth(<span class="hljs-string">&quot;你的密码&quot;</span>);<br>        <span class="hljs-comment">// 清空当前数据库</span><br>        redis.flushDB();<br>        <span class="hljs-comment">// 正常的增删改查</span><br>        System.out.println(redis.ping());<br>        System.out.println(redis.set(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;zhang&quot;</span>));<br>        System.out.println(redis.get(<span class="hljs-string">&quot;user&quot;</span>));<br>        <span class="hljs-comment">// 关闭连接</span><br>        redis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接创建 jedis 对象就可以创建远程连接，而且实例内的方法和 redis 的指令用法等等几乎一模一样，非常好用。</p><blockquote><p>redis 连接池</p></blockquote><p>一般来说 jedis 已经可以很好的操作 redis 数据库了，但是在项目中如果频繁的创建和关闭连接，是很耗费服务器资源的，所以这里可以使用 jedis 的连接池进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用默认的连接池操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisPoolDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建jedis连接池对象</span><br>        <span class="hljs-type">JedisPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(<span class="hljs-string">&quot;IP地址&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//  从连接池中获取连接</span><br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">redis</span> <span class="hljs-operator">=</span> pool.getResource();<br>        <span class="hljs-comment">// 正常操作jedis</span><br>        redis.auth(<span class="hljs-string">&quot;密码&quot;</span>);<br>        redis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;hanzhe&quot;</span>);<br>        System.out.println(redis.get(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-comment">// 关闭连接</span><br>        redis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用自定义配置的连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisPoolDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建连接池配置对象</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        <span class="hljs-comment">// 设置最大连接数</span><br>        poolConfig.setMaxTotal(<span class="hljs-number">50</span>);<br>        <span class="hljs-comment">// 设置最大空闲连接数</span><br>        poolConfig.setMaxIdle(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 按照指定的配置创建连接</span><br>        <span class="hljs-type">JedisPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig, <span class="hljs-string">&quot;IP地址&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">// 获取连接后面的操作就是一样的了</span><br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">redis</span> <span class="hljs-operator">=</span> pool.getResource();<br>        <span class="hljs-comment">// ........</span><br>        <span class="hljs-comment">// 关闭连接</span><br>        redis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>检查 redis 数据库</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;name&quot;</span><br>2) <span class="hljs-string">&quot;user&quot;</span><br>127.0.0.1:6379&gt; mget user name<br>1) <span class="hljs-string">&quot;zhang&quot;</span><br>2) <span class="hljs-string">&quot;hanzhe&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure><p>经过检查发现，java 操作 redis 不存在其他的问题，整合基本完成。</p><blockquote><p>控制台打印警告问题</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">SLF4J: Failed to load class <span class="hljs-string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.<br>SLF4J: Defaulting to no-operation (NOP) logger implementation<br>SLF4J: See http://www.slf4j.org/codes.html<span class="hljs-comment">#StaticLoggerBinder for further details.</span><br></code></pre></td></tr></table></figure><p>如果控制台打印如上的警报信息，可以引入 slf4j 的 maven 依赖进行解决</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Springboot-整合">Springboot 整合</h3><p>springboot 整合同样需要引入对应的 maven 依赖，和 jedis 有些许的不同，springboot 中封装的类并不可以直接调用类似命令的函数，而是对他们进行了二次封装</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>修改配置文件</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># IP地址</span><br><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">IP地址</span><br><span class="hljs-comment"># 端口</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-comment"># 访问密码</span><br><span class="hljs-attr">spring.redis.password</span>=<span class="hljs-string">密码</span><br><span class="hljs-comment"># 最大连接数</span><br><span class="hljs-attr">spring.redis.pool.max-active</span>=<span class="hljs-string">50</span><br><span class="hljs-comment"># 最大空闲连接数</span><br><span class="hljs-attr">spring.redis.pool.max-idle</span>=<span class="hljs-string">10</span><br></code></pre></td></tr></table></figure><blockquote><p>简单操作数据库</p></blockquote><p>操作数据库，需要注入 <code>RedisTemplate</code> 对象进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Redis2SpringbootApplicationTests</span> &#123;<br>    <span class="hljs-comment">// 自动注入对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;zhang&quot;</span>);<br>        <span class="hljs-comment">// 可以正常读取存入的 user 信息</span><br>        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RedisTemplate</code> 将数据类型对应的指令函数分别命名为 <code>opsForValue()</code>，<code>opsForList()</code>，<code>opsForSet()</code>，<code>opsForHash()</code>，<code>opsForHyperLogLog()</code> ，<code>opsForZSet()</code></p><blockquote><p>高级操作数据库</p></blockquote><p>上面的方法封装了各种数据类型的简单操作，接下来就是一些高级的操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Redis2SpringbootApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取当前连接</span><br>        <span class="hljs-type">RedisConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> redisTemplate.getConnectionFactory();<br>        <span class="hljs-type">RedisConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.getConnection();<br>        <span class="hljs-comment">// ping测试，清空库，停止服务，关闭连接等等高级操作</span><br>        System.out.println(connection.ping());<br>        connection.flushDb();<br>        connection.flushAll();<br>        connection.shutdown();<br>        connection.close();<br>        <span class="hljs-comment">// 开启事务等等相关设置也在这里</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>乱码问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java 代码</span><br>redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zhang&quot;</span>);<br>System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>));<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># redis 数据库</span><br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;\xac\xed\x00\x05t\x00\x04name&quot;</span><br></code></pre></td></tr></table></figure><p>我们通过 springboot 向 redis 中插入一个字符串，发现存进去的字符串存在乱码问题，这时候我们可以通过使用 <code>RedisTemplate</code> 的子类 <code>StringRedisTemplate</code> 进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Redis2SpringbootApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate string;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        string.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zhang&quot;</span>);<br>        System.out.println(string.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># name 也可以正常存取</span><br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;name&quot;</span><br>2) <span class="hljs-string">&quot;\xac\xed\x00\x05t\x00\x04name&quot;</span><br>127.0.0.1:6379&gt; get name<br><span class="hljs-string">&quot;zhang&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>自定义 RedisTemplate</p></blockquote><p>字符串可以通过 <code>StringRedisTemplate</code> 来解决问题，但是存入其他类型的还是会出现问题，这时可自己创建一个 <code>RedisTemplate</code> 来代替原本的类工作。<em>代码来自互联网</em></p><p>1.首先要引入 maven 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.创建配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisUtil</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>();<br>        template.setConnectionFactory(factory);<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        <span class="hljs-type">StringRedisSerializer</span> <span class="hljs-variable">stringRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-comment">// key采用String的序列化方式</span><br>        template.setKeySerializer(stringRedisSerializer);<br>        <span class="hljs-comment">// hash的key也采用String的序列化方式</span><br>        template.setHashKeySerializer(stringRedisSerializer);<br>        <span class="hljs-comment">// value序列化方式采用jackson</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">// hash的value序列化方式采用jackson</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        template.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候自定义的  就已经完成了，现在再来测试一遍是否乱码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Redis2SpringbootApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zhang&quot;</span>);<br>        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 乱码问题已经解决，这个特殊符号是字符串的转义</span><br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;name&quot;</span><br>127.0.0.1:6379&gt; get name<br><span class="hljs-string">&quot;\&quot;zhang\&quot;&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>通过序列化将对象存储到 redis 中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// implements Serializable 序列化接口一定要实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-comment">/* 省略get-set-toString方法 */</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Redis2SpringbootApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p.setUsername(<span class="hljs-string">&quot;张涵哲&quot;</span>);<br>        p.setPassword(<span class="hljs-string">&quot;zhang&quot;</span>);<br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;user&quot;</span>, p);<br>        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user&quot;</span>));<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 可以正常读取</span><br><span class="hljs-comment"> Person&#123;username=&#x27;张涵哲&#x27;, password=&#x27;zhang&#x27;&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="订阅与发布">订阅与发布</h2><p>redis 的订阅发布是一种通讯模式，分别为 <code>发送者/sub</code> 和 <code>订阅者/pub</code> 两种身份，发布者负责发送一些信息，然后由订阅者接收，涉及到的命令也非常少</p><blockquote><p>最常用：简单使用订阅和发布完成交互 <code>subscribe</code>，<code>publish</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 订阅者 当我订阅s1频道的时候，命令行就会被锁定，静等s1频道发送信息</span><br>127.0.0.1:6379&gt; subscribe s1<br>Reading messages... (press Ctrl-C to quit)<br>1) <span class="hljs-string">&quot;subscribe&quot;</span><br>2) <span class="hljs-string">&quot;s1&quot;</span><br>3) (<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 发布者 只需要在固定的频道发送消息即可，不用考虑订阅者状态</span><br>127.0.0.1:6379&gt; publish s1 haha<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 订阅者 命令行状态发生改变：</span><br>1) <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 提示接受到了消息</span><br>2) <span class="hljs-string">&quot;s1&quot;</span>     <span class="hljs-comment"># 如果订阅了多个，在这里区分发布者频道</span><br>3) <span class="hljs-string">&quot;haha&quot;</span>    <span class="hljs-comment"># 频道发送的消息</span><br></code></pre></td></tr></table></figure><h2 id="主从复制">主从复制</h2><p>在我们的项目越做越大的情况下，一个 redis 服务可能已经不支持我们的读写效率了，这个时候我们需要配置多个服务器，在每个服务器上都配置 redis 的环境，让他们分别为一个程序提供服务，这种工作方式被称之为集群</p><p>在多个服务器中选中一台服务器为主机 ( Master )，其他为从机 ( Slave )，主机负责写入数据 ( set… )，而从机负责读取数据 ( get )，为了多个服务器之间数据同步的问题，所以有了主从复制的技术。</p><p>这里可以通过复制多个配置文件，修改端口号来实现 <code>伪集群</code>，设置 6379 为主机，6380 为从机，后面简称为 79 和 80</p><h3 id="通过命令实现">通过命令实现</h3><p>选择 79 为主机，连接主机输入 <code>info replication</code> 命令即可查看当前机器配置状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; info replication<br><span class="hljs-comment"># Replication</span><br>role:master<br>connected_slaves:0<br>master_replid:49e04dfecc70d4b55f17798d80b1d77ac4289c12<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure><p>第二行位置显示 role:master，代表当前端口是主机，==redis 默认每台机器都是主机==，配置主从复制只需要配置从机就可以了。</p><p>配置从机 <code>slaveof</code> 认主，只需要找到目标 Redis 服务器作为自己的主人就可以了，这样一来从机就可以获取到主机的数据了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 80，81 端口</span><br>127.0.0.1:6380&gt; slaveof localhost 6379<br>OK<br>127.0.0.1:6380&gt; info replication<br><span class="hljs-comment"># Replication</span><br>role:slave<br>master_host:127.0.0.1<br>master_port:6379<br>master_link_status:up<br>master_last_io_seconds_ago:7<br>master_sync_in_progress:0<br>slave_repl_offset:434<br>slave_priority:100<br>slave_read_only:1<br>connected_slaves:0<br>master_replid:5ec4f58da9447b03e682d76edb61cbf5e4cf89a2<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:434<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:434<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 笔记</title>
    <link href="/2022/08/21/Spring%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/21/Spring%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>Spring 笔记</h1><p>spring 是基于 java 语言的轻量级的 IOC 和 AOP 容器框架，使用 spring 可以简易开发流程，降低代码耦合度</p><blockquote><p>它主要包括以下几个模块</p></blockquote><table><thead><tr><th>模块</th><th>作用</th></tr></thead><tbody><tr><td>core</td><td>核心类库，提供 spring 的 ioc 容器服务，是 spring 框架运行的基础</td></tr><tr><td>context</td><td>提供了 bean 的获取功能和解析配置文件的服务</td></tr><tr><td>aop</td><td>提供了 aop 面向切面编程的服务</td></tr><tr><td>dao</td><td>提供了简单的 JDBC 功能</td></tr><tr><td>orm</td><td>对 ORM 框架提供了很好的整合服务</td></tr><tr><td>web</td><td>提供 web 方面的服务</td></tr></tbody></table><img src="/img/5.jpg" title="Spring 的板块" /><h2 id="简单Spring程序实例">简单Spring程序实例</h2><h3 id="spring-环境搭建">spring 环境搭建</h3><p>使用 Spring 需要导入他的 maven 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 想要使用Spring框架需要添加一个context依赖，他会加载spring有关的多个jar包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置文件的编写">配置文件的编写</h3><p>在 IDEA 环境下，在项目 resources 目录下新建 spring config 配置文件，然后创建一个简单的实体类，在配置文件使用 <code>bean</code> 标签装配这个 bean (实体类)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Dog&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog01&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在测试类中获取到这个 Bean 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring.xml&quot;</span>);<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">dog01</span> <span class="hljs-operator">=</span> (Dog)ioc.getBean(<span class="hljs-string">&quot;dog01&quot;</span>);<br>    System.out.println(dog01);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Spring-IOC-容器">Spring IOC 容器</h2><p>IOC（Inver se of Control）可理解为容器，是 Spring 框架的和核心，他管理着 Spring 的组件，实现了控制反转的功能，之前练习配置的 dog 就是放在了 IOC 容器中才可以获取得到</p><h3 id="Bean-工厂">Bean 工厂</h3><p>Bean 工厂可以理解为 IOC 容器 ，由它来为我们创建 Bean 的实例对象，通过 Bean 工厂的实例可以获取到装配在 IOC 中的 Bean 的实例</p><p>1、BeanFactory 接口：Spring最核心的接口，提供了 IOC 配置机制，通常被称为 IOC 容器</p><p>2、ApplicationContext 接口：应用上下文，建立在 Bean 工厂的基础上，他下面有两个实现类:</p><ol><li>ClassPathXmlApplication： 从类路径 ( classpath ) 下加载配置文件</li><li>FileSystemXmlApplicationContext：  从文件系统 ( url路径 ) 中加载配置文件</li></ol><p><strong>BeanFactory 和 ApplicationContext的区别</strong></p><ol><li>BeanFactory 会在本身实例化完成后，在调用某个 getBean 的时候才会实例化那个对应的 bean，而ApplicationContext 是在加载配置文件的时候就将所有单例模式的 bean 实例化</li><li>ApplicationContext 在启动时就会检查 XML 文件是否正确，而 BeanFactory 则是在获取 Bean 时才会检查</li></ol><h3 id="XML-配置-Bean">XML 配置 Bean</h3><h4 id="Bean-的装配与获取">Bean 的装配与获取</h4><p>装配 Bean 需要使用 <code>bean</code> 标签进行装配，class 属性来指定被装配的类，id 作为类的名字不可重复</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--通过类的全限定名（包名+类名）告知SpringIOC容器要管理和创建bean对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Dog&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog01&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置好XML后再类中获取bean对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 通过目标配置文件创建IOC容器实例</span><br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring.xml&quot;</span>);<br>    <span class="hljs-comment">// 通过IOC实例获取其中已装配的bean(默认获取到的是Object类型的对象，需要进行向下转型)</span><br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">dog01</span> <span class="hljs-operator">=</span> (Dog)ioc.getBean(<span class="hljs-string">&quot;dog01&quot;</span>);<br>    <span class="hljs-comment">// 打印测试</span><br>    System.out.println(dog01);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 xml 装配 bean 的时候，可以向 bean 中注入参数，注入参数的过程就叫 ==DI ( 依赖注入 )==</p><h4 id="配置文件的依赖注入">配置文件的依赖注入</h4><p>我们将一开始的 dog 类中的值设置为 null，然后通过依赖注入的方法对实例进行赋值</p><p>正常的依赖注入是依靠属性内的 ==set 方法依赖注入==的，如果 set 方法不存在或命名错误则会影响正常运行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Dog&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog01&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;哈哈&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;7&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除开 set 依赖注入还可以通过==构造方法依赖注入==，在实体类中创建构造器，然后在配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Dog&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog01&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;嘿嘿&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果被注入的不是一般类型而是引用类型，例如一个人养了狗，person 类内有一个属性是 dog</p><blockquote><p>==引用类型注入1==：使用 ref 属性来引用定义过的 bean ( 定义的Bean不分先后顺序 )</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Dog&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog01&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;嘿嘿&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Person&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李江&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dog01&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>除开自定义的引用类型之外，java 有很多引用类型，例如集合数组</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.pojo.Good&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;good&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>Good测试类<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>list第一个元素<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>list第二个元素<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;set&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>set第一个元素<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>set第二个元素<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;key1&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>value1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;key2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value2&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;arr&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;user2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>注入 list 集合需要在 <code>property</code> 标签下使用 <code>list</code> 下的 <code>value</code> 来进行注入</li><li>注入 set 集合同 list 一个原理，只不过将 list  转换为 set</li><li>注入 map 集合需要在 <code>property</code> 标签下：<ul><li>使用 <code>entry</code> 作为 key，而后用 <code>entry</code> 的子标签 <code>value</code> 作为 value</li><li>也可以直接在 <code>entry</code> 标签上以属性的方式传入 key=“” value=“”</li></ul></li><li>注入数组同 list 和 set，将中间标签换为 <code>array</code> 即可，用 <code>value</code> 子标签来传值</li></ul><p>扩展：==名称空间注入==，在配置文件中添加 p 的命名空间，然后通过属性的方式进行注入</p><blockquote><p>p 命名空间后面跟上注入的属性名称，然后将值填入即可，需要留意的是 p 标签也是依赖 set 方法的</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Dog&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">p:value</span>=<span class="hljs-string">&quot;123&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>p 命名空间是针对属性的 set 方法的，那么自然也就有针对构造方法的 c 命名空间</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 通过c命名空间操作构造方法内的指定参数名称进行注入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Dog&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">c:value</span>=<span class="hljs-string">&quot;456&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 也可以通过构造方法参数的下标顺序进行注入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Dog&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">c:_0</span>=<span class="hljs-string">&quot;456&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="Bean-别名配置">Bean 别名配置</h4><p>在 xml 中装配了某个 bean 后，需要通过标签的 id 或者 name 值从 IOC 容器中获取到该类的实例，除 id，name 属性之外，还可以通过别名来获取指定的 bean，为装配的 bean 起别名需要使用到 <code>alias</code> 标签</p><blockquote><p>将名为 dog 的 bean 起别名为 abc，这样出来 dog 可以获取到之外，使用 abc 也可以获取得到</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Dog&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;嘿嘿&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;abc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="注解装配-Bean">注解装配 Bean</h3><h4 id="搭建-Junit-测试环境">搭建 Junit 测试环境</h4><p>因为注解操作 Bean 不会手动创建 IOC 容器，所以就要升级一下 Junit 测试，让他自行创建 IOC</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="Bean-的装配与获取-v2">Bean 的装配与获取</h4><p>在实体类上使用 <code>@Component</code> 注解将他装配到 IOC 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;阿汪&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;雄性&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在配置文件中打开注解配置 Bean 的功能，并扫描注解存在的包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;site.hanzhe&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>测试注解获取 bean</p><blockquote><p>@ContextConfiguration 注解指定配置文件来生成 IOC 容器</p><p>@RunWith 注解来指定使用 spring 集成的注解，可以使用 IOC</p><p>@Autowired 注解用于自动装配 IOC 内符合条件的 Bean</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ContextConfiguration(&quot;classpath:spring.xml&quot;)</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestForAnnotation</span> &#123;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> Dog d;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(d.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注解装配的依赖注入">注解装配的依赖注入</h4><p>==简单类型依赖注入== ( 包括 String ) 只需要在该变量上标注 @Value，在注解时传入注入的值即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;12&quot;)</span><br>    <span class="hljs-keyword">private</span> String value;<br>&#125;<br></code></pre></td></tr></table></figure><p>==引用类型依赖注入==直接使用 @Autowired 注解进行注入即可</p><h4 id="Spring-的自动装配">@Spring 的自动装配</h4><p>AutoWired 注解，他的作用是自动检测 IOC 容器中符合被装配的条件的 Bean 然后将其装配进来，他默认查找符合的条件是 Bean 的类型</p><p>那么一个新的问题就诞生了，如果 IOC 中有两个类型一样的 Bean，这个时候就需要用到另一个注解 ==@Qualifier==</p><blockquote><p>在向 IOC 中装配 Bean 的时候，给他一个名字</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(value=&quot;dog01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;阿汪&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;雄性&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在使用 @AutoWired 进行自动装配的时候配合 @Qualifier 使用，指定被装配的 bean 的名称</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(&quot;dog01&quot;)</span><br>Dog dog;<br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(dog);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="font-color-red-分层注解–语义化-font"><font color="red"><strong>分层注解–语义化</strong></font></h4><table><thead><tr><th>注解</th><th>语义化</th></tr></thead><tbody><tr><td>@Component</td><td>注解表明当前类为 Bean , 同时当有其他无法归类的也可以使用当前注解</td></tr><tr><td>@Controller</td><td>适用于 web 层,  用来标识当前类是控制器类</td></tr><tr><td>@Service</td><td>适用于 service 层的注解,  用来书写逻辑处理</td></tr><tr><td>@Repository</td><td>适用于 dao 层的类</td></tr></tbody></table><h3 id="Java-类配置-Bean">Java 类配置 Bean</h3><p>在 Spring 中可以通过 Java 类来配置 bean，但是这种做法并不常用，了解即可</p><h4 id="Bean-的装配与获取-v3">Bean 的装配与获取</h4><p>创建一个配置类，用来专门装配 bean，使用 ==@Configuration== 注解标识该类，在配置类中使用函数来返回实例对象，在函数上添加 @Bean 注解即可完成装配，@Bean 还可以传入参数做为 bean 的名称</p><blockquote><p>需要在配置文件中扫描配置类才可以被使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">config</span> &#123;<br>    <span class="hljs-meta">@Bean(&quot;dog01&quot;)</span><br>    <span class="hljs-keyword">public</span> Dog <span class="hljs-title function_">getDog01</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;dog01&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>装配完成后获取该类即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;SpringConfig.xml&quot;</span>);<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">dog01</span> <span class="hljs-operator">=</span> (Dog)ioc.getBean(<span class="hljs-string">&quot;dog01&quot;</span>);<br>    System.out.println(dog01);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Bean的作用域">Bean的作用域</h3><p>Bean 的作用域有常见的几种：单例，多例，request、session, global，bean 的作用域的配置方法是在 Spring 中配置 bean 的时候在 bean 标签上添加的 scope 属性</p><table><thead><tr><th>作用域</th><th>效果及作用</th></tr></thead><tbody><tr><td>singleton</td><td>单例模式，默认作用域,单例模式下的所有组件都在ioc启动完毕之前完成注册,表示spring IOC中只能存在一个Bean实例</td></tr><tr><td>prototype</td><td>原型模式，ioc容器启动时不会注册组件，什么时候获取bean，什么时候创建，每次获取bean时都是一个新的实例</td></tr><tr><td>request</td><td>每次Http请求都会创建一个新的Bean，切这个Bean只在当前request内有效</td></tr><tr><td>session</td><td>同一个Session中共享Bean实例，不同的Session请求会创建新的Bean实</td></tr><tr><td>globalSession</td><td>在一个全局Session中，容器会返回该Bean的同一个实例，仅适用于Portlet应用环境</td></tr></tbody></table><h3 id="Bean的生命周期">Bean的生命周期</h3><p>Bean的生命周期是指Bean从创建到销毁的过程，在Spring中配置Bean之后，在加载Spring核心配置文件的时候初始化，调用 close 方法的时候销毁，可以在xml中配置Bean的时候,通过Bean标签中的属性控制让他在初始化和销毁的时候可以执行什么方法</p><p>当使用 XML 配置 Bean 的时候</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.pojo.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroy&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>在配置Bean的时候指定了init-method和destroy-method两个属性,  他们分别代表着:</p><ol><li><p>init-method=“init”   在初始化的时候执行当前 Bean 中名称为 init 的方法</p></li><li><p>destroy-method=“destroy”   在销毁的时候执行当前 Bean 中名称为 destroy 的方法</p></li></ol><blockquote><p>注意: 初始化方法的执行优先级低于构造方法</p></blockquote><h3 id="Spring-的懒加载">Spring 的懒加载</h3><p>在 Spring 中的 ClassPathXmlApplicationContext 中，默认只要将 bean 装配进去，无论是否使用了他，都会对 Bean 进行实例化 ( 这一点通过构造函数可以体现 )，但是配置 Bean 的时候可以为他手动设置一个属性，让 IOC 不对它进行自动实例化，这个叫做 ==bean 的懒加载==，通过装配 bean 时的 lazy-init 属性来控制</p><blockquote><p>dog01 正常装配，在创建 IOC 容器的时候会自动实例化，而 dog02 则会在使用 getBean 后才会实例化</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog01&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Dog&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dog01&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog02&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.bean.Dog&quot;</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dog02&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="整合多个配置文件">整合多个配置文件</h3><p>我们在写程序的时候，可能会将配置信息分开为 n 多个配置文件，例如 spring 本身的配置文件，整合 mybatis 以及 mvc 等等，当我们书写了多个配置文件的时候我们就需要将他们整合起来：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--将指定的xml文件整合到当前文件中--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;spring-mybatis.xml&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h2 id="AOP-面向切面编程">AOP 面向切面编程</h2><p>在 Spring 中使用 AOP 需要引入 aspect 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="AOP-知识梳理">AOP 知识梳理</h3><p>AOP 是面向切面编程思想，底层基于动态代理技术 ( JDK OR CGLIB ) 实现的面向切面编程，在不影响源代码的情况下动态增加新的功能，例如 <strong>事务控制</strong>，<strong>日志记录</strong> 等等，Spring ( 5.1.5 ) 框架默认选用的是 JDK动态代理技术</p><blockquote><p>AOP 专业名词梳理</p></blockquote><p>学习 AOP 之前先了解一下关于 AOP 的一些专业名词，不必死记硬背，了解即可：</p><table><thead><tr><th>AOP</th><th>文字解释</th></tr></thead><tbody><tr><td>aspect 切面</td><td>他是一个专门用来处理AOP的类，里面封装着切面需要执行的方法</td></tr><tr><td>advice 通知</td><td>代码增强后都干了些什么，指通知的内容，切面类中具体执行的方法</td></tr><tr><td>joinpoint 连接点</td><td>代表所有可以被增强的方法</td></tr><tr><td>pointcut 切入点</td><td>可增强的方法未必会去增强，而真正被增强的方法就是切入点</td></tr></tbody></table><p>上面提到通知就是具体增强的方法，AOP 中的通知类型共有五种:</p><table><thead><tr><th>AOP</th><th>文字解释</th></tr></thead><tbody><tr><td>Before 前置通知</td><td>目标方法被调用之前执行</td></tr><tr><td>AfterReturning 返回通知</td><td>目标方法<strong>正常运行</strong>结束后执行</td></tr><tr><td>AfterThrowing 异常通知</td><td>目标方法执行过程中抛出异常的时候执行</td></tr><tr><td>After 后置通知</td><td>无论目标方法是否正常结束都会执行</td></tr><tr><td>Around 环绕通知</td><td>通知包裹了目标方法，分别在调用前后执行的通知功能</td></tr></tbody></table><blockquote><p>通过异常捕获机制形象的理解AOP</p></blockquote><p>AOP 是在不影响源代码的情况下增强功能，那么既然是增强功能就一定要注意执行的时机，上面的五种通知类型就对应着各种执行的时机，我们来通过异常捕获机制来具体了解一下：</p><img src="/img/spring-01.jpg" style="float: left" /><h3 id="Execution-表达式">Execution 表达式</h3><p><code>execution</code> 表达式是用来在连接点中匹配切点使用的，这里记录一下使用方法，后面会用到</p><blockquote><p>execution表达式语法 <strong>（&lt;修饰符&gt;?&lt;返回值类型&gt;空格&lt;全限定类名&gt;&lt;方法名&gt;(参数列表)&lt;异常&gt;）</strong></p></blockquote><p>通配符解释：</p><ul><li><p>【*】匹配一个或多个字符，可以代替返回值类型，方法名，包名，参数列表，例如：</p><ul><li>execution(public <em>*</em> site.hanzhe.service.**<em>Service.</em>**User(String, <em>*</em>))</li><li>匹配 public 修饰符，任意返回值类型，site.hanzhe.service 包下所有 Service 结尾的类中的所有 User 结尾的方法，其中要求方法的第一个参数是 String，第二个参数为任意类型参数</li></ul></li><li><p>【…】* 匹配的是字符单位，… 匹配的是数量单位，可以使用在包名，参数列表中，例如：</p><ul><li>execution(* site*…<em>*Service.*User(</em>…*))</li><li>public 修饰符可以省略不写，匹配任意返回值类型的 site 下的所有包以及子包以 Service 结尾的所有类中以 User 结尾的所有方法，方法中可以有任意数量及类型的参数列表</li></ul></li></ul><h3 id="XML配置AOP">XML配置AOP</h3><p>我们创建两个基本类，一个切面类用来存放通知方法，一个 service 类用来存放被增强的目标代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 日志切面类代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;========&gt;【前置通知】通知执行了&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;========&gt;【返回通知】通知执行了&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;========&gt;【后置通知】通知执行了&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;========&gt;【异常通知】通知执行了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 Spring ( 5.1.5 ) 默认选用 JDK动态代理实现 AOP，所以对于被增强的类需要实现一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Service接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(String name, String addr)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">existsUser</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Serviec实现类，也就是被增强的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(String name, String addr)</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;用户添加成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">existsUser</span><span class="hljs-params">(Integer id)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;用户已存在&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本的类我们已经准备好了，接下来我们就来书写 Spring 的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- AOP的名称空间： http://www.springframework.org/schema/aop --&gt;</span><br><br><span class="hljs-comment">&lt;!-- 将切面类以及被增强的类都交给IOC容器管理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.aspect.LogAspect&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site.hanzhe.service.impl.UserServiceImpl&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置AOP横切逻辑 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;toInsertUserGlobal&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">   execution(* site.hanzhe.service.impl.UserServiceImpl.insertUser(..))&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logAspect&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;toInserUser&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">            execution(* site.hanzhe.service.impl.UserServiceImpl.insertUser(..))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;toInserUser&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterReturning&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;toInserUser&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterThrowing&quot;</span></span><br><span class="hljs-tag">                            <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;toInsertUserGlobal&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span> <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">            execution(* site.hanzhe.service.impl.UserServiceImpl.insertUser(..))&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件书写好之后，我们就可以通过测试类获取对象测试了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span><br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;classpath:spring.xml&quot;</span>);<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> (UserService)ioc.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>        userService.insertUser(<span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;111222333&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试类后发现，增强代码成功运行！<em>通知执行顺序为：前置→目标代码→返回→后置</em>，我们在 Service 实现类中手动添加一个异常后再来测试：<em>通知执行顺序为：前置→目标代码→异常→后置</em></p><p>这里主要梳理一下 <code>aop:config</code> 标签的内容：</p><ul><li>aop:config 所有横切配置都在这个标签中实现<ul><li>aop:pointcut 全局切入点，可以在任何一个切面中引用</li><li>aop:aspect 切面，可以配置通知和切入点的结合<ul><li>aop:pointcut 局部切入点</li><li>aop:before… 通知，配合切面类的方法和切入点进行结合</li></ul></li></ul></li></ul><p>XML 配置 AOP 需要注意：通知执行的顺序是依靠在 XML 配置的先后顺序执行的，比如正常的执行顺序是【前置→目标代码→返回→后置】，但是我们在配置文件中将后置和返回的顺序调换一下就会发现，执行的顺序也会发生变化。</p><h3 id="注解配置-AOP">注解配置 AOP</h3><p>暂时保持切面类和 service 不变，先修改配置文件为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开启Spring注解开发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 开启AOP注解开发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 配置扫描包路径 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;site.hanzhe.service.impl, site.hanzhe.aspect&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>然后找到切面类，添加对应的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>     <span class="hljs-comment">// 声明这是个切面类</span><br><span class="hljs-meta">@Component</span>  <span class="hljs-comment">// 将切面类添加到IOC容器中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>    <span class="hljs-comment">// 类似 aop:pointcut 标签</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* site.hanzhe.service.impl.UserServiceImpl.insertUser(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">// 通知与注解都是互相对应的</span><br>    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;========&gt;【前置通知】通知执行了&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@AfterReturning(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;========&gt;【返回通知】通知执行了&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@After(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;========&gt;【后置通知】通知执行了&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@AfterThrowing(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;========&gt;【异常通知】通知执行了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在将实现类添加到 IOC 容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123; ...... &#125;<br></code></pre></td></tr></table></figure><p>最后来进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        userService.insertUser(<span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;111222333&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码正常执行，这里需要注意的是，注解开发AOP时通知执行的顺序并不会被方法声明的顺序所影响，<em>注解通知的顺序为：前置→目标代码→后置→返回</em></p><h3 id="JoinPoint-对象">JoinPoint 对象</h3><p>在使用 AOP 的时候，针对某个方法进行前置或者后置通知，不会只有打印语句这么简单，应该对目标方法获取一些有价值的信息进行操作才对，这里需要使用到 <code>JoinPoint</code> 对象来对目标方法进行获取</p><p>可以通过 <code>JoinPoint</code> 获取到目标 <strong>方法名</strong> 及 <strong>参数列表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>    <span class="hljs-comment">// 当前切面类中公用的切入点表达式</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* site.hanzhe.service.impl.UserServiceImpl.insertUser(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">point</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint point)</span>&#123;<br>        System.out.println(<br>            <span class="hljs-string">&quot;========&gt;【前置通知】&quot;</span><br>            + point.getSignature().getName() <br>            + <span class="hljs-string">&quot;方法执行了，携带的参数有：&quot;</span> <br>            + Arrays.asList(point.getArgs())<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除开获取这两种信息之外，当方法处理完成时所得到的==返回值==也可以获取得到</p><blockquote><p>在切面参数列表中定义一个变量用来接受返回值，然后通过注解中的 returning</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* site.hanzhe.service.impl.UserServiceImpl.insertUser(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-meta">@AfterReturning(value = &quot;pointcut()&quot;, returning = &quot;r&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(Object r)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;========&gt;【返回通知】返回的结果为：&quot;</span> + r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然能获取到返回值，那么在程序抛出异常时也可以获取==异常信息==</p><blockquote><p>同返回值一个原理，通过在注解中使用属性来获取到异常信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>    <span class="hljs-meta">@AfterThrowing(value = &quot;pointcut()&quot;, throwing = &quot;e&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">( Exception e )</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;========&gt;【异常通知】异常信息为：&quot;</span> + e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="强大的环绕通知">强大的环绕通知</h3><p>在 spring 的 aop 中，所有通知的使用方法几乎都是差不多的，在 xml 或者使用注解进行配置，匹配合适的时机进行切入即可，我们学过的通知有 <strong>前置通知，后置通知，返回通知，异常通知</strong> ，四种通知分别对应不同的时机进行切入，而环绕通知一个就可以代替上面四个通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* site.hanzhe.service.impl.UserServiceImpl.insertUser(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-meta">@Around(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span>&#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<br>                <span class="hljs-string">&quot;========&gt;【环绕-前置通知】&quot;</span> + point.getSignature().getName()<br>                + <span class="hljs-string">&quot;方法执行了，携带的参数有：&quot;</span><br>                + Arrays.asList(point.getArgs())<br>            );<br>            r = point.proceed(point.getArgs());<br>            System.out.println(<span class="hljs-string">&quot;========&gt;【环绕-返回通知】返回的结果为：&quot;</span> + r);<br>        &#125; <span class="hljs-keyword">catch</span> ( Throwable e ) &#123;<br>            System.out.println(<span class="hljs-string">&quot;========&gt;【环绕-异常通知】异常信息为：&quot;</span> + e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;========&gt;【环绕-后置通知】通知执行了&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>环绕通知需要 <code>ProceedingJoinPoint</code> 作为参数列表，我们可以通过 <code>ProceedingJoinPoint</code> 实例来自己掌控方法的调用时机，<em>方法必须要调用，而且调用后的结果必须返回</em></p><p>结合环绕通知后的执行顺序 ( 注解配置 )：</p><ul><li>正常执行：环绕前置→前置→目标代码→环绕返回→环绕后置→后置→返回</li><li>抛出异常：环绕前置→前置→目标代码→环绕异常→环绕后置→后置→返回<ul><li>这里因为环绕执行优先级较高，在环绕异常中处理之后普通异常通知就检测不到了，所以执行返回通知</li></ul></li></ul><h2 id="Spring-整合-Mybatis">Spring 整合 Mybatis</h2><h3 id="Spring-环境搭建">Spring 环境搭建</h3><p>Spring 整合 mybatis，利用 Spring 的控制反转，将 mybatis 实例化过程交给 IOC，首先就需要配置 Spring 环境</p><blockquote><p>导入Spring需要的maven依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>配置 Spring 注解开发环境，创建 <code>SpringConfig.xml</code> 配置文件，开启注解开发功能，并扫描所有被注解标注的类所在的包，可以自行创建一个实体类，用测试类来测试环境是否搭建成功</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;site.hanzhe&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Mybatis-环境搭建">Mybatis 环境搭建</h3><p>导入所需的 maven 依赖，依赖引入完毕后，去书写 <code>bean</code> <code>dao</code> <code>mapper</code>，配置文件稍后在写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.48<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="整合关键配置">整合关键配置</h3><p>Spring 整合 mybatis 需要额外导入几个 maven 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>spring-jdbc</code> 是 Spring 操作数据库必须的 jar 包</li><li><code>mybatis-spring</code> 是 2.0.3 版本的桥梁框架，实际开发中需要参考各种因素来决定桥梁 jar 包的版本</li></ul><table><thead><tr><th style="text-align:left">MyBatis-Spring</th><th style="text-align:left">MyBatis</th><th style="text-align:left">Spring 框架</th><th style="text-align:left">Spring Batch</th><th style="text-align:left">Java</th></tr></thead><tbody><tr><td style="text-align:left">2.0</td><td style="text-align:left">3.5+</td><td style="text-align:left">5.0+</td><td style="text-align:left">4.0+</td><td style="text-align:left">Java 8+</td></tr><tr><td style="text-align:left">1.3</td><td style="text-align:left">3.4+</td><td style="text-align:left">3.2.2+</td><td style="text-align:left">2.1+</td><td style="text-align:left">Java 6+</td></tr></tbody></table><hr />这个时开始书写 Spring 整合 mybatis 的配置文件，新建 Spring 的配置文件，起名为 `SpringMybatis.xml`<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置数据源--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///test&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zhang&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--配置mybatis动态代理的接口--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;site.hanzhe.dao&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--将mybatis整合到Spring中--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--将数据源配置到mybatis中，在配置映射文件路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mappers/*Mapper.xml&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--剩下的交给mybatis配置文件来处理--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在 Spring 整合 Mybatis 配置文件中共配置了一下几点：<ul><li>配置了数据源：连接数据库的信息，driver，url 等等</li><li>配置了 mybatis 动态代理的接口位置</li><li>配置了 SQLSessionFactoryBean 类，该类是 mybatis-spring 包下的类，在他下面配置了<ul><li>将数据源整合进了 mybatis 中</li><li>配置了 mapper 映射文件所在的目录</li><li>关联 mybatis 核心配置文件，将其他配置交给配置文件处理</li></ul></li></ul></li></ul><p><font color="red">需要注意！</font>需要使用 <code>import</code> 标签将 <code>SpringMybatis.xml</code> 导入到 <code>SpringConfig.xml</code> 中进行整合，也可以在一开始将两个配置文件的内容放在一起</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;SpringMybatis.xml&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><hr />创建 `mybatis-config.xml` 核心配置文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;site.hanzhe.bean&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>这里的配置几乎都是可选的，如果没有特殊要求，这个配置文件都可以省略不写</li></ul><h3 id="整合基本完成">整合基本完成</h3><p>因为使用了 spring 整合了 mybatis，之前 mybatis 中的复杂步骤此时全部省略掉了，直接调用接口就可以运行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:SpringConfig.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringTest1</span> &#123;<br>    <span class="hljs-meta">@Autowired</span> DeptDao dd;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(dd.findDept());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加事务管理">添加事务管理</h3><h4 id="场景模拟">场景模拟</h4><p>模仿一段转账的场景，A 向 B 转账 100 元钱，会经历大概几个步骤：</p><ul><li>先查询 A 的余额是否 &gt;= 100</li><li>符合条件后在数据库中将 A 的余额 - 100</li><li>( 这里处理一堆转账中途操作的逻辑，省略… )</li><li>最后在数据库中将 B 的余额 + 100</li></ul><p>上述模拟的转账场景，任何一个环节出错都会终止转账行为，但是可能会发生一种情况，如果在第三步发生了错误，程序抛出异常之后的任务不在执行，但是在异常抛出之前的第二步已经完成了扣款，这就导致了转账程序出现了 BUG</p><h4 id="事务控制回顾">事务控制回顾</h4><p>事务控制的四个 ACID 特性：</p><ul><li>原子性<ul><li>一组 sql 在一起执行，要么一起成功，要么一起失败！</li></ul></li><li>一致性<ul><li>例如转账，A 向 B 转了100元或者其他转账，无论 A 和 B 怎么转他俩的金额始终是那些</li></ul></li><li>隔离性<ul><li>多个 sql 同时操作一个资源，必须等第一个先操作完后续的才能继续操作</li></ul></li><li>持久性<ul><li>将数据永久存储到数据库中，而不是临时存储 (退出程序就消失)</li></ul></li></ul><h4 id="在整合中添加事务">在整合中添加事务</h4><p>在 spring 整合 mybatis 的配置文件中添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tx&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;tx&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;find*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span><span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;java.lang.Exception&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br><span class="hljs-comment">&lt;!--配置aop，将上面配置的事务管理器以横切的逻辑添加进去--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution( public * site.hanzhe.service.UserService.*(..) )&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>使用 bean 标签将 DataSourceTransactionManager 事务管理器装配到 IOC 容器中</p><ul><li>配置事务管理器中的 dataSource 属性来设置被他管理的数据源</li></ul></li><li><p>tx 是事务控制的名称空间，使用 <code>tx:advice</code> 标签来对符合条件的方法进行事务管理</p><ul><li>在标签上通过 id 属性来为该配置起名字，然后通过 transaction-manager 属性来选择事务管理器</li><li>使用 <code>tx:advice</code> 下的 <code>tx:attributes</code> 下的 <code>tx:method</code> 标签来进行方法筛选<ul><li><font color="red">name 属性</font>是被事务管理的方法名，可以使用 * 通配符进行模糊匹配</li><li><font color="red">propagation 属性</font>是事务的传播类型，是个枚举，常用选项有：<ul><li>REQUIRED： 方法必须在事务环境中运行，当前若有事务环境就加入，没有就新建，==是默认值==</li><li>SUPPORTS： 若有事务环境就加入运行，没有就以非事务环境运行</li><li>MANDATORY： 必须在事务中运行，若没有事务环境就会抛出异常</li></ul></li><li><font color="red">isolation 属性</font>是事务隔离级别</li><li><font color="red">read-only 属性</font>是只读设置，true 为只读</li><li><font color="red">rollback-for 属性</font>用来设置回滚的异常，如果发生的异常并不是指定的异常不会回滚</li></ul></li></ul></li><li><p>将事务管理配置好后，需要通过 aop 技术将事务逻辑横切进去，切面就是 <code>tx-advice</code> 的id</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序学习笔记</title>
    <link href="/2022/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>微信小程序学习笔记</h1><p>笔记开始于<code>2021-04-21</code>，开发者工具版本号为<code>1.05.2103200</code></p><p>官方文档地址：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></p><h2 id="入门小程序开发">入门小程序开发</h2><blockquote><p>前置准备</p></blockquote><p>首先要<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1">注册开发者账号</a>，之前注册过服务号之类也要再次注册，小程序不同于服务号需要单独注册</p><p>注册了小程序的开发者账号之后，<a href="https://mp.weixin.qq.com/">扫码登录小程序后台</a>（扫码登录时选择小程序测试号）找到<code>AppID</code>，后面会用到</p><p>之后<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">下载微信开发者工具</a>进行小程序的开发就可以了</p><blockquote><p>Hello world</p></blockquote><p>在小程序开发者工具中点击加号创建小程序，填写项目名称、项目目录以及前面的<code>AppID</code>即可</p><img src="/img/wx-app-01.png" style="zoom:70%;" /><p>点击新建后会自动生成一个HelloWorld的小程序，我们通过操作开发者工具可以直接进行预览</p><blockquote><p>微信开发者工具简单使用</p></blockquote><p>开发者工具使用详细教程可以参<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html">官方文档</a></p><p><strong>1.</strong> 在左上角用户头像的右侧有这样四个按钮开关，他们对应着页面显示内容，具体如下所示：</p><img src="/img/wx-app-02.png" /><ul><li>模拟器：左侧小程序预览界面</li><li>编辑器：右侧代码编写区域</li><li>调试器：右下角浏览器控制台</li><li>可视化：通过鼠标拖拽完成小程序页面的绘制，基本用不到…</li></ul><p><strong>2.</strong> 在四个开关按钮右侧有这样一栏，具体作用如下所示：</p><img src="/img/wx-app-03.png" /><ul><li>预览：点击预览后稍等会生成二维码，可以直接在手机微信上扫码查看效果</li><li>真机调试：除了手机端扫码预览之外还会在PC生成调试器，可以实时观测手机上的小程序，起到调试作用</li><li>清缓存：这个没必要说了，，，</li></ul><h2 id="小程序目录结构">小程序目录结构</h2><p>这里先了解一下小程序项目目录结构，了解一下每个文件分别是干什么的</p><img src="/img/wx-app-04.png" /><p>首先从<strong>根目录</strong>开始了解，将根目录这几个文件划分为三块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 这两个文件夹可自定义命名，没有强制要求，utils可以删除不要 */</span><br>|-pages   <span class="hljs-comment">// 这是页面文件夹，小程序中所有的页面都会放在该目录下</span><br>|-utils   <span class="hljs-comment">// 一些可复用的函数可以抽取为单独的JS文件放在该目录下，然后在其他页面中通过require引用</span><br>  |-util.<span class="hljs-property">js</span>  <span class="hljs-comment">// 目录下只有一个个的JS文件，这里就不单独说了</span><br>  |-abc.<span class="hljs-property">js</span> ...<br><br><span class="hljs-comment">/* 小程序的主体文件，必须存在且放在项目根目录 */</span><br>|-app.<span class="hljs-property">js</span>    <span class="hljs-comment">// JS逻辑代码</span><br>|-app.<span class="hljs-property">json</span>  <span class="hljs-comment">// 小程序的全局配置，例如小程序标题是什么，背景颜色是什么，有多少个page页面...</span><br>|-app.<span class="hljs-property">wxss</span>  <span class="hljs-comment">// 全局生效的CSS文件</span><br><br><span class="hljs-comment">/* 其他配置文件，可有可无 */</span><br>|-project.<span class="hljs-property">config</span>.<span class="hljs-property">json</span> <span class="hljs-comment">// 使用开发者工具每个人都有自定义的配置，这个是用来存储个性配置的文件，与项目无关</span><br>|-sitemap.<span class="hljs-property">json</span>        <span class="hljs-comment">// 微信搜索引擎的相关配置，具体参考官网</span><br></code></pre></td></tr></table></figure><p><code>utils</code>目录在上面已经解释过了，这里介绍一下<code>pages</code>目录</p><img src="/img/wx-app-05.png" /><p>可以看到，<code>pages</code>下有<code>index、logs</code>两个文件夹，两个文件夹下分为存放<code>js、json、wxml、wxss</code>四种类型的同名文件，这四种类型的同名文件被称为一个<em>Page页面</em>，将四个文件放在某个文件夹下，这个文件夹就可以看成一个<code>Page页面</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 写法与Angular有些类似，他将一个HTML页面拆分为四个文件分别写不同的代码 */</span><br>|-abc.<span class="hljs-property">js</span>    <span class="hljs-comment">// 主要写JS代码，处理页面取值等等业务逻辑</span><br>|-abc.<span class="hljs-property">wxml</span>  <span class="hljs-comment">// 主要写HTML代码，控制页面布局等等</span><br>|-abc.<span class="hljs-property">wxss</span>  <span class="hljs-comment">// 主要写CSS代码，用来美化页面布局</span><br>|-abc.<span class="hljs-property">json</span>  <span class="hljs-comment">// 当前页面的配置文件，优先级高于全局配置文件app.json</span><br></code></pre></td></tr></table></figure><h2 id="页面相关知识">页面相关知识</h2><h3 id="常用控件使用">常用控件使用</h3><h3 id="JS文件介绍">JS文件介绍</h3><h3 id="声明周期函数">声明周期函数</h3><h3 id="页面相关事件">页面相关事件</h3><p>单击事件（支持冒泡）：bindtap</p><p>单机事件（禁止冒泡）：catchtap</p><h2 id="页面表单操作">页面表单操作</h2><h2 id="路由页面跳转">路由页面跳转</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 保留当前页面跳转，跳转到下一页后会在左上角自动生成返回按钮</span><br>wx.<span class="hljs-title function_">navigateTo</span>()<br><span class="hljs-comment">// 销毁当前页面，跳转到下一页</span><br>wx.<span class="hljs-title function_">redirectTo</span>()<br><span class="hljs-comment">// 销毁所有页面，然后打开指定页面</span><br>wx.<span class="hljs-title function_">reLaunch</span>()<br></code></pre></td></tr></table></figure><h2 id="发起网络请求">发起网络请求</h2><h2 id="常用小程序API">常用小程序API</h2>]]></content>
    
    
    <categories>
      
      <category>小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swagger笔记</title>
    <link href="/2022/07/13/Swagger%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/13/Swagger%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>Swagger笔记</h1><p>现在市面上大多数公司都摒弃了传统 jsp 开发，采用前后端分离式的开发规则，前端使用 Vue，Angular，React 等等完成页面，后端省掉了视图跳转的过程，直接书写接口返回 json 数据供前端调用即可</p><p>这样一来就诞生了一个新的问题，后端程序员需要写一个接口文档来告诉前端开发人员都有那些接口，每个接口都是干什么的，需要那些参数等等。</p><p>书写接口文档是一件费时费力的活，而 Swagger 可以根据程序代码自动生成在线接口文档，==Swagger 是接口文档生成工具==</p><h2 id="整合Swagger">整合Swagger</h2><h3 id="导入依赖">导入依赖</h3><p>想要整合使用 Swagger 生成接口文档，首先我们需要引用 Swagger 的 maven 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Swagger依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 排除下面两个依赖，解决 For input string: &quot;&quot; 异常 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.swagger<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-models<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 单独引用版本偏低的两个依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.swagger<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.swagger<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-models<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- UI页面展示 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="启用Swagger">启用Swagger</h3><p>在引用 Swagger 的依赖后，我们还需要通过注解开启 Swagge 才可以实现接口文档</p><blockquote><p>新建一个配置类，通过 <code>@EnableSwagger2</code> 注解启用 Swagger：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span>   <span class="hljs-comment">// 开启Swagger</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="了解接口文档">了解接口文档</h3><p>Swagger 接口文档主要有四部分组成：</p><p>【分组信息】，【分组描述信息】，【接口描述信息】，【实体类信息】</p><p><img src="/img/swagger-01.jpg" alt=""></p><p>我们目前仅仅是引入了 Swagger 的依赖，开启 Swagger 功能之后如果没有配置的话，默认会使用 swagger 初始化的配置</p><h2 id="初始化分组">初始化分组</h2><p>我们想要使用自定义的分组信息，要在配置类提供一个 Docket 实例到 IOC 容器中，通过 Docket 实例设置分组名称，Swagger 会根据实例进行自定义设置。</p><blockquote><p>创建一个分组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 还是之前的配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;张涵哲的分组&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面使用 Swagger2 默认规则创建了一个 Docket 对象，定义分组名称为 <code>张涵哲的分组</code>，效果如图所示：</p><p><img src="/img/swagger-02.jpg" alt=""></p><blockquote><p>多分组配置</p></blockquote><p>如果想要创建多个分组，那么就在 IOC 容器中多提供几个 docket 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;张涵哲的分组&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;***的分组&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/swagger-03.jpg" alt=""></p><h2 id="配置分组详情">配置分组详情</h2><blockquote><p>配置分组描述</p></blockquote><p>我们已经可以创建多个分组了，但是我们可以发现，每个分组中都有一段描述信息，我们可以在每个分组下显示不同的描述信息，需要调用 Docket 的 <code>apiInfo()</code> 函数传入自定义的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;张涵哲的分组&quot;</span>)<br>                .apiInfo(apiInfo());<br>    &#125;<br> <span class="hljs-comment">// 创建一个函数用来返回 ApiInfo 实例</span><br>    <span class="hljs-comment">// 这里我只显示了部分信息，填写null的都是不显示的，如果想要全部显示可以填写所有的信息</span><br>    <span class="hljs-keyword">public</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Contact</span> <span class="hljs-variable">contact</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;张涵哲&quot;</span>, <span class="hljs-string">&quot;http://blog.hanzhe.club&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfo</span>(<br>                <span class="hljs-string">&quot;基于Swagger2.0练习&quot;</span>,<br>                <span class="hljs-string">&quot;基于程序中所有的接口提供帮助文档&quot;</span>,<br>                <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>                <span class="hljs-literal">null</span>,<br>                contact,<br>                <span class="hljs-literal">null</span>,<br>                <span class="hljs-literal">null</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们为 <code>张涵哲的分组</code> 配置了一段描述信息，接下来看看效果：</p><p><img src="/img/swagger-04.png" alt="image-20200812131813648"></p><p>可以看到分组的描述信息已经显示出来了。</p><blockquote><p>配置扫描范围</p></blockquote><p>当我们多个人同时开发一个程序时，就会使用多个分组，每个人对应这一个分组，其中每个分组都有自己的接口文档，这里需要配置分组接口显示</p><p>例：张涵哲负责开发用户相关的接口 <code>包位置：club.hanzhe.controller.user.UserController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>        .groupName(<span class="hljs-string">&quot;张涵哲的分组&quot;</span>)<br>        .apiInfo(apiInfo())<br>        <span class="hljs-comment">// select开始，build结束，apis用来过滤</span><br>        .select()<br>        .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;club.hanzhe.controller.user&quot;</span>))<br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来该分组下就只会显示固定的接口信息了，除开通过包扫描的方法之外还有其他的方法进行筛选：</p><p><code>RequestHandlerSelectors</code> 类中其他的静态函数：</p><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>any()</td><td>扫描全部接口</td></tr><tr><td>none()</td><td>不扫描</td></tr><tr><td>basePackage(String package)</td><td>根据给定的包的位置进行扫描</td></tr><tr><td>withClassAnnotation(Class annotation)</td><td>类上有对应注解会被扫描</td></tr><tr><td>withMethodAnnotation(Class annotation)</td><td>函数上有对应注解的会被扫描</td></tr></tbody></table><p>还可以通过路径进行过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>        .groupName(<span class="hljs-string">&quot;张涵哲的分组&quot;</span>)<br>        .apiInfo(apiInfo())<br>        <span class="hljs-comment">// select开始，build结束，paths用来过滤</span><br>        .select()<br>        .paths(PathSelectors.ant(<span class="hljs-string">&quot;/user/**&quot;</span>))<br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>PathSelectors</code> 类中其他的静态函数：</p><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>any()</td><td>扫描全部接口</td></tr><tr><td>none()</td><td>不扫描</td></tr><tr><td>ant(String path)</td><td>扫描指定路径</td></tr><tr><td>regex(String regex)</td><td>根据正则表达式过滤</td></tr></tbody></table><h2 id="接口信息配置">接口信息配置</h2><blockquote><p>简单接口显示</p></blockquote><p><img src="/img/swagger-05.jpg" alt=""></p><p>上面的图片是扫描到接口后默认生成的接口文档，Swagger 是以 <code>Controller</code> 为单位，对接口进行分组管理的，这个分组的元素在 Swagger 中称为 <code>Tag</code>，我们可以通过注解来修改一下接口文档，让他更人性化：</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Api(tags = “”)</td><td><strong>标注在类上</strong> 用来表明接口组，tags=组名</td></tr><tr><td>@ApiOperation(value = “”, notes = “”, tags=“”)</td><td><strong>标注在函数上</strong> value=标题，notes=描述，tags=分组</td></tr><tr><td>@ApiParam(“”)</td><td><strong>标注在参数列表中</strong> 表示当前参数代表的含义以及用法</td></tr></tbody></table><p>例如下面我们编辑一下当前的 UserController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags = &quot;User接口文档&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;查询所有user&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">getList</span><span class="hljs-params">()</span>&#123; ... &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;添加新的user信息&quot;, notes = &quot;传入用户信息进行封装user进行添加&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">addUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> UserBean user)</span>&#123; ... &#125;<br>    <br>    <span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;通过ID更新user信息&quot;, notes = &quot;路径传入ID，json传输修改信息&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">updateUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span>Long id, <span class="hljs-meta">@RequestBody</span> UserBean user)</span>&#123;<br>     ...<br>    &#125;<br>    <br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;通过ID删除user信息&quot;, notes = &quot;路径传入ID进行删除&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;删除的目标ID&quot;)</span><span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;<br>        ...<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下图所示：</p><p><img src="/img/swagger-06.jpg" alt=""></p><blockquote><p>跨组显示接口</p></blockquote><p>之前有说过，Swagger 默认是按照每个 Controller 为一个分组显示接口的，那么如果我们其中一个 Controlle 执行时需要另个 Controller 的某个接口配合，这时我们当前分组就要支持显示其他分组信息。</p><p>**1.**员工的分组接口除了本身的增删改查之外还要查询携带查询所有部门信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags = &quot;部门接口&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/dept&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span>    <span class="hljs-comment">// tags 是一个数组，可以制定多个分组同时显示</span><br>    <span class="hljs-meta">@ApiOperation( value = &quot;查询所有部门&quot;, tags = &#123;&quot;部门接口&quot;, &quot;员工接口&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getList</span><span class="hljs-params">()</span>&#123; &#125;<br>    <br>    <span class="hljs-comment">// .... 省略其他接口</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="/img/swagger-07.jpg" alt=""></p><blockquote><p>通过已有的接口新建一个分组</p></blockquote><p>除了接口跨分组显示之外，还可以在多个不同的接口中指向同一个不存在的分组，Swagger 会新建一个分组来展示这些接口信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags = &quot;员工接口&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;通过ID删除user信息&quot;, </span><br><span class="hljs-meta">                  notes = &quot;路径传入ID进行删除&quot;, tags = &quot;删除操作相关接口&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;删除的目标ID&quot;)</span><span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags = &quot;部门接口&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/dept&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptController</span> &#123;<br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;通过ID删除部门&quot;, tags = &quot;删除操作相关接口&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;删除的目标ID&quot;)</span><span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/swagger-08.jpg" alt=""></p><h2 id="实体类信息配置">实体类信息配置</h2><p>我们在开始的时候就 Swagger 接口文档由 <code>分组</code>，<code>分组描述信息</code>，<code>接口信息</code>，<code>实体类信息</code> 四部分组成，前三种我们已经使用过了，接下来我们就要学习使用配置类信息</p><p>当我们需要完成类似添加操作的时候，如果需要的参数过多，使用 @ApiParam 注解就会太过臃肿，直接封装为实体类又要解释每个字段都是干什么的，是什么类型，接口显示也过于繁琐，所以我们可以将实体类直接显示在文档中，当时用到该实体类时在底部翻找属性对应参数即可，一个实体类可以对应 N 多个接口，一劳永逸</p><blockquote><p>实体类的配置</p></blockquote><p>配置实体类十分的简单，只需要使用两个注解就可以完成基本操作：</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@ApiModel()</td><td>实体类名称</td></tr><tr><td>@ApiModelProperty()</td><td>实体类中每个字段代表的含义解释</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@ApiModel(&quot;员工实体类&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBean</span> &#123;<br><br>    <span class="hljs-meta">@ApiModelProperty(&quot;员工ID，用来识别员工的唯一表示，不可重复。&quot;)</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;员工姓名&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;员工年龄&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>效果如图所示：</p><p><img src="/img/swagger-09.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>api文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS8 部署服务器环境</title>
    <link href="/2022/07/13/CentOS8%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83/"/>
    <url>/2022/07/13/CentOS8%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1>CentOS8 部署服务器环境</h1><h2 id="远程连接服务器">远程连接服务器</h2><p>连接服务器使用的是 xshell 工具，百度下载即可</p><p>如果你的服务器是购买的 ( 例如阿里 )，需要去你服务器的安全组进行端口放行才可以使用，详情百度，我这里是新建的 centos 8 的虚拟机，通过虚拟机模拟真实的服务器，想要连接虚拟机需要使用指定命令获取 ip 地址</p><h3 id="获取-IP-地址">获取 IP 地址</h3><p>( 已购买服务器用户可以跳过，可以看看如何设置安全组开放端口 )</p><p>因为购买服务器会给一条外网 ip 地址，但虚拟机创建是不会告诉你 ip 地址的，所以需要自己手动运行虚拟机进行获取，使用命令 <code>ifconfig</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@192 ~]<span class="hljs-comment"># ifconfig</span><br>ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.0.105  netmask 255.255.255.0  broadcast 192.168.0.255<br>        inet6 fe80::a234:dff6:40db:cb50  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether 00:0c:29:5f:11:17  txqueuelen 1000  (Ethernet)<br>        RX packets 17256  bytes 20130010 (19.1 MiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 4184  bytes 360390 (351.9 KiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;<br>        loop  txqueuelen 1000  (Local Loopback)<br>        RX packets 52  bytes 4320 (4.2 KiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 52  bytes 4320 (4.2 KiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500<br>        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255<br>        ether 52:54:00:da:e0:e9  txqueuelen 1000  (Ethernet)<br>        RX packets 0  bytes 0 (0.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br></code></pre></td></tr></table></figure><p>这里可以看到，我使用了 <code>ifconfig</code> 命令后，下面列出了三个 ip 地址，分别是 <code>192.168.0.105</code>，<code>127.0.0.1</code>，<code>192.168.122.1</code>，筛选后得出我的 ip 地址为 <code>192.168.0.105</code></p><p>双击打开 shell，依次点击【文件】【新建】，然后在弹出的页面左侧选择【连接】，右侧填写服务器信息即可</p><p><img src="https://s2.loli.net/2024/01/06/JoNdYBrKv7O1PcD.png" alt="WindTerm"><br>点击确定后，左侧就会出现你刚刚新建的回话，双击连接，输入用户名和密码就可以操作服务器了，建议用 root 用户登录防止出现权限问题等等。</p><blockquote><p>CentOS 7 注意事项</p></blockquote><p>如果使用的是 centos7 的话查看 ip 地址的命令为 <code>ip addr</code>，结果如下所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#ip addr</span><br><span class="hljs-attribute">1</span>: lnk/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br>    <span class="hljs-attribute">inet</span> <span class="hljs-number">127.0.0.1</span>/<span class="hljs-number">8</span> scope host lo<br>       <span class="hljs-attribute">valid_lft</span> forever preferred_lft forever<br>    <span class="hljs-attribute">inet6</span> ::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> scope host<br>       <span class="hljs-attribute">valid_lft</span> forever preferred_lft forever<br><span class="hljs-attribute">2</span>: enp2s1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="hljs-number">1500</span> qdisc mq state UP group default qlen <span class="hljs-number">1000</span><br>    <span class="hljs-attribute">link</span>/ether <span class="hljs-number">00</span>:<span class="hljs-number">17</span>:<span class="hljs-number">08</span>:<span class="hljs-number">49</span>:<span class="hljs-number">9</span>d:c5 brd ff:ff:ff:ff:ff:ff<br></code></pre></td></tr></table></figure><p>2: 后面跟着的 <code>ens33</code> 就是网卡名称，我们可以通过 <code>ifup ens33</code> 来开启网卡，就可以访问网络，但是每次开机都需要手动开启网卡比较麻烦，所以我们需要设置网卡开机自启：</p><p>在 centos7 的<code>/etc/sysconfig/network-scripts</code> 目录下，有一个 <code>ifcfg-网卡名称</code> 的文件，使用 vim 打开该文件将 <code>ONBOOT=no</code> 改为 <code>yes</code>，网卡就可以开机自启动了</p><h3 id="防火墙设置">防火墙设置</h3><p>如果 IP 地址输入正确，用户名密码也没问题，但还是连不上，那么可能就是防火墙给拦截了，打开虚拟机修改防火墙配置</p><blockquote><p>CentOS 操作防火墙常用命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看防火墙状态，running是运行中，not running是停止中</span><br>firewall-cmd --state<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开防火墙</span><br>systemctl start firewalld.service<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭防火墙</span><br>systemctl stop firewalld.service<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有开放的端口-ports</span><br>firewall-cmd --list-all<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询指定端口开放状态 <span class="hljs-built_in">yes</span>开启，no关闭</span><br>firewall-cmd --query-port=22/tcp<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开放/关闭 指定端口 -- premanent代表永远生效，如果不携带该参数则仅本次有效</span><br>firewall-cmd --add-port=22/tcp --permanent<br>firewall-cmd --remove-port=22/tcp --permanent<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启防火墙服务 -- 端口状态修改后重启生效</span><br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>了解了以上命令后，就可以将端口开放了，这里只开放 22 剩下随用随开即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --add-port=22/tcp --permanent<br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><h2 id="部署-JDK-8">部署 JDK 8</h2><p>百度 Oracle 下载 jdk8 Linux 版本，在 Oracle 官网针对 Linux 版本的 jdk 提供了四种文件包，除了咱们熟悉的 x86 和 x64 之外，还有 rpm 和 tar.gz 的文件，这里我选择了 tar.gz 压缩文件进行安装配置</p><p>首先将 tar.gz 文件下载到本地，然后在下载另一个远程操作软件 xftp，它的功能类似 xshell，不过 xshell 是用来模拟终端的，而 xftp 是用来传输文件的，下载好 xftp 后双击打开</p><p>依次按照顺序点击左上角的【文件】【新建】，填写信息于 xshell 基本一致，协议的位置选择 <code>SFTP</code> ，然后在下面将用户名和密码直接填入即可</p><p>然后连接服务器，将之前下载好的 tar.gz 文件拖拽到服务器 ( 右侧窗口 ) 上传至如下目录，然后解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文件上传目录</span><br>/usr/local<br></code></pre></td></tr></table></figure><ul><li>这里补充一个小技巧，如果 xftp 显示中文文件名乱码的话，按照如下顺序走一遍即可<ul><li>选中当前连接【文件】【属性】上方选项卡【选项】勾选【使用 UTF-8 编码】| 完成</li></ul></li></ul><blockquote><p>Xshell 下操作</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">移动位置到当前目录</span><br>cd /usr/local<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压文件</span><br>tar -zxvf jdk-8u181-linux-x64.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将文件重命名为简单的名称</span><br>mv jdk1.8.0_181 jdk8<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除掉无用的 tar.gz 文件</span><br>rm -rf jdk-8u181-linux-x64.tar.gz<br></code></pre></td></tr></table></figure><p>截止到目前，Java 已经安装完毕了，这个没有安装过程，解压他的过程就是安装，接下来是配置环境变量，切换目录到 <code>etc</code> 下使用 xshell 操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">切换目录</span><br>cd /etc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用vim编辑器编辑配置文件，增加环境变量</span><br>vim profile<br></code></pre></td></tr></table></figure><p>输入以上命令后，就会看到配置文件的详细信息，翻到文件最底部敲击字母 i，下方会提示插入模式，然后在最底下编写代码，添加 jdk 的环境变量，代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-variable constant_">JAVA_HOME</span>=<span class="hljs-regexp">/usr/</span>local/jdk8<br><span class="hljs-keyword">export</span> <span class="hljs-variable constant_">PATH</span>=<span class="hljs-attr">$PATH</span>:$JAVA_HOME/bin<br><span class="hljs-keyword">export</span> <span class="hljs-variable constant_">CLASSPATH</span>=.:$JAVA_HOME/lib/dt.<span class="hljs-property">jar</span>:$JAVA_HOME/lib/tools.<span class="hljs-property">jar</span><br><span class="hljs-keyword">export</span> <span class="hljs-variable constant_">JRE_HOME</span>=$JAVA_HOME/jre<br></code></pre></td></tr></table></figure><ul><li>需要注意的是在输入 jdk8 的时候，小键盘数字键是不能用的</li></ul><p>编写完成后，敲击键盘左上角的 <code>esc</code> 退出编辑模式，此时你处于命令模式，然后敲击 <code>:wq</code> ( 保存并退出 ) 然后回车即可。配置文件就搞定了，然后输入命令刷新环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更新资源文件</span><br>source profile<br></code></pre></td></tr></table></figure><p>接下来就像在 Windows 中一样输入 <code>javac</code>，<code>java</code>，<code>java -version</code> 来测试 jdk 有没有安装成功吧</p><blockquote><p>– 补充</p></blockquote><p>当我们在 Windows 中将打包好的 springboot 的 jar 包放在 centos 中运行的时候，会发现他启动的特别慢，这个时候我们就需要更改一些配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑JDK下的指定文件</span><br>vim /usr/local/jdk8/jre/lib/security/java.security<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改 securerandom.source 的值为如下所示</span><br>securerandom.source=file:/dev/urandom<br></code></pre></td></tr></table></figure><h2 id="部署-Tomcat-8-5">部署 Tomcat 8.5</h2><p>安装 tomcat 同 jdk 一样，首先是去官网下载指定版本的 tomcat 的压缩包，然后上传至服务器等等操作</p><blockquote><p>tomcat 8.5 下载地址，记着选择 tar.gz 的 Linux 版本</p></blockquote><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">https:</span>//tomcat.apache<span class="hljs-meta">.org</span>/download<span class="hljs-number">-80.</span>cgi<br></code></pre></td></tr></table></figure><p>下载完成后，使用 XFTP 工具将压缩包上传至服务器的 <code>/usr/local</code> 目录下，然后在 xshell  中操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">解压tomcat包</span><br>tar -zxvf apache-tomcat-8.5.55.tar.gz<br></code></pre></td></tr></table></figure><p>解压之后就已经算是安装完成了，可以 cd 到 tomcat 目录下，执行命令检查是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动tomcat服务</span><br>startup.sh<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭tomcat服务</span><br>shutdown.sh<br></code></pre></td></tr></table></figure><p>启动后通过 ip 地址 + 8080 端口号是可以访问到网站的，如果访问失败可以尝试开放防火墙 8080 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=8080/tcp --permanent<br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><blockquote><p>环境变量配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc<br>vim profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在insert模式下追加段代码</span><br>export CATALINA_HOME=/usr/local/tomcat/apache-tomcat-8.5.31<br>export PATH=$PATH:$CATALINA_HOME/bin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后保存刷新即可</span><br>source profile<br></code></pre></td></tr></table></figure><h2 id="部署-MySQL">部署 MySQL</h2><h3 id="下载及安装">下载及安装</h3><p>之前的环境都是下载好然后进行离线安装的，不过这次的 mysql 的安装是需要联网的，研究了一下午离线安装没有成功…妥协了 ( &gt;_&lt; )，毕竟我也是第一次</p><p>首先去 mysql 官网下载安装所需要的 rpm 包，官网直连地址：</p><blockquote><p>我安装的是 5.7.30 下的 Red Hat 下的 Linux 7，在下面选择第一个 RPM Bundle 下载到本地即可。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>dev.mysql.com<span class="hljs-regexp">/downloads/my</span>sql/<br></code></pre></td></tr></table></figure><p>下载完成后远程连接你的 服务器 / 虚拟机，cd 至 <code>usr/local/</code> 目录下新建一个文件夹，将你下载好的文件上传到新建文件夹中，然后开始解压，命令如下</p><blockquote><p>因为他没有给文件包一层目录，所以这里我选择了新建一个文件夹，这样解压后文件就不会乱</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">新建文件夹</span><br>mkdir /usr/local/abc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">移动到目标文件夹</span><br>cd /usr/local/abc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上传文件后，进行解压</span><br>tar -xvf mysql-5.7.30-1.el7.x86_64.rpm-bundle.tar<br></code></pre></td></tr></table></figure><hr />> 接下来准备安装环境，依次运行以下命令安装依赖<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装三个依赖</span><br>yum -y install libaio perl net-tools<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">依赖检测失败：libncurses.so.5()(64bit) 被 ... 需要</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个可以先不执行，等安装报错在安装也可以</span><br>dnf install ncurses-compat-libs<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检查系统是否自带了mariadb，如有就卸载，会影响安装</span><br>rpm -qa|grep mariadb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载命令</span><br>rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64<br></code></pre></td></tr></table></figure><blockquote><p>依赖安装完成后，在解压好的目录下，开始安装 rpm 包：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -ivh mysql-community-common-5.7.30-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-libs-5.7.30-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-client-5.7.30-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-server-5.7.30-1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><p>依次安装完成后启动 mysql 服务，检测是否安装成功，如果提示 avive (running) 即为安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动mysql服务</span><br>service mysqld start<br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查mysql启动状态</span><br>service mysqld status<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果提示 avive (running) 即为安装成功</span><br>[root@localhost mysql-cache]# service mysqld start<br>Redirecting to /bin/systemctl start mysqld.service<br>[root@localhost mysql-cache]# service mysqld status<br>Redirecting to /bin/systemctl status mysqld.service<br>● mysqld.service - MySQL Server<br>   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)<br>   Active: active (running) since Wed 2020-06-03 02:03:49 CST; 5s ago<br>     Docs: man:mysqld(8)<br>           http://dev.mysql.com/doc/refman/en/using-systemd.html<br>  Process: 14149 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $M&gt;<br>  Process: 14123 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)<br> Main PID: 14152 (mysqld)<br>    Tasks: 27 (limit: 11362)<br>   Memory: 248.5M<br>   CGroup: /system.slice/mysqld.service<br>           └─14152 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid<br></code></pre></td></tr></table></figure><blockquote><p>centos 下对 mysql 服务的操作命令 ( 其实在 linux 中，服务不叫服务，叫做守护进程 )：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 mysql 服务</span><br>service mysqld start<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭 mysql 服务</span><br>service mysqld stop<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启 mysql 服务</span><br>service mysqld restart<br></code></pre></td></tr></table></figure><h3 id="配置-MySQL">配置 MySQL</h3><p>在上面我们已经成功的安装了 mysql 5.7.30，接下来只需要进行一些后续的处理，这个 mysql 数据库就可以正常使用了。</p><blockquote><p>修改配置文件</p></blockquote><p>由 rpm 命令安装的 mysql，他的配置文件位于 <code>/etc/my.cnf</code> 处，在尾部加上这样两句命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 个人配置，可选择性跳过 ##</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭密码安全策略验证</span><br>validate-password=OFF<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭表名区分大小写 0为区分，1为不区分</span><br>lower_case_table_names=1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置字符集</span><br>character-set-server=utf8<br></code></pre></td></tr></table></figure><ul><li>注：每次修改完配置文件后都要重启服务才能生效</li></ul><blockquote><p>设置 root 密码</p></blockquote><p>想要设置 root 密码，首先要先登录 mysql 数据库，但是没有密码怎么登录？其实在我们安装 mysql 的时候已经为我们生成了一个临时的密码，查看密码的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">最后的一串像乱码一样的东西就是临时密码</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者使用 <span class="hljs-built_in">cat</span> /var/log/mysqld.log 命令看前几行第一个 [Note] 的位置</span><br>grep password /var/log/mysqld.log<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2020-06-02T20:37:30.623479Z 1 [Note] A temporary password is generated <span class="hljs-keyword">for</span> root@localhost: ,mhLlwzx&gt;5g!</span><br></code></pre></td></tr></table></figure><p>使用这个临时的密码登录 mysql 的 root 用户后，第一件事儿就是修改他的密码，命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 如果你之前没有取消密码安全策略，那么这里就要想一个绝妙的密码</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> password <span class="hljs-operator">=</span> password(&quot;你的密码&quot;);<br></code></pre></td></tr></table></figure><p>密码修改完成后，你就可以正常使用你的数据库啦，但是还有点收尾工作要做 ↓ ↓ ↓</p><blockquote><p>开放防火墙 3306 端口，配置远程连接数据库</p></blockquote><p>现在的数据库仅仅在本地能够正常使用，但是如果想要在自己的电脑上远程操作数据库，还需要进行一些配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开放防火墙 3306 端口</span><br>firewall-cmd --add-port=3306/tcp --permanent<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启防火墙服务</span><br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>开放 3306 端口后，你会发现还是不能远程访问你的数据库，因为你还需要最后一步：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 进入mysql中执行以下命令 ( 在这里也是需要验证密码安全策略的 )</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;你的密码&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br></code></pre></td></tr></table></figure><p>至此！mysql 算是安装配置完成了，当然这个很简陋，真实服务器环境上配置的数据库比这个还要复杂，涉及到用户组和权限管理的问题，但是我这里只是练习用，就不写那么多了。</p><h2 id="部署-Redis">部署 Redis</h2><blockquote><p>redis 的下载</p></blockquote><p>首先要去 redis 的官网下载他的压缩包，官网 [ 中文 ] 直连地址如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.redis.cn/</span><br></code></pre></td></tr></table></figure><p>进入官网后直接下载即可，然后远程连接 服务器/虚拟机 将下载好的文件上传至 <code>/usr/local</code> 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入到usr/local目录</span><br>cd /usr/local<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上传文件后，执行解压命令</span><br>tar -zxvf redis-5.0.5.tar.gz<br></code></pre></td></tr></table></figure><blockquote><p>redis 的安装</p></blockquote><p>在执行安装命令之前，首选需要安装 gcc 的依赖，如已安装请忽略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install gcc<br></code></pre></td></tr></table></figure><p>然后切换到 redis 目录下开始执行安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">切换目录到redis下</span><br>cd redis-5.0.5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行安装命令</span><br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>这样一来，安装就顺利结束了，如果提示 -bash: make: command not found 则代表 gcc 没有装，需要重新安装 gcc 环境</p><blockquote><p>redis 的配置</p></blockquote><p>实际上这个时候 redis 已经可以正常运行了，但是直接执行运行的是默认的配置，我们需要有一套自己的配置，所以这个时候我们需要修改一下配置文件，这里建议复制一个作为备份，然后在修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">新建目录并进入</span><br>mkdir my_config<br>cd my_config<br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制配置文件</span><br>cp ../redis.conf redis.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑配置文件信息</span><br>vim redis.conf<br></code></pre></td></tr></table></figure><p>在配置文件中修改以下两行即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注释掉<span class="hljs-built_in">bind</span>，取消访问redis的ip地址限制，否则只有本机才能访问</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">bind</span> 127.0.0.1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改为 <span class="hljs-built_in">yes</span>，可以后台运行redis，否则会锁定命令行</span><br>daemonize yes<br></code></pre></td></tr></table></figure><blockquote><p>运行 redis 并创建连接</p></blockquote><p>好了，redis 的安装基本完成了，而且我们也有了属于自己的配置文件，接下来让我们来运行一下 redis，在运行 redis 之前，我们需要知道，redis 有两个可以启动的程序，一个是服务端，一个是客户端</p><p>首先我们来运行服务端 <code>redis-sever</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果直接输入则使用默认配置</span><br>redis-server<br><span class="hljs-comment"># 可以在后面追加配置文件名称，让他按照指定的配置启动，这里就让他以咱自定义的配置启动</span><br>redis-server redis.conf<br></code></pre></td></tr></table></figure><p>接下来让我们启动客户端 <code>redis-cli</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果直接输入则默认连接本地的6379端口</span><br>redis-cli<br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以通过参数来指定目标IP地址或端口号</span><br>redis-cli -h 127.0.0.1 -p 6379<br></code></pre></td></tr></table></figure><p>尝试输入一个 ping 命令，测试服务是否正常工作，如果返回 PONG 就证明一切正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; ping<br>PONG<br></code></pre></td></tr></table></figure><blockquote><p>关闭 redis</p></blockquote><p>如果不时用任何配置让他默认启动的话，直接 Ctrl + C 就可以关闭 redis，那么后台运行应该怎么关？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 连接到指定的服务后，执行关闭命令即可</span><br>redis-cli<br>shutdown<br><span class="hljs-comment"># 也可以直接关闭，或者指定IP,端口关闭</span><br>redis-cli shutdown<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx简单使用</title>
    <link href="/2022/07/13/Nginx%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/13/Nginx%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>Nginx 笔记</h1><p>Nginx 是一款高性能的 web 反向代理服务器，常用与配置集群以及负载均衡</p><h2 id="安装配置-Nginx">安装配置 Nginx</h2><blockquote><p>下载安装</p></blockquote><p><strong>1.</strong> 需要访问 <a href="http://nginx.org/">nginx官网</a>下载最新压缩包，也可以到<a href="http://nginx.org/download/">历史版本</a>中选择下载，这里选择的是<code>nginx-1.19.0.tar.gz</code></p><p><strong>2.</strong> 想要安装 nginx 需要一些依赖，远程连接你的服务器后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 nginx 的依赖</span><br>yum -y install pcre-devel zlib-devel<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果你的服务器已安装 gcc 环境，那么这步就可以省略</span><br>yum -y install gcc automake autoconf libtool make<br></code></pre></td></tr></table></figure><p><strong>3.</strong> 环境到这里就准备完毕了，接下来准备安装 nginx，将之前下载好的压缩文件上传至服务器中，然后解压，上传步骤这里就不赘述了，直接开始解压安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">移动目录至<span class="hljs-built_in">local</span>下，然后上传nginx安装包</span><br>cd /usr/local<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压上传的压缩文件</span><br>tar -zxvf nginx-1.19.0.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">移动目录到解压好的文件中</span><br>cd nginx-1.19.0<br></code></pre></td></tr></table></figure><p><strong>4.</strong> 接下来准备编译安装，在解压好的<code>nginx-1.19.0</code>目录中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检查压缩包，生成Makefile文件</span><br>./configure<br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行安装方法</span><br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p><strong>5.</strong> 执行结束后移动目录到<code>/usr/local</code>会发现目录中多了一个<code>nginx</code>文件夹，文件夹内是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZbp1abebnnglcdjsmbh8tZ /]# cd /usr/local/nginx<br>[root@iZbp1abebnnglcdjsmbh8tZ nginx]# ls<br>conf  html  logs  sbin<br></code></pre></td></tr></table></figure><p>这样 nginx 就安装就完成了，我们可以看到 nginx 目录下有四个文件夹：</p><ul><li><code>conf</code>：存放 nginx 的配置文件</li><li><code>html</code>：基本的 html 页面，比如 nginx 的欢迎页 <code>index.html</code> 就在这个目录下</li><li><code>logs</code>：看名字就知道是存放运行日志的文件夹了</li><li><code>sbin</code>：该目录下只有一个<code>nginx</code>文件，我们所有的命令都是靠这个文件运行的</li></ul><blockquote><p>运行 nginx</p></blockquote><p>运行 nginx 需要进入到 sbin 目录下执行 nginx 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入sbin目录</span><br>[root@iZbp1abebnnglcdjsmbh8tZ nginx]# cd sbin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 nginx</span><br>[root@iZbp1abebnnglcdjsmbh8tZ sbin]# ./nginx<br></code></pre></td></tr></table></figure><p>如果没有任何返回就代表运行成功了，nginx 默认在 80 端口运行，访问一下就可以看到效果了</p><blockquote><p>配置环境变量</p></blockquote><p>我们每次操作 nginx 都要移动到 sbin 目录下然后还要加<code>./</code>才能调用命令，比较麻烦，这里将 nginx 配置到环境变量中方便日后操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑profile配置文件</span><br>[root@iZbp1abebnnglcdjsmbh8tZ sbin]# vim /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件的最下面添加Nginx的环境变量，添加完成后 :wq 退出即可</span><br>export PATH=$PATH:/usr/local/nginx/sbin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">刷新环境变量</span><br>[root@iZbp1abebnnglcdjsmbh8tZ sbin]# souece /etc/profile<br></code></pre></td></tr></table></figure><p>操作完成后就可以在任何地方都可以调用 nginx 命令了</p><blockquote><p>Nginx 常用命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动nginx</span><br>nginx<br><span class="hljs-meta prompt_"># </span><span class="language-bash">快速停止nginx</span><br>nginx -s stop<br><span class="hljs-meta prompt_"># </span><span class="language-bash">完整有序的停止nginx</span><br>nginx -s quit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看nginx是否运行</span><br>ps -ef | grep nginx<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 nginx 版本</span><br>nginx -v<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看配置文件是否有误</span><br>nginx -t<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新载入配置</span><br>nginx -s reload<br></code></pre></td></tr></table></figure><h2 id="配置文件预览">配置文件预览</h2><p>在 nginx 目录下的 conf 目录中，有一个<code>nginx.conf</code>文件，它就是 nginx 的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">全局配置模块</span><br>user nobody;        # 配置用户或者组，默认为nobody<br>worker_processes 1; # 允许生成的进程数，默认为1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定nginx进程运行文件存放地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pid /nginx/pid/nginx.pid;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定日志路径，级别。全局、http、server都可以使用，级别以此为：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">debug|info|notice|warn|error|crit|alert|emerg</span><br>error_log log/error.log debug;<br>events &#123;<br>    # events模块<br>    #use epoll;  # 事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport<br>    accept_mutex on;  # 设置网路连接序列化，防止惊群现象发生，默认为on<br>    multi_accept on;  # 设置一个进程是否同时接受多个网络连接，默认为off<br>    worker_connections 1024;  # 最大连接数，默认为512<br>&#125;<br>http &#123;<br>    include       mime.types;   #文件扩展名与文件类型映射表<br>    default_type  application/octet-stream; #默认文件类型，默认为text/plain<br>    #access_log off; #取消服务日志    <br>    log_format myFormat &#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;; #自定义格式<br>    access_log log/access.log myFormat;  #combined为日志格式的默认值<br>    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。<br>    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。<br>    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。<br><br>    upstream mysvr &#123;   <br>      server 127.0.0.1:7878;<br>      server 192.168.10.121:3333 backup;  #热备<br>    &#125;<br>    error_page 404 https://www.baidu.com; #错误页<br>    server &#123;<br>        keepalive_requests 120; #单连接请求上限次数。<br>        listen       4545;   #监听端口<br>        server_name  127.0.0.1;   #监听地址       <br>        location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。<br>           #root path;  #根目录<br>           #index vv.txt;  #设置默认页<br>           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表<br>           deny 127.0.0.1;  #拒绝的ip<br>           allow 172.18.5.54; #允许的ip           <br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反向代理">反向代理</h2><p>在了解反向代理之前，首先要了解代理模式，最常用的就是科学上网，这里用两张图说明：</p><p><img src="/img/nginx-01.jpg" alt=""></p><p>类似上面就是我们正常访问一个网站的请求，如图访问 Google 肯定是访问不了的，我们就需要挂代理：</p><p><img src="/img/nginx-02.jpg" alt=""></p><p>这种代理服务器是安放在我们客户端这一方的，服务器并不知道我们的请求经过了代理，反向代理则刚好相反：</p><p><img src="/img/nginx-03.jpg" alt=""></p><p>反向代理我们请求的仅仅是代理服务器，至于请求最后究竟发送到哪里客户端不知道</p><blockquote><p>如何使用反向代理</p></blockquote><p>在 nginx 的安装目录下，有一个<code>conf</code>目录，改目录下的<code>nginx.conf</code>配置文件中的 http 模块下，可以通过 server 设置反向代理，他的标准写法是这个样子的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>listen       80;<br>server_name  www.baidu.com;<br>location / &#123;<br>    proxy_pass  http://220.181.38.148/;<br>    index       index.html;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>server 表示一个监听的目标</p><ul><li>listen [ 监听条件1 ] 可以是端口号，可以是 ip 地址，也可以是 ip 地址+端口号，也可以使用通配符 *</li><li>server_name [ 监听条件2 ] 可以是一个域名，也可以是多个域名 ( 逗号分隔 )，也可以使用通配符 *</li><li>location [ 监听条件3 ] 后面跟着一个空格，接着是一个url，例如 /blog/，/shop/ 等等区分项目路径，可以使用通配符，也可以使用正则表达式<ul><li>proxy_pass [ 目标地址 ]  符合监听条件后跳转的目标地址</li><li>index [ 默认首页 ] 跳转的目标项目路径，可以通过这里设置默认首页，一般不常用</li></ul></li></ul></li><li><p>关于配置具体参考网站：<code>https://www.cnblogs.com/ysocean/p/9392908.html</code></p></li></ul><p>在配置文件中可以有多个 server 出现，nginx 会从上到下依次监听，当符合某一个的时候就不会继续往下走。</p><blockquote><p>反向代理可以干些什么</p></blockquote><p>我在服务器上部署了两个应用要求必须都通过 80 端口直接访问，可是 80 端口只有一个，这个时候就可以通过反向代理来配置，例如</p><p>blog.hanzhe.site -&gt; 访问博客网站 ( 博客网站在本地的8081端口 )</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span>       localhost:<span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span>  blog.hanzhe.site;<br><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://localhost:8081/;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>zhang.hanzhe.site -&gt; 访问个人网站 ( 个人网站在本地的8082端口 )</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span>       localhost:<span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span>  zhang.hanzhe.site;<br><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://localhost:8082/;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，当我访问 blog.hanzhe.site 的时候，访问的是博客网站，访问 zhang.hanzhe.site 的时候访问的是个人网站，都是 80 端口，但是对应本地确实两个不一样的端口</p><h2 id="负载均衡">负载均衡</h2><h3 id="负载均衡的实现">负载均衡的实现</h3><blockquote><p>什么是负载均衡</p></blockquote><p>反向代理技术是 nginx 的特点之一，那么<code>负载均衡</code>就是第二大特点，什么是负载均衡？顾名思义，负载均衡就是讲服务器接收的请求分散开来，从而达到减缓服务器压力的一门技术</p><p>既然将请求分散开来，那么就肯定还要有服务器来接受这些分散出去的请求，所以就需要多台服务器进行配合，按照要求轮流来负责处理请求，那么将这些请求合理的分发出去的技术就叫做 负载均衡</p><blockquote><p>实现负载均衡</p></blockquote><p>还是老位置，nginx 的安装目录下的 conf 目录下的 nginx.conf 配置文件中使用 upstream 来完成负载均衡</p><p>upstream 后面跟着标识符作为名称，然后下面可书写 n 多个 server 指向目标地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream blog &#123;<br>server 127.0.0.1:8080;<br>server 127.0.0.1:8081;<br>server 127.0.0.1:8082;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里匹配到 <a href="http://blog.hanzhe.com:80">blog.hanzhe.com:80</a> 域名之后，直接移交给上面 blog 对应的负载均衡进行处理，会按照特定的规则来分发请求。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span>      <span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span> blog.hanzhe.com;<br><span class="hljs-section">location</span> / &#123;<br><span class="hljs-attribute">proxy_pass</span>  http://blog;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="集中方式说明">集中方式说明</h3><p>在上面提到了负载均衡会按照特定的规则来向各个服务器中分发请求，那么这个规则究竟是什么，现在就来简单了解一下。</p><blockquote><p>1 - 轮询规则</p></blockquote><p>轮询规则是 nginx 默认的负载规则，当我们书写的格式像上面的代码一样，没有多余的修饰，那么他默认就是轮询规则</p><p>轮询规则，顾名思义，就是所有请求都按照时间顺序分发到不同的服务器上，期间如果有服务器突然死机，那么就会被踢出轮询队伍中。</p><blockquote><p>2 - 权重规则 ( weight )</p></blockquote><p>轮询规则是按照时间来依次分发请求的，而权重规则是按照服务器的权重比例来进行请求分发的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">实例配置</span><br>upstream blog &#123;<br>server  localhost:8080 weight=2;<br>server  localhost:8081 weight=6;<br>server  localhost:8082 weight=3;<br>&#125;<br></code></pre></td></tr></table></figure><p>在目标服务器地址后面跟上空格，追加1weight`关键字就可以设置权重比例了，对应的数字越大，被访问的频率也就越高，例如上面的配置，如果访问量较高的话，8080 和 8082 两个端口加一起的访问量可能还没有一个 8081 多，可以让高性能服务器拿到较高的值，适合多个服务器配置不一致时起到的均衡作用，这就是权重规则。</p><blockquote><p>3 - 哈希规则 ( ip_hash )</p></blockquote><p>该规则会根据客户端的 ip 地址进行 hash 计算后的结果进行分类，这样的好处是可以让客户端自始至终访问的都是同一台服务器，可以解决 session 的问题。</p><p>配置方法也十分简单，在 upstream 中添加关键字即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">实例配置</span><br>upstream blog &#123;<br>ip_hash;<br>server  localhost:8080;<br>....<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ip_hash 还可以配合 weight 权重一起使用。</li></ul><blockquote><p>4 - 最少规则 ( least_conn )</p></blockquote><p>看名字就可以轻松的看出来，该规则的特点就是将请求交给连接数最少的服务器进行处理，也就是所谓的均摊。</p><p>代码就不粘了，使用方法同上面一致，将关键字敲上即可。</p><blockquote><p>5 - 延迟规则 ( fair )</p></blockquote><p>按照服务器的响应时间来分配，两台服务器等待的情况下，延迟低的服务器优先分配，使用方法同上</p><hr><p><em>这里需要注意无论是 server 还是 upstream 都是在 http 模块下的，而且 upstream 要在 server 的前面，不然不起作用</em></p><h2 id="动静分离">动静分离</h2><h2 id="高可用">高可用</h2>]]></content>
    
    
    <categories>
      
      <category>运维技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javaweb笔记</title>
    <link href="/2022/07/13/Java%E7%AC%94%E8%AE%B0/JavaWeb%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/13/Java%E7%AC%94%E8%AE%B0/JavaWeb%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>JavaWeb 笔记</h1><p>温故而知新！javaweb 笔记。</p><h2 id="HttpServlet-类">HttpServlet 类</h2><h3 id="简单使用-Servlet">简单使用 Servlet</h3><p>在传统的 javaweb 无框架开发的时候，所谓的控制机就是 servlet，创建一个普通的 java 类之后，继承 HttpServlet 类之后，这个类就是一个 servlet 类了，在创建好一个 servlet 之后，只需要配置他的访问路径，那么他就可以正常工作了。</p><blockquote><p>创建一个 servlet 类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 在客户端发起请求的时候，最常用的就是 get 和 post 两种请求方式</span><br><span class="hljs-comment">     * 在 servlet 中分别对着两种方式进行解析，但无论是什么请求，他们的最终处理过程都是一样的</span><br><span class="hljs-comment">     * 所以这里只需要写一个处理逻辑即可。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>         <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;经过了Servlet1控制器&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>         <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面我们已经书写好了一个 servlet 类，但是这个 servlet 还不能正常工作，想要正常工作，需要接收到客户端发来的请求，这样一来就需要配置他的访问路径</p><blockquote><p>在 web.xml 中装载 servlet 并配置访问路径</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置一个简单的Servlet控制器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>club.hanzhe.web.Servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Servlet-的生命周期">Servlet 的生命周期</h3><p>什么是 servlet 的生命周期？servlet 的生命周期，就是 servlet 从初始化工作到最终销毁的过程，我们可以控制 servlet 在某个指定的过程中处理一些逻辑。</p><p>就像上面说的一样，servlet 共有三个声明周期，分别是 <code>初始化</code>，<code>工作</code>，<code>销毁</code>，他们分别对应的函数被称之为生命周期函数，使用方法如下所示：</p><blockquote><p>servlet 的声明周期函数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>         <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;访问了Servlet2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        System.out.println(<span class="hljs-string">&quot;servlet2 init&quot;</span>);<br>        <span class="hljs-built_in">super</span>.init();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>         <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;servlet2 service&quot;</span>);<br>        <span class="hljs-built_in">super</span>.service(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;servlet2 destroy&quot;</span>);<br>        <span class="hljs-built_in">super</span>.destroy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>[ init ] 为初始化方法，当该 servlet 首次被访问的时候会执行一次，之后就不在执行。</li><li>[ service ] 为当前 servlet 提供服务，每当请求访问到 servlet 时，会首先经过 service，然后由 service 判断请求类型，最终调用合适的 doGet 或者 doPost 等等，，，，每次访问都会执行，且优先级在 doGet doPost 之前。</li><li>[ destroy ] 为销毁方法，当 servlet 销毁时执行的善后方法，在我们关闭服务器的时候会看到这个函数执行，多数用来释放资源。在 servlet 销毁之前执行，且只执行一次。</li></ul><h2 id="HttpServletRequest">HttpServletRequest</h2><p>request 代表请求，那么这个类代表的就是基于 HTTP 协议的 servlet 请求封装类，关于客户端请求的所有信息都封装在这个对象中，我们可以使用这个类获得到很多具体信息。</p><h3 id="获取请求参数">获取请求参数</h3><p>之前我们已经实现了 servlet 接受请求，并且处理一些逻辑，但是仅仅是这些是不够的，如果我们写一个带有登录功能的 servlet，应该要获取前端发来的参数，然后在进行逻辑处理。</p><p>例如想要获取前端表单提交的参数，需要使用 <code>HttpServletRequest</code> 对象中的 <code>getParameter</code> 方法</p><blockquote><p>简单的参数表单提交以及获取参数</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 前端代码from表单提交 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;login&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin: 0px auto;&quot;</span>&gt;</span><br>        账户：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// servlet来处理逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>         <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 获取参数，对应 form 表单中的 name 属性</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>        <span class="hljs-comment">// 因为这里是练习，我就用打印代替了一切逻辑处理</span><br>        System.out.println(<span class="hljs-string">&quot;username: &quot;</span> + username);<br>        System.out.println(<span class="hljs-string">&quot;password: &quot;</span> + password);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>配置 web.xml 的代码我就不写了，，，，</li></ul><blockquote><p>效果如图所示：</p></blockquote><img src="..//img/JavaWeb1.png"><p>前端发起请求，已经被 servlet 完全接收，参数已经处理完成。这里暂时先不考虑乱码的问题，后面会提到。</p><h3 id="其他获取方法">其他获取方法</h3><p>我们已经简单的通过 servlet 获取到了请求中包含的参数，其实真实的请求中包含的信息非常多，而其中获取请求携带的表单参数最为常用，那么除开这个方法之外，还可以获取到很多的信息</p><blockquote><p>获取请求携带参数信息</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getParameter( String name)</td><td>请求中 name 属性对应的值。</td></tr><tr><td>getParameterNames()</td><td>获取请求中所有携带的参数的 name，返回 Enumeration 集合</td></tr></tbody></table><blockquote><p>获取更多请求信息</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getRequestURL()</td><td>完整的请求URL</td></tr><tr><td>getRequestURI()</td><td>请求相对路径地址，是在URL的域名与参数之间的路径信息。</td></tr><tr><td>getQueryString()</td><td>URL后面的参数信息，截止 ? 后面的都会获取 ( post下获取不到 )。</td></tr><tr><td>getRemoteHost()</td><td>客户端请求时的 IP 地址</td></tr><tr><td>getRemoteAddr()</td><td>客户端请求时的 IP 地址</td></tr><tr><td>getRemotePort()</td><td>客户端请求时使用的端口号</td></tr><tr><td>getLocalAddr()</td><td>服务端 IP 地址</td></tr><tr><td>getLocalName()</td><td>服务端主机名</td></tr></tbody></table><blockquote><p>获取请求头的信息</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getHeader(String name)</td><td>获取目标请求头信息，如果不包含头则为 null，包含多个则返回第一个</td></tr><tr><td>getHeaders(String name)</td><td>返回目标请求头的所有信息。</td></tr><tr><td>getHeaderNames()</td><td>返回所有请求头信息，返回值是一个枚举类型</td></tr></tbody></table><p>更多关于 HttpServletRequest 的函数说明，直连</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/wwq0813/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">90256058</span><br></code></pre></td></tr></table></figure><h2 id="HttpServletResponse">HttpServletResponse</h2><p>服务端与客户端交互，客户端发送请求，请求数据被封装到 <code>HttpServletRequest</code> 对象中，那么服务器接收请求后，向客户端返回的信息也被封装到一个对象中，就是 <code>HttpServletResponse</code>。</p><h3 id="设置响应数据">设置响应数据</h3><blockquote><p>响应数据对应的方法</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getOutputStream()</td><td>获取字节输出流，以字节形式向客户端响应数据</td></tr><tr><td>getWriter()</td><td>获取字符输出流，以字符形式向客户端响应数据</td></tr></tbody></table><ul><li>如果字节输出流输出字符的话，会爆出异常</li><li>在同一次响应的过程中，字节流和字符流只能使用一种，二者相互排斥</li></ul><p>像之前的例子，后端成功接收到了前端发送的请求，并且成功打印在了控制台中，但是这仅仅是后台知道，要给前端一个提示才行，这里要实现一个功能，如果请求成功了，在页面上给一个成功的提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>    outputStream.println(<span class="hljs-string">&quot;success !&quot;</span>);<br>    Enumeration&lt;String&gt; names = req.getParameterNames();<br>    <span class="hljs-keyword">while</span> ( names.hasMoreElements() )&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> names.nextElement();<br>        System.out.println(str + <span class="hljs-string">&quot;: &quot;</span> + req.getParameter(str));<br>        outputStream.println(str + <span class="hljs-string">&quot;: &quot;</span> + req.getParameter(str));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置响应头">设置响应头</h3><blockquote><p>设置响应头对应的方法</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>addHeader(String name, String value)</td><td>在目标请求头中追加字符串值</td></tr><tr><td>addIntHeader(String name, int value)</td><td>在目标请求头中追加整数类型的值</td></tr><tr><td>addDateHeader(String name, long value)</td><td>在目标请求头中追加长整形类型的值</td></tr><tr><td>setHeader(String name, String value)</td><td>修改目标请求头中字符串值</td></tr><tr><td>setIntHeader(String name, int value)</td><td>修改目标请求头中整数类型的值</td></tr><tr><td>setDateHeader(String name, long value)</td><td>修改在目标请求头中长整形类型的值</td></tr><tr><td>setStatus(int value)</td><td>设置响应结果状态码</td></tr></tbody></table><ul><li>add 开头的是在原基础上追加，适合有多个值得请求头</li><li>set 开头的是修改，对应的是只有一个值的请求头</li></ul><p>可以修改请求头之后，我们就可以针对相应的数据进行一些设置了，例如之前的中文乱码，现在就可以解决了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置响应类型字符集为utf-8</span><br>resp.setHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>更多关于 HttpServletResponse 的函数说明，直连</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">8</span>bc6b82403c5<br></code></pre></td></tr></table></figure><h2 id="转发与重定向">转发与重定向</h2><p>我们已经学习了 <code>请求</code> 和 <code>响应</code>，可以通过 html  或者 jsp 页面发送请求，后台接受请求后进行处理，然后响应给前端页面返回值，那么我们可以不可以在后端就控制页面的跳转呢？</p><blockquote><p>转发和重定向实现代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 转发实现页面跳转</span><br><span class="hljs-meta">@WebServlet(&quot;/servlet3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>          <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        req.getRequestDispatcher(<span class="hljs-string">&quot;login.html&quot;</span>).forward(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重定向实现页面跳转</span><br><span class="hljs-meta">@WebServlet(&quot;/servlet4&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>          <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.sendRedirect(<span class="hljs-string">&quot;login.html&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二者都可以实现页面的跳转，但是有着本质的区别</p><ol><li>通过代码可以看出来，转发是通过 request 操作的，但是重定向是通过 response 操作的</li><li>在转发之后，还需要调用 forward 方法，将当前的请求，响应对象传递下去，也就意味着即使目标变了，但是请求和相应还是原本的请求和相应，地址栏也不会有任何的变化</li><li>重定向则是抛弃了当前的请求过程，另外发起了一个新的请求去访问目标地址，浏览器地址栏会发生变化，且状态码会变成 304</li></ol><h2 id="会话跟踪技术">会话跟踪技术</h2><h2 id="请求处理技术">请求处理技术</h2><h3 id="过滤器">过滤器</h3><h3 id="监听器">监听器</h3>]]></content>
    
    
    <categories>
      
      <category>JavaEE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java动态代理</title>
    <link href="/2022/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1>代理模式</h1><p>代理模式顾名思义，就是以你的名义帮你处理一些琐事，例如：用户A 近期准备结婚，他需要预定饭店，布置会场，邀请亲朋，制定菜单等等等等… 这样处理事情就比较麻烦，针对这些琐事就可以找 <em>婚庆公司</em> 来处理，他们可以解决婚礼过程中的大部分事情，这样用户A 只需要面对结婚这件事儿本身就可以，而不需要考虑其他的事情。</p><p>上面这个例子中 <em>婚庆公司的定位就是代理</em>，Java 中有些地方也需要使用代理模式进行解决，例如事务，日志等等，我们希望 service 中只需要负责业务逻辑本身而不要掺杂其他的代码，这里就可以用到代理模式</p><p><strong>动态代理模式总结起来一句话：可以做到在不修改目标对象的功能前提下,对目标功能扩展</strong></p><p>我们需要了解掌握三种代理模式：静态代理，JDK 动态代理，CGLIB 动态代理，我们通过日志的方式进行了解</p><h2 id="静态代理模式">静态代理模式</h2><p>我们需要准备 service 接口以及代理类和被代理类：</p><blockquote><p>正常执行添加日志</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// service接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-comment">// 添加用户的方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(String username, String password)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(String username, String password)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 假装有DAO层</span><br>        <span class="hljs-comment">// count = userDao.insertUser(username, password);</span><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">us</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        System.out.println(us.insertUser(<span class="hljs-string">&quot;老八&quot;</span>, <span class="hljs-string">&quot;秘制小汉堡&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们运行测试类的 main 方法后发现控制台只输出了数字 1，如果我们想要实现日志功能的话，需要在实现类中添加打印语句，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 【改】实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(String username, String password)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 假装有DAO层</span><br>        <span class="hljs-comment">// count = userDao.insertUser(username, password);</span><br>        System.out.println(<span class="hljs-string">&quot;用户【&quot;</span> + username + <span class="hljs-string">&quot;】插入成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志添加完成！</p><blockquote><p>使用代理模式添加日志</p></blockquote><p>但是按照之前的说法，我们不希望在 service 中掺杂其他的代码，它仅仅负责逻辑即可，所以我们要移除掉实现类中的输出语句，新建一个代理类来完成这部分功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> UserService us;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceProxy</span><span class="hljs-params">( UserService us )</span>&#123;<br>        <span class="hljs-built_in">this</span>.us = us;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(String username, String password)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.us.insertUser(username, password);<br>        System.out.println(<span class="hljs-string">&quot;用户【&quot;</span> + username + <span class="hljs-string">&quot;】插入成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">us</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceProxy</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>() );<br>        System.out.println(us.insertUser(<span class="hljs-string">&quot;老八&quot;</span>, <span class="hljs-string">&quot;秘制小汉堡&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建代理类的对象，将被代理的实例作为参数传过去，让代理类以自己的名义帮自己实现日志功能，这样实现类中只需要负责书写业务逻辑就可以了。这就是 ==静态代理模式==</p><h2 id="JDK动态代理">JDK动态代理</h2><p>静态代理可以做到在不修改源代码的情况下添加新的功能，但是如果 service 比较多的话静态代理的弊端就出来了，每个 service 都对应一个代理类，这样代码量就大大增加，这里就可以使用 JDK动态代理来解决这个问题：</p><blockquote><p>代码实现</p></blockquote><p>JDK动态代理依靠 <code>java.lang.reflect.Proxy</code> 实现，保持接口和实现类不动，新建代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">( Object obj)</span>&#123;<br>        <span class="hljs-comment">// 获取被代理类的类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> obj.getClass().getClassLoader();<br>        <span class="hljs-comment">// 获取被代理的类实现的所有接口</span><br>        Class&lt;?&gt;[] classes = obj.getClass().getInterfaces();<br>        <span class="hljs-comment">// 在这里接管目标对象执行函数的过程</span><br>        <span class="hljs-comment">// proxy不用管，method：被执行的函数，args：传递的参数</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> <br>            (Object proxy, Method method, Object[] args)-&gt;&#123;<br>             <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(obj, args);<br>                System.out.println(<span class="hljs-string">&quot;用户【&quot;</span> + Arrays.asList(args) + <span class="hljs-string">&quot;】插入成功！&quot;</span>);<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(classLoader, classes, invocationHandler);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>LogProxy.getInstance</code> 传入被代理的对象，通过 <code>Proxy.newProxyInstance</code> 来获取到代理对象，调用这个方法需要传入三个参数：</p><ul><li>【classLoader】被代理的类的类加载器</li><li>【classes】被代理的类所实现的所有接口</li><li>【invocationHandler】是一个支持函数式的接口，直接创建对象即可，当被代理的类调用方法的时候会在这里进行执行，通过 lambda 创建该类的实例需要接受三个形参：<ul><li>【proxy】暂时不用管…</li><li>【method】被代理的类执行的方法会在这里进行处理</li><li>【args】被代理类执行方法时传入的参数</li><li>最后记得将 invoke 执行函数后的结果返回，不然调用者那边会收不到返回结果</li></ul></li></ul><blockquote><p>JDK动态代理的缺点</p></blockquote><p>我们通过 <code>Proxy.newProxyInstance</code> 传参成功返回了代理对象 ，然后在测试类中成功转换为 <code>UserService</code> 实例进行日志增强，现在我们尝试打印一下转换之前的代理对象的 class 是什么样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-comment">// 省略多余代码</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> obj.getClass().getClassLoader();<br>        Class&lt;?&gt;[] classes = obj.getClass().getInterfaces();<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> <br>            (Object proxy, Method method, Object[] args) -&gt; method.invoke(obj, args);<br>        <span class="hljs-comment">// 获取代理对象并进行打印</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <br>            Proxy.newProxyInstance(classLoader, classes, invocationHandler);<br>        System.out.println(proxy.getClass());<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果为：<code>class com.sun.proxy.$Proxy0</code>，并不是我们熟悉的类型，那为什么他可以转换为 <code>UserService</code> 类型呢？因为他获取了被代理目标类实现的所有接口：<code>obj.getClass().getInterfaces()</code>，让我们打印一下代理对象实现的接口是什么样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-comment">// 省略多余代码</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> obj.getClass().getClassLoader();<br>        Class&lt;?&gt;[] classes = obj.getClass().getInterfaces();<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> <br>            (Object proxy, Method method, Object[] args) -&gt; method.invoke(obj, args);<br>        <span class="hljs-comment">// 获取代理对象并进行打印</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <br>            Proxy.newProxyInstance(classLoader, classes, invocationHandler);<br>        System.out.println(Arrays.asList(proxy.getClass().getInterfaces()));<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果为：<code>[interface site.hanzhe.proxy.jdkProxy.UserService]</code>，代理对象实现了和被代理对象一模一样的接口，所以他可以转换为 <code>UserService</code>，那么如果我们被代理的类没有实现任何接口会怎么样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 修改被代理的类，让他不实现任何接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-comment">/* implements UserService */</span> &#123;<br>    <span class="hljs-comment">// @Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(String username, String password)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 假装有DAO层</span><br>        <span class="hljs-comment">// count = userDao.insertUser(username, password);</span><br>        System.out.println(username + <span class="hljs-string">&quot;--&quot;</span> + password);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被代理类修改完成了，代理类保持不变，在测试类中修改强制转换类型，然后进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">us</span> <span class="hljs-operator">=</span><br>             (UserServiceImpl)LogProxy.getInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>());<br>        us.insertUser(<span class="hljs-string">&quot;老八&quot;</span>, <span class="hljs-string">&quot;秘制小汉堡&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>系统抛出了 <code>java.lang.ClassCastException</code> 异常，详细信息为 <code>com.sun.proxy.$Proxy0 cannot be cast to site.hanzhe.proxy.jdkProxy.UserServiceImpl</code>，告诉我们无法强制转换为 <code>UserServiceImpl</code> 类型的对象，这样一来我们就测出了一个问题，JDK动态代理要求 <em>被代理的对象必须实现至少一个接口</em></p><h2 id="CGLIB动态代理">CGLIB动态代理</h2><p>在之前的静态代理中，代理类与被代理类实现了同一个接口，从而达到对每个函数进行代理的目的，而在 JDK动态代理中要求被代理的类必须实现至少一个接口，那么如果我们被代理的类没有实现接口的话如何代理？</p><p>CGLIB动态代理模式，以被代理对象作为父类，动态创建一个子类作为代理对象并返回，CGLIB动态代理底层使用了 ASM字节码框架来生成子类，相比较比 Java反射效率要高</p><p>想要使用 CGLIB动态代理需要引入 CGLIB 和 ASM 的 jar 包，这里记录一下两个 jar 包所对应的 maven 坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.ow2.asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>代码实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个没有实现任何接口的 service 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-comment">// 添加用户的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(String username, String password)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 假装有DAO层</span><br>        <span class="hljs-comment">// count = userDao.insertUser(username, password);</span><br>        System.out.println(username + <span class="hljs-string">&quot;--&quot;</span> + password);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代理类代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">(Object obj)</span>&#123;<br>        <span class="hljs-comment">// 创建CGLIB的工具类</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setSuperclass(obj.getClass());<br>        enhancer.setCallback(<br>            (InvocationHandler)(Object proxy, Method method, Object[] args)-&gt;&#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(obj, args);<br>                System.out.println(<span class="hljs-string">&quot;用户【&quot;</span> + Arrays.asList(args) + <span class="hljs-string">&quot;】插入成功！&quot;</span>);<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        );<br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代理类代码说明：</p><ul><li>【Enhancer】CGLIB中的工具类，通过工具类来动态创建一个新的实例<ul><li>【setSuperclass】设置对象继承的父类，该方法需要传入被代理类的 class 对象</li><li>【setCallback】通过回调的方式实现代理功能，该方法需要传入一个 <code>Callback</code> 对象， 这里使用他下面子接口 <code>InvocationHandler</code>，也就是 JDK动态代理时手动创建的那个对象，由于类型原因在使用的时候使用了强制类型转换<ul><li>【InvocationHandler】函数式接口的三个参数这里就不解释了，记得将 invoke 结果返回即可</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL笔记</title>
    <link href="/2022/06/02/MySQL%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/02/MySQL%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>mysql 由行和列之间建立某种关系存储数据信息，是最常见的关系型数据库，也是当下最流行的，开源的，免费的数据库</p><h1>安装及配置</h1><p>我习惯下载软件都会去官网进行下载，直接百度搜索 mysql 即可，mysql 的官网地址如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//www.mysql.com/</span><br></code></pre></td></tr></table></figure><p>当然也可以直接去他的下载地址：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>dev.mysql.com<span class="hljs-regexp">/downloads/my</span>sql/<br></code></pre></td></tr></table></figure><blockquote><p>MySQL的下载页面如下所示：</p></blockquote><p><img src="https://s2.loli.net/2024/01/07/y67UJA9B8tRzZ1v.png" alt=""></p><p>这里我选择下载的是 Windows x64 环境下的 MySQL 5.7.30，下载完成后是一个压缩包文件，将他解压到平时安装软件的位置就行了，解压就相当于是一种安装</p><h2 id="MySQL-配置文件">MySQL 配置文件</h2><p>在 mysql 解压完成后，进入 mysql 目录下，新建一个 mysql 的配置文件，命名要求及格式为<code>my.ini</code>，注意，这里的 ini 是文件的格式扩展名，而不是文件名的一部分</p><p>然后右键用记事本打开，在配置文件中添加如下的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[client]<br>default-character-set=utf8<br><br>[mysqld]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置MySQL端口为3306</span><br>port=3306<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置mysql的安装目录</span><br>basedir=D:\Files\MySQL_5.7.30<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置mysql数据库的数据的存放位置目录</span><br>datadir=D:\Files\MySQL_5.7.30\database<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置数据库字符集</span><br>character-set-server=utf8<br>init_connect=&#x27;SET collation_connection = utf8_general_ci&#x27;<br>init_connect=&#x27;SET NAMES utf8&#x27;<br>collation-server=utf8_general_ci<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置表名区分大小写，1为不区分，2为区分</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">lower_case_table_names=2</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置无需密码登录</span><br>skip-grant-tables<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">防止某些查询语句报错</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">缓存索引和数据的大小</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">innodb_buffer_pool_size=1G</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最大连接数</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">max_connections=521</span><br></code></pre></td></tr></table></figure><p><code>datadir</code>是自己随便写的位置，目录名称也可以自行修改，但是最好是一个不存在的目录，这样在初始化的时候会为你自动创建该目录，如果是一个已存在的目录可能会出错</p><p>因为我们不是通过 MSI 进行安装的，并不能通过安装初始化 root 密码，所以在没有密码的状况下需要进设置无需密码登录，等所有设置都完成之后就可以注释掉了</p><p>配置文件就搞定了，这个是最简单的配置文件信息，mysql 配置信息远远不止这点，想要配置多去百度查询<code>my.ini</code>具体配置即可</p><h2 id="配置环境变量">配置环境变量</h2><p>配置环境变量应该都很熟悉了</p><ul><li>右键<code>计算机</code>，点击<code>属性</code></li><li>找到左侧的<code>高级系统设置</code>，点击进入</li><li>在<code>高级</code>选项卡下，点击下方的<code>环境变量</code></li><li>在下面的<code>系统变量</code>区域中找到<code>PATH</code>，双击进入</li><li>添加新的环境变量到 mysql 安装目录下的<code>bin</code>目录中</li><li>至此，环境变量配置完成</li></ul><h2 id="初始化服务">初始化服务</h2><p>这一步需要执行的只有两行代码，需要环境配置没有任何问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化MySQL服务</span><br>mysqld -install<br></code></pre></td></tr></table></figure><p>控制台提示<code>Service successfully installed</code>表示服务创建成功了，如果没有提示这个可能程序出现了问题，或者之前安装过 mysql 没有卸载干净，自行百度解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化本地数据库</span><br>mysqld --initialize-insecure --user=mysql<br></code></pre></td></tr></table></figure><p>初始化本地数据库后，会在你之前设置的那个目录的位置创建一个你指定名称的目录，目录下会存放着数据库存储的文件，初始化命令执行会有几秒钟的延迟，请耐心等待，如果没有任何提示就证明初始化成功了</p><h2 id="设置-ROOT-密码">设置 ROOT 密码</h2><p>启动 mysql 服务，打开控制台输入以下命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 启动MySQL服务<br><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> mysql<br># 对应的关闭<br># <span class="hljs-built_in">net</span> stop mysql<br></code></pre></td></tr></table></figure><p>服务开启成功后，进入mysql：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -u root -p<br></code></pre></td></tr></table></figure><p>输入以上命令后，会提示让你输入密码，因为我们设置了无需密码登录，所以这里不输入任何字符直接回车，就可以进入 mysql（ 日后若忘记了密码也可以这么找回 ），进入 mysql 后开始修改密码，流程如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 选择数据库</span><br>use mysql;<br><span class="hljs-comment">-- 执行修改操作</span><br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> authentication_string<span class="hljs-operator">=</span>password(<span class="hljs-string">&#x27;密码&#x27;</span>) <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;root&#x27;</span> <span class="hljs-keyword">and</span> Host<span class="hljs-operator">=</span><span class="hljs-string">&#x27;localhost&#x27;</span>;<br><span class="hljs-comment">-- 刷新权限</span><br>flush privileges;<br><span class="hljs-comment">-- 退出MySQL</span><br>exit;<br></code></pre></td></tr></table></figure><p>这样一套行云流水下来，root 的密码也设置好了，接下来去配置文件删掉最后一项，然后重启服务即可</p><p><font color="red"><strong>注：</strong></font>上面涉及到修改密码的 update 语句，是基于<code>mysql5.7.30</code>版本使用的，如果版本低一些，请使用下面这行代码替换：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">update user <span class="hljs-built_in">set</span> password=password(&#x27;abc&#x27;) WHERE User=&#x27;root&#x27;;<br></code></pre></td></tr></table></figure><p>这样一来你的 mysql 就已经配置完成啦！可以正常使用了</p><h2 id="MIS-安装版忘记密码">MIS 安装版忘记密码</h2><p>之前在上面我们提过，如果我们忘记了密码可以回溯到最开始，在<code>my.ini</code>配置文件中使用<code>skip-grant-tables</code>即可无需密码登录，然后在重置密码</p><p>但是如果是通过 MIS 安装的 mysql，它的目录下是没有<code>my.ini</code>配置文件的，所以想要重置密码需要进行以下步骤：</p><ol><li><p>关闭 mysql 的服务</p></li><li><p>在 cmd 下输入<code>mysqld --skip-grant-tables</code>启动服务器 光标不动 （不要关闭该窗口）</p></li><li><p>重新打开一个新的 cmd，键入命令<code>mysql -u root -p</code>，输入密码的时候直接回车，没有校验</p></li><li><p>到这里就已经可以进入数据库了，在修改自己的密码即可：</p><ul><li><code>use mysql;</code></li><li><code>update user set authentication_string=password('密码') where user='root' and Host='localhost';</code></li></ul></li><li><p>密码修改完成后，关闭两个 cmd 窗口 在任务管理器结束 mysqld 进程，重启 mysql 进程就可以正常使用了</p></li></ol><h1>结构化语言</h1><p>学习 mysql 大多数都是在学习 sql 这门语言，sql 语言中划分了语句的类型，称之为结构化语言：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>DDL 数据定义语言</td><td>操作的是表结构相关，例如<code>CREATE、ALTER、MODIFY、DROP</code></td></tr><tr><td>DML 数据操纵语言</td><td>操作表中具体的数据，例如<code>INSER、DELETE、UPDATE、TRUNCATE</code></td></tr><tr><td>DQL 数据查询语言</td><td>负责查询相关的操作，例如<code>SELECT、SHOW</code></td></tr><tr><td>DPL 事务处理语言</td><td>操作事务相关命令，例如<code>BIGIN、ROLLBACK、COMMIT</code></td></tr><tr><td>DCL 数据控制语言</td><td>用于为用户设置权限的命令，例如<code>GRANT、REVOKE</code></td></tr></tbody></table><h1>库级相关命令</h1><p>命令不用死记硬背，用时过来找，随时作补充，熟能生巧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建数据库，可选择的指定字符集<br>CREATE DATABASE [IF NOT EXISTS] `TEST` [CHARACTER SET utf8];<br><br>-- 删除数据库<br>DROP DATABASE [IF EXISTS] `TEST`;<br><br>-- 查询所有已创建的数据库<br>SHOW DATABASES;<br><br>-- 查看指定数据库创建命令<br>SHOW CREATE DATABASE `TEST`;<br><br>-- 修改数据库信息 ( 库名不可修改 )<br>ALTER DATABASE `TEST` [CHARACTER SET utf8];<br><br>-- 选择数据库<br>USE `TEST`; <br></code></pre></td></tr></table></figure><p><code>TEST</code>代表库名称，<em>`</em> 被叫做 “飘号”，它适用于我们书写的标识符防止被识别为关键字</p><p>[ ] 中括号内的关键字为可选项：</p><ul><li><code>CREATE DATABASE</code>中的<code>IF NOT EXISTS</code>的作用是创建已存在的库时会防止报错</li><li><code>DROP DATABASE</code>中的<code>IF EXISTS</code>的作用是删除不存在的库时会防止报错</li><li><code>CHARACTER SET</code>表示的就是字符集了</li></ul><h1>表级相关命令</h1><p>关于表的几个简单命令这里记一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建表<br>CREATE TABLE 表名称(...);<br><br>-- 删除表<br>DROP TABLE 表名称;<br><br>-- 查询表结构<br>SHOW CREATE TABLE 表名称;<br><br>-- 复制一张表（仅数据）<br>CREATE TABLE 源表 SELECT * FROM 新表<br><br>-- 复制一张表（连同表结构，包括主键，约束等等）<br>CREATE TABLE 源表 LIKE 新表<br><br>-- 清空表中的数据<br>TRUNCATE TABLE 表名称;<br></code></pre></td></tr></table></figure><blockquote><p>创建简单表</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `EMP` (<br> `ID` INT(5),<br> `NAME` VARCHAR(20)<br>);<br></code></pre></td></tr></table></figure><h2 id="各种数据类型">各种数据类型</h2><p>上面就是创建一张简单的数据表的 SQL 语句，<code>ID</code>和<code>NAME</code>都是列的名称，后面跟着的<code>INT、VARCHAR</code>就是数据类型，数据类型后面的括号代表的是长度，数据类型主要分为 <strong>数值</strong> <strong>字符串</strong> <strong>日期时间</strong> <strong>枚举</strong> 三种</p><blockquote><p>数值类型</p></blockquote><table><thead><tr><th style="text-align:left">类型</th><th>大小</th><th style="text-align:left">最大数量 / 长度</th><th style="text-align:left">使用场景 / 描述</th></tr></thead><tbody><tr><td style="text-align:left">BIT</td><td>位数据</td><td style="text-align:left">1~64</td><td style="text-align:left">小整数值</td></tr><tr><td style="text-align:left">TINYINT</td><td>1 字节</td><td style="text-align:left">255</td><td style="text-align:left">小整数值</td></tr><tr><td style="text-align:left">SMALLINT</td><td>2 字节</td><td style="text-align:left">65535</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">MEDIUMINT</td><td>3 字节</td><td style="text-align:left">16777215</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">INT 或 INTEGER</td><td>4 字节</td><td style="text-align:left">2147483647</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">BIGINT</td><td>8 字节</td><td style="text-align:left">18446744073709551615</td><td style="text-align:left">极大整数值</td></tr><tr><td style="text-align:left">FLOAT</td><td>4 字节</td><td style="text-align:left"></td><td style="text-align:left">单精度 浮点数值</td></tr><tr><td style="text-align:left">DOUBLE</td><td>8 字节</td><td style="text-align:left"></td><td style="text-align:left">双精度 浮点数值</td></tr><tr><td style="text-align:left">DECIMAL</td><td>(M, D)</td><td style="text-align:left">依赖于 M 和 D 的值</td><td style="text-align:left">小数，适合金融计算</td></tr></tbody></table><blockquote><p>字符串类型</p></blockquote><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">CHAR</td><td style="text-align:left">255 字节</td><td style="text-align:left">定长字符串</td></tr><tr><td style="text-align:left">VARCHAR</td><td style="text-align:left">65535 字节</td><td style="text-align:left">变长字符串</td></tr><tr><td style="text-align:left">TINYBLOB</td><td style="text-align:left">255 字节</td><td style="text-align:left">不超过 255 个字符的二进制字符串</td></tr><tr><td style="text-align:left">TINYTEXT</td><td style="text-align:left">255 字节</td><td style="text-align:left">短文本字符串</td></tr><tr><td style="text-align:left">BLOB</td><td style="text-align:left">65535 字节</td><td style="text-align:left">二进制形式的长文本数据</td></tr><tr><td style="text-align:left">TEXT</td><td style="text-align:left">65535 字节</td><td style="text-align:left">长文本数据</td></tr><tr><td style="text-align:left">MEDIUMBLOB</td><td style="text-align:left">16777215 字节</td><td style="text-align:left">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:left">MEDIUMTEXT</td><td style="text-align:left">16777215 字节</td><td style="text-align:left">中等长度文本数据</td></tr><tr><td style="text-align:left">LONGBLOB</td><td style="text-align:left">4294967295 字节</td><td style="text-align:left">二进制形式的极大文本数据</td></tr><tr><td style="text-align:left">LONGTEXT</td><td style="text-align:left">4294967295 字节</td><td style="text-align:left">极大文本数据</td></tr></tbody></table><blockquote><p>日期时间类型</p></blockquote><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">格式</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">DATE</td><td style="text-align:left">3 字节</td><td style="text-align:left">YYYY-MM-DD</td><td style="text-align:left">日期值</td></tr><tr><td style="text-align:left">TIME</td><td style="text-align:left">3 字节</td><td style="text-align:left">HH:MM:SS</td><td style="text-align:left">时间值或持续时间</td></tr><tr><td style="text-align:left">YEAR</td><td style="text-align:left">1 字节</td><td style="text-align:left">YYYY</td><td style="text-align:left">年份值</td></tr><tr><td style="text-align:left">DATETIME</td><td style="text-align:left">8 字节</td><td style="text-align:left">YYYY-MM-DD HH:MM:SS</td><td style="text-align:left">混合日期和时间值</td></tr><tr><td style="text-align:left">TIMESTAMP</td><td style="text-align:left">4 字节</td><td style="text-align:left">YYYYMMDD HHMMSS</td><td style="text-align:left">混合日期和时间值，时间戳</td></tr></tbody></table><blockquote><p>选择类型</p></blockquote><table><thead><tr><th>类型</th><th>用途</th></tr></thead><tbody><tr><td>ENUM</td><td>只能使用一些特定的值，例如 ENUM(‘男’, ‘女’)</td></tr><tr><td>SET</td><td>如果说 ENUM 是单选，那么 SET 就是多选</td></tr></tbody></table><blockquote><p>根据了解到的数据类型完善一下表的结构</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `EMP` (<br> `ID` INT(5),<br> `DEPT_ID` INT(3),<br> `NAME` VARCHAR(20),<br> `AGE` INT(3),<br> `IDENTITY` VARCHAR(18),<br> `GENDER` ENUM(&#x27;男&#x27;, &#x27;女&#x27;),<br> `CREATE_DATE` DATETIME,<br> `MODIFY_DATE` DATETIME,<br> `MONEY` DECIMAL(14, 2),<br> `DESCRIPTION` TEXT<br>)<br></code></pre></td></tr></table></figure><h2 id="约束-Constraint">约束 Constraint</h2><p>表的数据肯定不是想些什么就写什么，不然数据乱了表就没有存在的意义了，要让表变得有意义，我们需要在向表中添加数据的时候设计一些规则，例如不能留空，或者不能重复之类的，这个叫做 <strong>约束</strong></p><blockquote><p>约束大致分为五种</p></blockquote><ul><li><p>主键约束<code>PRIMARY KEY</code></p><ul><li>在表中是唯一的标识，通过主键列可以找到任何一行记录，<strong>自带唯一和非空</strong></li></ul></li><li><p>外键约束<code>FOREIGN KEY</code></p><ul><li>指本表中的某一列关联其他表中的某一列，所取的值必须在被约束的列中存在，约束与被约束的列的类型以及长度必须相同 ( 阿里手册禁用外键约束 )</li></ul></li><li><p>唯一约束<code>UNIQUE</code></p><ul><li>该列不允许出现重复的数据，NULL值除外</li></ul></li><li><p>非空<code>NOT NULL</code></p><ul><li>该列不允许出现空值 NULL，空字符串 “” 不属于空值</li></ul></li><li><p>检查<code>CHECK</code></p><ul><li>通过表达式判断来检查当前列是否符合要求的规则，该约束目前在 MySQL 中无效</li></ul></li></ul><blockquote><p>约束的添加与查看</p></blockquote><p>约束可以直接书写在类型的后面，叫做 <strong>行级约束</strong>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `EMP` (<br> `USER_ID` INT(5) PRIMARY KEY<br>)<br></code></pre></td></tr></table></figure><p>也可以在表创建完成之后书写在最后面，叫做 <strong>表级约束</strong>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `EMP` (<br> `USER_ID` INT(5),<br>   PRIMARY KEY(`USER_ID`)<br>)<br></code></pre></td></tr></table></figure><p>表结构创建完成后，我们想知道自己究竟设置了那些约束，可以通过命令进行查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW INDEX FROM `EMP`<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>约束共有五种类型，分为表级约束和列级约束两种书写方式</li><li>表级约束不支持<code>NOT NULL</code>，列级约束不支持<code>FOREIGN KEY</code>和<code>CHECK</code></li><li>个人建议使用 <em>表级约束</em>，使用表级约束的情况下查看所有关于约束的列可以直接看最后几行就一目了然了</li></ul><blockquote><p>有了这几个约束，我们在重新设计一下表结构</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 新建一张表用来测试外键约束（行级约束）<br>CREATE TABLE `DEPT` (<br> `ID` INT(3) PRIMARY KEY,<br> `NAME` VARCHAR(10) NOT NULL,<br> `CREATE_TIME` DATETIME,<br> `PHONE` VARCHAR(20) NOT NULL<br>)<br><br>-- 重新设置表添加约束（表级约束）<br>CREATE TABLE `EMP` (<br> `ID` INT(5),<br> `DEPT_ID` INT(3),<br> `NAME` VARCHAR(20) NOT NULL,<br> `AGE` INT(3) NOT NULL,<br> `IDENTITY` VARCHAR(18),<br> `GENDER` ENUM(&#x27;男&#x27;, &#x27;女&#x27;),<br> `CREATE_DATE` DATETIME,<br> `MODIFY_DATE` DATETIME,<br> `MONEY` DECIMAL(14, 2),<br> `DESCRIPTION` TEXT,<br>  PRIMARY KEY(`ID`),<br>  UNIQUE(`IDENTITY`),<br>  FOREIGN KEY(`DEPT_ID`) REFERENCES`DEPT`(`ID`)<br>)<br></code></pre></td></tr></table></figure><h2 id="列的各种属性">列的各种属性</h2><p>我们在创建表的时候，先是写列名称，然后是数据类型，然后是行级约束，最后写表级约束，列中除开这些之外，还有他本身自带的属性：</p><ul><li>默认<code>DEFAULT</code><ul><li>向数据库中插入数据的时候，如果没有提供该列的数据，那么就是用这个默认值</li></ul></li><li>注释<code>COMMENT</code><ul><li>注释是面向开发人员的，用来告诉开发人员这列代表什么意思，取值等等，表和列都可以使用</li></ul></li><li>自增<code>AUTO_INCREMENT</code><ul><li>我们表中的主键列，当表中数据不多的时候可以选择使用自增，他会自动生成 1, 2, 3… 的递增主键</li></ul></li><li>更新<code>ON UPDATE</code><ul><li>表中最常见的两个字段就是创建时间以及修改时间，其中修改时间是随着每次修改都更新的，这里就可以使用该属性来完成这个操作</li></ul></li><li>填充<code>ZEROFILL</code><ul><li>如果当前字段长度为10，但是值得长度并不够10位，想要补全10为就可以用该属性</li></ul></li><li>无符号<code>UNSIGNED</code><ul><li>适用于数值类型，只能存储大于等于 0 的值，简单理解 无符号 ≈ 无负号</li></ul></li></ul><p><strong>关于自增的描述：</strong></p><ol><li><em>自增适用于数值类型且必须是主键的列，且一张表中只能有一个自增列</em></li><li>在 mysql 5.7 以及之前的版本，自增数据是暂存在内存中的，当重启 mysql 打开表后他会找到当前自增列的最大值开始继续自增，而 mysql 8 之后这个自增做了持久化</li><li>当我们向数据库中插入数据时，只有在未指定自增列的值或者传的值为 NULL 值得时候，才会触发自增</li><li>我们插入数据时为自增列 ( y ) 传了值 ( x ) 的情况下，如果 x &gt; y 那么 x 就会作为新的自增值，否则不会变化</li><li>当前自增值为 1，执行了一次插入失败之后，在执行一次会发现值是 3，在失败的时候自增列还是会变化的</li><li>自增关于值得操作会在后面提到</li></ol><blockquote><p>根据掌握的属性在重新设计一次表结构</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 添加上一些属性用来测试<br>CREATE TABLE `DEPT` (<br> `ID` INT(3) UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;部门ID&#x27;,<br> `NAME` VARCHAR(10) NOT NULL COMMENT &#x27;部门名称&#x27;,<br> `CREATE_TIME` DATETIME DEFAULT NOW() COMMENT &#x27;部门成立时间&#x27;,<br> `PHONE` VARCHAR(20) NOT NULL COMMENT &#x27;部门联系电话&#x27;<br>) COMMENT &#x27;部门表&#x27;;<br><br>-- 添加上一些属性用来测试<br>CREATE TABLE `EMP` (<br> `ID` INT(5) UNSIGNED AUTO_INCREMENT COMMENT &#x27;员工ID&#x27;,<br> `DEPT_ID` INT(3) UNSIGNED COMMENT &#x27;所在的部门ID&#x27;,<br> `NAME` VARCHAR(20) NOT NULL COMMENT &#x27;姓名&#x27;,<br> `AGE` INT(3) NOT NULL COMMENT &#x27;员工年龄&#x27;,<br> `IDENTITY` VARCHAR(18) COMMENT &#x27;身份证号码&#x27;,<br> `GENDER` ENUM(&#x27;男&#x27;, &#x27;女&#x27;) DEFAULT &#x27;男&#x27; COMMENT &#x27;性别&#x27;,<br> `CREATE_DATE` DATETIME DEFAULT NOW() COMMENT &#x27;创建时间&#x27;,<br> `MODIFY_DATE` DATETIME DEFAULT NOW() ON UPDATE NOW() COMMENT &#x27;修改时间&#x27;,<br> `MONEY` DECIMAL(14, 2) COMMENT &#x27;月薪&#x27;,<br> `DESCRIPTION` TEXT COMMENT &#x27;个人描述&#x27;,<br>  PRIMARY KEY(`ID`),<br>  UNIQUE(`IDENTITY`),<br>  FOREIGN KEY(`DEPT_ID`) REFERENCES `DEPT` (`ID`)<br>) COMMENT &#x27;员工表&#x27;;<br></code></pre></td></tr></table></figure><h2 id="修改已创建的表">修改已创建的表</h2><p>上面每次做一写更新都会重新撰写建表语句，如果在项目已经上线的情况下，表中会有大量的数据，频繁的重建很浪费事件，所以我们需要学习修改已创建的表</p><p>重新创建一个测试表用来练习：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `USER` (<br> `ID` INT(3) AUTO_INCREMENT COMMENT &#x27;用户ID&#x27;,<br> `NAME` VARCHAR(10) NOT NULL COMMENT &#x27;昵称&#x27;,<br> `USER_ID` VARCHAR(20) COMMENT &#x27;账号&#x27;,<br> `PASSWORD` VARCHAR(20) COMMENT &#x27;密码&#x27;<br>) COMMENT &#x27;用户表&#x27;<br></code></pre></td></tr></table></figure><blockquote><p>表级修改</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 修改表的名称<br>rename table `USER` TO `T_EMP`;<br></code></pre></td></tr></table></figure><blockquote><p>列级修改</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- ADD：新增一个列<br>ALTER TABLE `T_EMP` ADD `SEX `ENUM (&#x27;男&#x27;, &#x27;女&#x27;);<br><br>-- MODIFY：修改列的信息，新的列会直接覆盖旧的列，所以请将属性写全不然会丢失<br>ALTER TABLE `T_EMP` MODIFY `SEX` ENUM (&#x27;男&#x27;, &#x27;女&#x27;) DEFAULT &#x27;男&#x27;;<br><br>-- CHANGE：修改列以及列名，新的列会直接覆盖旧的列，所以请将属性写全不然会丢失<br>ALTER TABLE `T_EMP` CHANGE `SEX` `GENDER` ENUM (&#x27;男&#x27;, &#x27;女&#x27;) COMMENT &#x27;性别&#x27;;<br><br>-- 删除某个列<br>ALTER TABLE `T_EMP` DROP `GENDER`;<br></code></pre></td></tr></table></figure><blockquote><p>约束修改</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 新建表用来测试约束<br>CREATE TABLE `TEST` (<br> `ID` INT(5),<br> `UUID` INT(3) UNSIGNED,<br> `NAME` VARCHAR(10)<br>) COMMENT &#x27;测试约束&#x27;<br><br>-- 在列上添加约束<br>ALTER TABLE `TEST` ADD PRIMARY KEY(`ID`)<br>ALTER TABLE `TEST` ADD FOREIGN KEY(`UUID`) REFERENCES`DEPT`(`ID`)  -- 无意义 为了测试<br>ALTER TABLE `TEST` ADD UNIQUE(`NAME`)<br><br># 在列上移除某个约束<br>#   想要删除约束，首先我们需要知道约束名称，查看一下表结构：SHOW CREATE TABLE`TEST`<br>#   在表结构中可以看到约束对应的名称，然后通过名称完成删除约束<br><br>-- 删除外键约束，FOREIGN KEY 后面跟上约束名称<br>ALTER TABLE `TEST` DROP FOREIGN KEY `test_ibfk_1`;<br><br>-- 删除唯一约束，INDEX 后面跟上约束名称<br>ALTER TABLE `TEST` DROP INDEX `NAME`;<br><br>-- 删除主键约束，会删除表中所有主键(必须)，无需名称<br>ALTER TABLE `TEST` DROP PRIMARY KEY;<br></code></pre></td></tr></table></figure><blockquote><p>自增修改</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 重置自增值：要求当前表中数据为空或者当前表的自增列的最大值小于你要设置的值<br>ALTER TABLE `123` AUTO_INCREMENT = 1;<br>-- 修改自增的步长，属于全局修改，会在所有库所有表中生效<br>SET @@auto_increment_increment=2;<br></code></pre></td></tr></table></figure><p>对于已创建的表的修改，自始至终还是有些捉摸不透，建议还是通过可视化工具进行操作</p><h2 id="扩展：三大范式">扩展：三大范式</h2><p>我们在书写一个程序的时候，设计数据库往往是最重要的一个环节，一个程序中的所有业务逻辑都是围绕着数据进行操作的，表结构设计的好程序写起来就省力一些，相反表结构设计的不好，程序写起来就比较麻烦，所以建议我们在设计数据库的时候参照一下数据库设计<strong>三大范式</strong></p><blockquote><p>第一范式：原子性</p></blockquote><table><thead><tr><th style="text-align:center">员工ID</th><th style="text-align:center">员工姓名</th><th style="text-align:center">部门职位</th><th style="text-align:center">员工薪资</th></tr></thead><tbody><tr><td style="text-align:center">4163545354</td><td style="text-align:center">王富贵</td><td style="text-align:center">技术部开发</td><td style="text-align:center">8000</td></tr></tbody></table><p>第一范式通俗来说就是表中的<em>每列都不可再分</em>，类似上面这张员工表，其中的<code>部门职位</code>可以进行拆分为<code>部门</code>和<code>职位</code>两列，违反了第一范式，应该按照下面的格式进行设计：</p><table><thead><tr><th style="text-align:center">员工ID ( 主键 )</th><th style="text-align:center">员工姓名</th><th style="text-align:center">部门</th><th style="text-align:center">职位</th><th style="text-align:center">员工薪资</th></tr></thead><tbody><tr><td style="text-align:center">4163545354</td><td style="text-align:center">王富贵</td><td style="text-align:center">技术部</td><td style="text-align:center">开发</td><td style="text-align:center">8000</td></tr></tbody></table><blockquote><p>第二范式：完整性</p></blockquote><p>一张表一般只有一个主键列用来区分每一行，但是有的表会使用到联合主键，第二范式就是要求<em>所有列都要与主键列相关而不是和部分主键相关</em>，例如下面张成绩表：</p><table><thead><tr><th style="text-align:center">学生 ID ( 主键1 )</th><th style="text-align:center">课程 ID ( 主键2 )</th><th style="text-align:center">课程名称</th><th style="text-align:center">分数</th></tr></thead><tbody><tr><td style="text-align:center">31718040101</td><td style="text-align:center">82001</td><td style="text-align:center">《Java高级从入门到入坟》</td><td style="text-align:center">82</td></tr></tbody></table><p>课程名称仅仅和课程 ID 有关系，与学生 ID 没有关系，这就违反了第二范式，应该将课程名称放到课程表中。</p><blockquote><p>第三范式：直接关系</p></blockquote><p>第三范式可以理解为*表中的每个字段都应该与主键有直接关系，而不是间接关系，*例如这张博客表中的分类名称就违反了第三范式，他应该是通过分类 ID 查出来的信息，不应该直接写到博客表中，应该写到分类表中</p><table><thead><tr><th style="text-align:center">博客 ID ( 主键 )</th><th style="text-align:center">分类 ID</th><th style="text-align:center">分类名称</th><th style="text-align:center">博客标题</th><th style="text-align:left">博客内容</th></tr></thead><tbody><tr><td style="text-align:center">B348500012</td><td style="text-align:center">2</td><td style="text-align:center">知识</td><td style="text-align:center">Java入门教程</td><td style="text-align:left">Java是面向对象的高级语言…</td></tr></tbody></table><ul><li>第三范式和第二范式很相像，第二范式是针对联合主键的，而第三范式是针对当前表和唯一主键的。</li><li>三大范式仅仅是一个规范，起到参考作用，但是在真实项目中要按照实际业务进行设计</li></ul><h1>数据的增删改查</h1><h2 id="简单练习CRUD">简单练习CRUD</h2><p>创建一张新的表用来进行测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `T_EMP` (<br> `ID` INT(3) AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,<br> `NAME` VARCHAR(15) NOT NULL COMMENT &#x27;姓名&#x27;,<br> `AGE` INT(3) NOT NULL COMMENT &#x27;年龄&#x27;,<br> `PHONE` CHAR(11) COMMENT &#x27;联系电话&#x27;,<br> `SALARY` INT(6) NOT NULL COMMENT &#x27;薪水&#x27;,<br> `ADDRESS` VARCHAR(128) COMMENT &#x27;家庭住址&#x27;,<br> `ENTER_TIME` DATETIME COMMENT &#x27;入职时间&#x27;,<br>  PRIMARY KEY(`ID`),<br>  UNIQUE(`PHONE`)<br>) COMMENT &#x27;员工表&#x27;<br></code></pre></td></tr></table></figure><p>表肯定是要存储数据的，那么肯定就要有对数据的操作了，这里简单练习增删改查：</p><blockquote><p>插入：INSERT</p></blockquote><p><code>INSERT</code>代表插入，<code>INTO</code>插入到<code>T_EMP</code>表，<code>VALUES</code>代表插入的具体的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 全字段插入 INSERT INTO 表名 VALUES(值1，值2...)<br>INSERT INTO `T_EMP` VALUES(NULL, &#x27;张涵哲&#x27;, 22, &#x27;13344445555&#x27;, 4000, &#x27;大连市&#x27;, &#x27;2019-11-11 12:00:00&#x27;);<br><br>-- 按需插入 INSERT INTO 表名(字段1，字段2) VALUES(值1，值2)<br>INSERT INTO `T_EMP`(`NAME`, `AGE`, `SALARY`) VALUES(&#x27;丁聪华&#x27;, 24, 4800);<br>  <br>-- 批量插入  ...VALUES(值1，值2), (值1，值2), (值1，值2)...<br>INSERT INTO `T_EMP` VALUES<br>  (NULL, &#x27;孙蝶妃&#x27;, 19, &#x27;13300000001&#x27;, 3800, &#x27;桂林西街&#x27;, &#x27;2019-11-11 12:00:00&#x27;),<br>  (NULL, &#x27;许娇翔&#x27;, 31, &#x27;13300000002&#x27;, 5000, &#x27;徐汇区&#x27;, &#x27;2000-09-14 12:00:00&#x27;),<br>  (NULL, &#x27;崔子希&#x27;, 36, &#x27;13300000003&#x27;, 4500, &#x27;浦东区&#x27;, &#x27;2012-10-21 12:00:00&#x27;),<br>  (NULL, &#x27;樊瑶芳&#x27;, 28, NULL, 6000, &#x27;虹鹰大厦&#x27;, &#x27;2020-01-18 12:00:00&#x27;),<br>  (NULL, &#x27;阮恭琴&#x27;, 25, &#x27;13300000004&#x27;, 5300, NULL, &#x27;2018-12-25 12:00:00&#x27;),<br>  (NULL, &#x27;姚道益&#x27;, 39, &#x27;13300000005&#x27;, 13000, &#x27;徐汇区&#x27;, &#x27;2015-01-01 12:00:00&#x27;),<br>  (NULL, &#x27;朱咏娴&#x27;, 52, NULL, 11000, &#x27;桂林西街&#x27;, &#x27;1999-06-11 12:00:00&#x27;),<br>  (NULL, &#x27;郭秀晶&#x27;, 46, NULL, 12000, &#x27;桂林西街&#x27;, &#x27;2008-04-28 12:00:00&#x27;),<br>  (NULL, &#x27;戴敏&#x27;, 33, &#x27;13300000006&#x27;, 8300, NULL, &#x27;2018-08-21 12:00:00&#x27;),<br>  (NULL, &#x27;马庆炳&#x27;, 19, &#x27;13300000007&#x27;, 4500, &#x27;万泰国际&#x27;, &#x27;2021-01-01 12:00:00&#x27;),<br>  (NULL, &#x27;伍兆斌&#x27;, 21, NULL, 6000, &#x27;虹鹰大厦&#x27;, &#x27;2019-11-11 12:00:00&#x27;),<br>  (NULL, &#x27;张滕龙&#x27;, 47, NULL, 11500, NULL, &#x27;2014-04-30 12:00:00&#x27;)<br>  (NULL, &#x27;王林&#x27;, 20, &#x27;13300000010&#x27;, 7800, &#x27;王家村&#x27;, &#x27;2015-11-11 12:00:00&#x27;),<br>  (NULL, &#x27;胖虎&#x27;, 15, &#x27;13300000011&#x27;, 4300, &#x27;幸福大街&#x27;, &#x27;2015-11-11 12:00:00&#x27;),<br>  (NULL, &#x27;张楚岚&#x27;, 19, &#x27;13300000012&#x27;, 9300, &#x27;异人村&#x27;, &#x27;2015-11-11 12:00:00&#x27;),<br>  (NULL, &#x27;张楚岚&#x27;, 19, &#x27;13300000013&#x27;, 9300, &#x27;异人村&#x27;, &#x27;2015-11-11 12:00:00&#x27;),<br>  (NULL, &#x27;贾正经&#x27;, 23, NULL, 3800, &#x27;陕西&#x27;, &#x27;2015-11-11 12:00:00&#x27;),<br>  (NULL, &#x27;袁天罡&#x27;, 65, &#x27;13300000014&#x27;, 3800, NULL, &#x27;2015-11-11 12:00:00&#x27;),<br>  (NULL, &#x27;张译&#x27;, 36, &#x27;13000000015&#x27;, 13000, &#x27;蘑菇街&#x27;, &#x27;2015-11-11 12:00:00&#x27;);<br></code></pre></td></tr></table></figure><blockquote><p>查询：SELECT</p></blockquote><p><code>SELECT</code>代表查询<code>*</code>所有字段的值，<code>FROM</code>从<code>T_EMP</code>表中进行查询，<code>WHERE</code>代表过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询所有数据<br>SELECT * FROM `T_EMP`<br><br>-- 查询某一列的值<br>SELECT `NAME`, `ADDRESS` FROM `T_EMP`<br><br>-- 初识WHERE条件关键字，这里指定查询姓名为&#x27;崔子希&#x27;的员工<br>SELECT * FROM `T_EMP` WHERE `NAME` = &#x27;崔子希&#x27;<br></code></pre></td></tr></table></figure><blockquote><p>更新：UPDATE</p></blockquote><p><code>UPDATE</code>修改<code>T_EMP</code>表中的<code>set</code>姓名哈哈哈，<code>WHERE</code>要求修改ID为7的员工</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 修改数据，如果不加后面的 WHERE 就会将所有行都修改<br>UPDATE `T_EMP` SET `NAME` = &#x27;哈哈哈&#x27; WHERE `ID` = 7<br></code></pre></td></tr></table></figure><blockquote><p>删除：DELETE</p></blockquote><p><code>DELETE FROM</code>删除<code>T_EMP</code>表中的数据，<code>WHERE</code>要求删除数据的ID为14</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 删除数据，如果不加后面的 WHERE 就会全部删除，谨慎使用<br>DELETE FROM `T_EMP` WHERE `ID` = 14<br></code></pre></td></tr></table></figure><h2 id="条件查询与运算符">条件查询与运算符</h2><blockquote><p>简单运算符主要分为两种</p></blockquote><p><strong>比较运算符：</strong></p><ul><li>【大于 &gt;】【小于 &lt;】【等于 =】【大于等于 &gt;=】【小于等于 &lt;=】【不等于 ( &lt;&gt; 或者 != ) 】</li></ul><p><strong>逻辑运算符：</strong></p><ul><li>【与 AND】【或 OR】【非 NOT】</li></ul><p>特殊运算符</p><ul><li>是否为空：【IS NULL】【IS NOT NULL】</li><li>包含以下任意一个值：IN ( 值，值，值 )<ul><li>在<code>IN</code>的括号中不仅可以书写特定的值，也可以查询列作为参数，被称为子表查询</li></ul></li><li>满足在指定的区间内：<code>BETWEEN 最小值 AND 最大值</code>;</li></ul><blockquote><p>WHERE 条件语句</p></blockquote><p>上面有用到过<code>WHERE</code>，可以通过<code>WHERE</code>配合运算符来筛选出符合条件的数据进行操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询ID为1的员工<br>SELECT * FROM `T_EMP` WHERE `ID` = 1<br><br>-- 查询薪水一万以上的员工<br>SELECT * FROM `T_EMP` WHERE `SALARY` &gt; 10000<br><br>-- 查询2005年前入职的员工<br>SELECT * FROM `T_EMP` WHERE `ENTER_TIME` &lt; &#x27;2005-01-01 00:00:00&#x27;<br><br>-- 查询年龄小于20或者大于40的员工<br>SELECT * FROM `T_EMP` WHERE `AGE` &lt; 20 OR `AGE` &gt; 40<br><br>-- 查询年龄大于35薪水低于一万的员工<br>SELECT * FROM `T_EMP` WHERE `AGE` &gt; 35 AND `SALARY` &lt; 10000<br></code></pre></td></tr></table></figure><h2 id="更多查询操作">更多查询操作</h2><p>上面接触的比较运算符配合逻辑运算符可以完成大多数操作，这里继续学习更多的查询技巧</p><blockquote><p>IN 包含</p></blockquote><p>要求查询崔子希，朱咏娴，马庆炳，贾正经四个员工的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- OR进行查询</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  <span class="hljs-keyword">WHERE</span> `NAME` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;崔子希&#x27;</span><br>    <span class="hljs-keyword">OR</span> `NAME` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;朱咏娴&#x27;</span><br>    <span class="hljs-keyword">OR</span> `NAME` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;马庆炳&#x27;</span><br>    <span class="hljs-keyword">OR</span> `NAME` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;贾正经&#x27;</span>;<br></code></pre></td></tr></table></figure><p>使用<code>OR</code>关键字的确可以达到目的，但是使用<code>IN</code>的话可以极大简化SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 只要NAME匹配括号内的任意一项都可以查询到</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  <span class="hljs-keyword">WHERE</span> `NAME` <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;崔子希&#x27;</span>, <span class="hljs-string">&#x27;朱咏娴&#x27;</span>, <span class="hljs-string">&#x27;马庆炳&#x27;</span>, <span class="hljs-string">&#x27;贾正经&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>AS 别名</p></blockquote><p>有些时候表中的列过多可能会造成查看失误，针对这点可以对每列在查询是起一个别名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 正常查询</span><br><span class="hljs-keyword">SELECT</span> <br>  `ID`,<br>  `NAME`,<br>  `AGE`,<br>  `PHONE`,<br>  `SALARY`,<br>  `ADDRESS`,<br>  `ENTER_TIME`<br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br><br><span class="hljs-comment">-- 别名查询</span><br><span class="hljs-keyword">SELECT</span> <br>  `ID` <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;编号&#x27;</span>,<br>  `NAME` <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  `AGE` <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  `PHONE` <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;电话&#x27;</span>,<br>  `SALARY` <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;薪水&#x27;</span>,<br>  `ADDRESS` <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;住址&#x27;</span>,<br>  `ENTER_TIME` <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;入职日期&#x27;</span><br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  <br><span class="hljs-comment">-- 一般情况下AS关键字可以省略不写，例如</span><br><span class="hljs-keyword">SELECT</span> `ID` <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;编号&#x27;</span><br><span class="hljs-comment">-- 可以简写为</span><br><span class="hljs-keyword">SELECT</span> `ID` <span class="hljs-string">&#x27;编号&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>BETWEEN  AND 区间</p></blockquote><p>查询年龄在20到50之前的员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 一般写法</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  <span class="hljs-keyword">WHERE</span> `AGE` <span class="hljs-operator">&gt;=</span> <span class="hljs-number">20</span><br>    <span class="hljs-keyword">AND</span> `AGE` <span class="hljs-operator">&lt;=</span> <span class="hljs-number">50</span><br>    <br><span class="hljs-comment">-- 区间写法，两种写法是等价的</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  <span class="hljs-keyword">WHERE</span> `AGE` <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><blockquote><p>LIKE 模糊查询</p></blockquote><p>模糊查询，顾名思义，列中有部分匹配的内容就可以查询的到，模糊查询需要配合通配符使用，否则不起效果，MySQL中针对模糊查询有两个通配符：</p><ul><li><code>_</code>：下划线，只匹配一个字符</li><li><code>%</code>：百分号，匹配多个字符</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 模糊查询_  找到以&quot;张&quot;开头的姓名为两个字的员工</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  <span class="hljs-keyword">WHERE</span> `NAME` <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;张_&#x27;</span><br>  <br><span class="hljs-comment">-- 模糊查询% 找到所有姓名以&quot;张&quot;开头的员工</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  <span class="hljs-keyword">WHERE</span> `NAME` <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;张%&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>DISTINCT：去重 ( 了解 )</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询所有员工的姓名</span><br><span class="hljs-keyword">SELECT</span> `NAME` <span class="hljs-keyword">FROM</span> `T_EMP`<br></code></pre></td></tr></table></figure><p>我们发现了在员工表中有两个张楚岚，这里可以针对重复数据进行去重操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 在查询的字段`NAME`前加上关键字，代表根据这个字段进行去重</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> `NAME` <span class="hljs-keyword">FROM</span> `T_EMP`<br></code></pre></td></tr></table></figure><p>这回就可以看出重复数据已经不见了，但是只查询出了姓名不是我想要的，最起码要与ID一同查出来才可以，我们改一下SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> `NAME`, `ID` <span class="hljs-keyword">FROM</span> `T_EMP`<br></code></pre></td></tr></table></figure><p>发现了一个问题，ID列的确查询出来了，但是去重效果却消失了，这是因为按照上述写法，首先根据姓名进行判断是否重复，然后找到姓名重复的行再根据ID进行判断，ID不重复就代表数据没有重复</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 那么我们尝试一下把ID放在去重前面进行查询</span><br><span class="hljs-keyword">SELECT</span> `ID`, <span class="hljs-keyword">DISTINCT</span> `NAME` <span class="hljs-keyword">FROM</span> `T_EMP`<br></code></pre></td></tr></table></figure><p>这回更糟糕，SQL直接报错了，因为使用<code>DISTINCT</code>就必须放在查询开头，所以<code>DISTINCT</code>一般不用做真正的去重，可以根据他查询不重复数据的数量，如何进行去重操作也会在后面在提到</p><blockquote><p>NULL值操作</p></blockquote><p>如果实现查询所有没有留下手机号的员工，SQL应该这么写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `T_EMP` <span class="hljs-keyword">WHERE</span> `PHONE` <span class="hljs-operator">=</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><p>可实际效果却是一条都查不出来，那是因为<em>NULL值是不参与运算</em>的，这里需要使用<code>IS NULL</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `T_EMP` <span class="hljs-keyword">WHERE</span> `PHONE` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><p>如果想查所有留了手机号的员工呢？之前逻辑运算中接触的<code>NOT</code>就用上了，它的作用就是取反</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `T_EMP` <span class="hljs-keyword">WHERE</span> `PHONE` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><h2 id="排序与分页">排序与分页</h2><p>我们在网页上操作一些表格数据的时候肯定使用过排序和分页的功能，这些都是前端发起的请求最终移交到数据库进行处理的，这里就学习一下排序与分页</p><blockquote><p>ORDER BY：排序</p></blockquote><p>排序有两种规则，一种是升序，一种是降序，分别对应着两个关键字：</p><ul><li><code>ASC</code>：升序，首行值最小，末行值最大</li><li><code>DESC</code>：降序，首行值最打，末行值最小</li></ul><p><code>ORDER BY</code>排序，根据<code>SALARY</code>字段进行<code>ASC</code>升序排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 根据薪水升序排序</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `SALARY` <span class="hljs-comment">-- ASC</span><br></code></pre></td></tr></table></figure><p><code>ASC</code>升序排序是默认排序规则，所以可以省略不写，如果想倒排的话就需要写<code>DESC</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 根据薪水倒叙排序</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `SALARY` <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><p>可以多列同时排序，每个排序规则用逗号隔开，例如下面这段SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 先按照薪水进行降序排序，薪水相同的按照年龄年龄进行升序排序</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>    `SALARY` <span class="hljs-keyword">DESC</span>,<br>    `AGE` <span class="hljs-keyword">ASC</span><br></code></pre></td></tr></table></figure><blockquote><p>LIMIT：分页</p></blockquote><p>MySQL中分页使用的关键字为<code>LIMIT</code>，使用起来比较简单，如下所示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 从第0个开始，查询5条数据，为第一页</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  LIMIT <span class="hljs-number">0</span>, <span class="hljs-number">5</span><br><span class="hljs-comment">-- 从第5个开始，查询5条数据，为第二页</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  LIMIT <span class="hljs-number">5</span>, <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><code>LIMIT</code>后面第一个参数是从第几条开始查，第二个参数是查询多少个数据，按照分页的逻辑只需要传入页码和查询数量就可实现分页查询，那么SQL应该修改为下面这种写法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- pageNum，pageSize为程序传过来的参数</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  <span class="hljs-comment">-- 计算的步骤应该交给Java处理，SQL这边只需要获取到值就可以了</span><br>  LIMIT (pageNum <span class="hljs-operator">-</span> <span class="hljs-number">1</span>) <span class="hljs-operator">*</span> pageSize, pageSize<br><br><span class="hljs-comment">-- 例如：查询第二页，每页显示6条，就应该写</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> `T_EMP`<br>  LIMIT <span class="hljs-number">6</span>, <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h1>函数相关操作</h1><p>先放一段落</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">聚合函数</span><br><span class="hljs-section">--------------------------------</span><br>计数：COUNT()<br>求和：SUM()<br>平均值：AVG()<br>最大值：MAX()<br>最小值：MIN()<br><br><br><br><br><span class="hljs-section">数学函数</span><br><span class="hljs-section">--------------------------------</span><br>绝对值：ABS()<br>向上取整：CEILING()<br>向下取证：FLOOR()<br>0~1随机数：RAND()<br>判断符号：SIGN() 负数返回-1，正数返回1，0返回0<br><br><br><br><span class="hljs-section">字符串函数</span><br><span class="hljs-section">--------------------------------</span><br>字符串长度：CHAR_LENGTH()<br>字符串拼接：CONCAT(...)<br>全部转大写：UPPER()<br>全部转小写：LOWER()<br>字符串替换：REPLACE(str, source, target)<br>截取字符串：SUBSTR()<br>字符串翻转：REVERSE()<br><br><br><br><br><span class="hljs-section">时间函数</span><br><span class="hljs-section">--------------------------------</span><br>获取当前日期：CURRENT<span class="hljs-emphasis">_DATE()</span><br><span class="hljs-emphasis">获取当前时间：CURRENT_</span>TIME()<br>获取日期时间：NOW()<br></code></pre></td></tr></table></figure><h2 id="聚合函数">聚合函数</h2><h2 id="分组与分组函数">分组与分组函数</h2><h2 id="其他常用函数">其他常用函数</h2><h3 id="数学函数">数学函数</h3><h3 id="字符串函数">字符串函数</h3><h3 id="时间函数">时间函数</h3><h1>多表链接查询</h1><h1>MySQL的事务</h1><h1>视图与索引</h1><h1>用户权限管理</h1>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/01/hello-world/"/>
    <url>/2022/06/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>demo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus 学习笔记</title>
    <link href="/2022/05/23/MyBatis-Plus%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/23/MyBatis-Plus%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>MyBatis-Plus 学习笔记</h1><p>MyBatis-Plus ( 简称 MP ) 是一款基于 MyBatis 的增强工具，他并不是由官方提供，而是由个人开发出来的一款增强框架，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生，后面 mybatis-plus 会简称为 MP</p><blockquote><p>官方自述</p></blockquote><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="快速入门初体验">快速入门初体验</h2><p>跟着官方文档进行一次 MP 的快速入门体验：</p><blockquote><p>前置条件准备</p></blockquote><p>**1.**创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 初始化测试</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `<span class="hljs-keyword">USER</span>`;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> T_USER;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">USER</span>`(<br>  ID <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>  `NAME` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  AGE <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  EMAIL <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;邮箱&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (id)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">USER</span>`(ID, `NAME`, AGE, EMAIL) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;test1@qq.com&#x27;</span>),<br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;王富贵&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;test2@qq.com&#x27;</span>),<br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;老八&#x27;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&#x27;test3@qq.com&#x27;</span>),<br>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;马云&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;test4@qq.com&#x27;</span>),<br>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;王健林&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;test5@qq.com&#x27;</span>);<br><br><span class="hljs-comment">-- 测试表名称绑定</span><br>RENAME <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">TO</span> T_USER;<br><br><span class="hljs-comment">-- 自动填充练习</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> T_USER <span class="hljs-keyword">ADD</span> CREATE_TIME DATETIME <span class="hljs-keyword">DEFAULT</span> NOW();<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> T_USER <span class="hljs-keyword">ADD</span> CHANGE_TIME DATETIME <span class="hljs-keyword">DEFAULT</span> NOW();<br><br><span class="hljs-comment">-- 乐观锁练习</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> T_USER <span class="hljs-keyword">ADD</span> VERSION <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 逻辑删除练习</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> T_USER <span class="hljs-keyword">ADD</span> DELETED <span class="hljs-type">INT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>**2.**快速创建一个 springboot 的程序引入相关的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- maven依赖引入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.49<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- mybatis-plus依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>**3.**配置数据库连接</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql:///zhe</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">******</span><br><span class="hljs-comment"># 这里配置了日志输入，方便日后观察</span><br><span class="hljs-attr">mybatis-plus.configuration.log-impl</span>=<span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><blockquote><p>开始编码</p></blockquote><p>在我们把数据库以及程序都布置好了之后，我们尝试做一次简单的查询：</p><p>**1.**创建实体类以及 dao 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建数据表对应的实体类</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><p>**2.**创建 dao 接口，这里需要注意 <font color="red">接口类需要继承 <code>BaseMapper</code> 抽象类并填写实体类对应泛型</font>，然后就不用管了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建dao接口</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123; &#125;<br></code></pre></td></tr></table></figure><p>**3.**接下来我们在测试类中书写代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot01MybatisPlusApplicationTests</span> &#123;<br><br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">private</span> UserDao ud;<br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>  ud.selectList(<span class="hljs-literal">null</span>).forEach( item-&gt;System.out.println(item) );<br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>查询就这么简单的完成了！</p><h2 id="快速CRUD练习">快速CRUD练习</h2><blockquote><p>insert 插入</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 快速插入一条数据</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot01Test</span> &#123;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> UserDao ud;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>      user.setName(<span class="hljs-string">&quot;张涵哲&quot;</span>);<br>      user.setAge(<span class="hljs-number">50</span>);<br>      user.setEmail(<span class="hljs-string">&quot;zhang_hanzhe@qq.com&quot;</span>);<br>      ud.insert(user);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>update 更新</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 快速更新一条数据</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot01Test</span> &#123;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> UserDao ud;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>      user.setName(<span class="hljs-string">&quot;张涵哲&quot;</span>);<br>      user.setAge(<span class="hljs-number">21</span>);<br>      user.setEmail(<span class="hljs-string">&quot;zhang_hanzhe@qq.com&quot;</span>);<br>      ud.updateById(user);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>delete 删除</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot01Test</span> &#123;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> UserDao ud;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 根据ID删除</span><br>      ud.deleteById(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// 根据ID删除多个</span><br>      ud.deleteBatchIds(Arrays.asList(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));<br>      <span class="hljs-comment">// 根据条件删除</span><br>      HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张涵哲&quot;</span>);<br>      ud.deleteByMap(map);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>select 查询</p></blockquote><p>由于刚刚的测试将数据都删光了，这里建议在执行一次初始化的 SQL 重置一下数据，然后在跟着测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot01Test</span> &#123;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> UserDao ud;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 根据ID查询</span><br>      System.out.println(ud.selectById(<span class="hljs-number">1L</span>));<br>      <span class="hljs-comment">// 根据指定ID查询多个</span><br>      System.out.println(ud.selectBatchIds(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)));<br>      <span class="hljs-comment">// 查询所有</span><br>      System.out.println(ud.selectList(<span class="hljs-literal">null</span>));<br>      <span class="hljs-comment">// 根据条件查询</span><br>      HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;老八&quot;</span>);<br>      System.out.println(ud.selectByMap(map));<br>      <span class="hljs-comment">// 查询总记录数</span><br>      System.out.println(ud.selectCount(<span class="hljs-literal">null</span>));<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常用注解学习">常用注解学习</h2><h3 id="TableName注解">TableName注解</h3><p>刚刚我们快速过了一遍 CRUD，表名和实体类是对应的，如果我们稍作修改的话再来尝试一下：</p><ul><li>表名：<code>T_USER</code>，实体类名：<code>UserEntity</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">org.springframework.jdbc.BadSqlGrammarException: <br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## Error querying database.  Cause: com.mysql.jdbc.exceptions.jdbc4.MySQ                                                                LSyntaxErrorException: Table &#x27;zhe.user_entity&#x27; doesn&#x27;t exist</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## The error may exist in site/hanzhe/dao/UserDao.java (best guess)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## The error may involve defaultParameterMap</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## The error occurred while setting parameters</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## SQL: SELECT  id,name,age,email  FROM user_entity</span></span><br>......<br></code></pre></td></tr></table></figure><p>这里就可以发现程序报错了，因为他的 SQL 是自动生成的，自动生成的表明默认按照实体类的驼峰转下划线完成的，那么这里就需要使用 <code>@TableName</code> 来重新配置一下了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;T_USER&quot;)</span> <span class="hljs-comment">// 默认属性就是表名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>查询成功！该注解主要用于实体类和表名称的绑定，除此之外还有其他功能但并不常用，如有需要去查官方文档</p><h3 id="TableId-主键注解">TableId 主键注解</h3><p>仔细看之前的插入语句会发现有一个细节：==我们并没有为这个对象设置 ID，但是数据库中却存进去了 ID==，这是因为 MP 会对表中的主键自动生成一个 ID，关于主键自动填充我们需要了解一下 <code>@TableId</code> 主键注解</p><p><code>@TableId</code> 默认 <code>value</code> 对应的是主键字段名称，第二个<code>type</code> 是枚举类型，用来修改自动生成类型：</p><ul><li><code>IdType.AUTO</code>：对应数据库中的自增</li><li><code>IdType.NONE</code>：不对主键进行任何处理</li><li><code>IdType.INTUT</code>：我们在执行插入之前手动设置值</li><li><code>IdType.ASSIGN_ID</code>：使用<strong>雪花算法</strong>计算 ID</li><li><code>IdType.ASSIGN_UUID</code>：分配 UUID</li></ul><blockquote><p>修改自动生成类型</p></blockquote><p>==使用 AUTO 类型必须将数据库中的自增开启==，剩下的类型如法炮制，就不写了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;T_USER&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span>&#123;<br>    <span class="hljs-comment">// 这里修改了变量名为 aaa，但是通过value绑定了数据中的字段名，所以不会报错</span><br>    <span class="hljs-meta">@TableId(value = &quot;ID&quot;, type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Long aaa;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TableField-非主键注解">TableField 非主键注解</h3><p>既然由主键注解，当然也就有非主键注解 <code>@TableField</code>，一般用来绑定库内的字段名，还可以进行一些高级操作</p><blockquote><p>自动填充</p></blockquote><p>在我们创建表的时候，有的表会涉及到时间列，包含创建时间以及修改时间，这两个我们可以通过 SQL 写死，也可以在 java 中创建一个 Date 实例丢给他，学习了 MP 之后我们就可以使用自动填充了 ( 自己创建好两个列 )：</p><p><strong>1.</strong><code>TableField</code> 注解中的 <code>fill</code> 表示自动填充，使用自动填充一定要知道什么情况下被填充，填充的内容是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实体类配置</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;T_USER&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span>&#123;<br> ......<br>    <span class="hljs-comment">// FieldFill.INSERT: 只有在插入的时候填充</span><br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br>    <span class="hljs-comment">// FieldFill.INSERT_UPDATE: 插入和修改的时候都填充</span><br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br>    <span class="hljs-keyword">private</span> Date changeTime;<br>&#125;<br></code></pre></td></tr></table></figure><p>**2.**实体类配置好自动填充时机时候，我们还要配置一下自动填充的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在配置类中配置自动填充内容</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FillConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MetaObjectHandler</span> &#123;<br>    <span class="hljs-comment">// 书写规则：第一个写死，第二个为填充的目标变量名，第三个为填充类型，第四个是对应的值</span><br>    <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">// 插入级别配置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        <span class="hljs-comment">// INSERT</span><br>        <span class="hljs-built_in">this</span>.strictInsertFill(metaObject, <span class="hljs-string">&quot;createTime&quot;</span>, Date.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        <span class="hljs-comment">// INSERT_UPDATE</span><br>        <span class="hljs-built_in">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;changeTime&quot;</span>, Date.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br>    <span class="hljs-meta">@Override</span>  <span class="hljs-comment">// 更新级别配置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        <span class="hljs-comment">// UPDATE</span><br>        <span class="hljs-built_in">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;changeTime&quot;</span>, Date.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>非表中字段</p></blockquote><p>实体类中并不是每个属性都是表中的字段，例如表中的性别字段，1代表男，0代表女，区分起来就很麻烦，为了解决这个问题我们需要在类中定义两个常量，再告诉 MP 这不是表中的字段，就解决了这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;T_USER&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span>&#123;<br>    <span class="hljs-meta">@TableId(value = &quot;ID&quot;, type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Long aaa;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Integer gender;<br>    <span class="hljs-keyword">private</span> String email;<br>    <br>    <span class="hljs-meta">@TableField(exist = false)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MALE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;   <span class="hljs-comment">// 男</span><br>    <span class="hljs-meta">@TableField(exist = false)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">FEMALE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 女</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Version-乐观锁">Version 乐观锁</h3><p>所谓乐观锁就是在数据库中添加一个列作为标识列，一般为 version，在进行 upd ate 之前先进行 select 查询，如果查询的 version 和更新时的 version 是一致的就证明没人操作过这行记录，那么就进行修改，并且修改 version 列，如果查询时和修改时的列不一致就证明有人进行了修改，为了防止脏读就会取消更新。</p><blockquote><p>测试乐观锁</p></blockquote><p>在使用乐观锁之前我们需要添加乐观锁插件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> OptimisticLockerInterceptor <span class="hljs-title function_">optimisticLockerInterceptor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimisticLockerInterceptor</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>乐观锁对应注解为 <code>@Version</code>，没有任何参数，如果变量名与字段名对应不上可以使用 <code>@TableFiels</code> 注解进行绑定，记得在测试之前要在数据库中添加标识字段 ( 建议使用 version )：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实体类代码</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;T_USER&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span>&#123;<br>    ......<br>    <span class="hljs-meta">@Version</span>   <span class="hljs-comment">// 添加@Version注解</span><br>    <span class="hljs-keyword">private</span> Integer version;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要这两步，这样一来乐观锁就配置完成了，现在我们来开始测试 ( version 默认是 1 )：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot01Test</span> &#123;<br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">private</span> UserDao ud;<br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 按照乐观锁的逻辑，修改前先获取到version，然后在修改的时候在传过去，如果值一样就可以修改</span><br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> ud.selectById(<span class="hljs-number">2L</span>).getVersion();<br>  <span class="hljs-type">UserEntity</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>();<br>  user.setAaa(<span class="hljs-number">2L</span>);<br>  user.setEmail(<span class="hljs-string">&quot;fu_gui@qq.com&quot;</span>);<br>  user.setVersion(version);<br>  ud.updateById(user);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试运行成功！version 字段被修改成了 2，再次测试一样成功！version 变成 3，按照之前分析的逻辑每次更新时 version 都会发生变化，现在我们来模拟一次更新失败的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot01Test</span> &#123;<br><br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">private</span> UserDao ud;<br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 在修改前获取到version</span><br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> ud.selectById(<span class="hljs-number">2L</span>).getVersion();<br>  <span class="hljs-type">UserEntity</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>();<br>  user1.setAaa(<span class="hljs-number">2L</span>);<br>  user1.setEmail(<span class="hljs-string">&quot;update1@qq.com&quot;</span>);  <span class="hljs-comment">// 注意这里是update1</span><br>  user1.setVersion(v1);<br>  <span class="hljs-comment">// 在执行修改之前另一个人进行了操作并且完成了修改</span><br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> ud.selectById(<span class="hljs-number">2L</span>).getVersion();<br>  <span class="hljs-type">UserEntity</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>();<br>  user2.setAaa(<span class="hljs-number">2L</span>);<br>  user2.setEmail(<span class="hljs-string">&quot;update2@qq.com&quot;</span>);  <span class="hljs-comment">// 注意这里是update2</span><br>  user2.setVersion(v2);<br>  System.out.println(ud.updateById(user2));  <span class="hljs-comment">// 这里执行了2</span><br>  <span class="hljs-comment">// 然后第一个开始进行修改</span><br>  System.out.println(ud.updateById(user1));  <span class="hljs-comment">// 1是最后执行的</span><br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果 1 和 0，代表第一次执行成功了，第二次执行失败了，查看数据库，邮箱也是留在了 update2，成功！</p><h3 id="TableLogic-逻辑删除">TableLogic 逻辑删除</h3><p>当我们在页面中删除某个数据的时候，往往不是真的删除，而是通过修改某个字段让用户不在读取，因为在某些业务中被删除的数据也有存在的价值</p><p>在 MP 中使用逻辑删除也非常的简单，当然我们需要在添加一个列作为逻辑删除列 ( 这里推荐使用 deleted )，且所有表中的逻辑删除字段都要使用这个名字，然后来约定一个值，我这里就是 0 代表已删除，1 代表正常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实体类进行修改，由于之前测试将属性名乱七八糟，这里就顺便都改回来了</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;T_USER&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span> &#123;<br>    <span class="hljs-meta">@TableId(value = &quot;ID&quot;, type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br>    <span class="hljs-keyword">private</span> Date changeTime;<br>    <span class="hljs-comment">// 这里通过@TableLogic设置了逻辑删除</span><br>    <span class="hljs-meta">@TableLogic</span><br>    <span class="hljs-keyword">private</span> Integer deleted;<br>&#125;<br></code></pre></td></tr></table></figure><p>实体类修改完成之后，我们还需要添加一个配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 逻辑删除字段名为deleted</span><br><span class="hljs-attr">mybatis-plus.global-config.db-config.logic-delete-field</span>=<span class="hljs-string">deleted</span><br><span class="hljs-comment"># 被删除的变量值</span><br><span class="hljs-attr">mybatis-plus.global-config.db-config.logic-delete-value</span>=<span class="hljs-string">0</span><br><span class="hljs-comment"># 正常显示的变量值</span><br><span class="hljs-attr">mybatis-plus.global-config.db-config.logic-not-delete-value</span>=<span class="hljs-string">1</span><br></code></pre></td></tr></table></figure><p>接下来我们来测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot01Test</span> &#123;<br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">private</span> UserDao ud;<br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>  ud.deleteById(<span class="hljs-number">1L</span>);<br>  ud.selectList(<span class="hljs-literal">null</span>).forEach(System.out::println);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试后我们通过日志发现，原来的 delete 语句变成了现在的 update 语句，而且在执行 selectList 的时候查询不到删除后的数据，MP 已经帮我们全都配置好了</p><h3 id="常用注解小总结">常用注解小总结</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@TableName</td><td>用来绑定实体类和数据表名称</td></tr><tr><td>@TableId</td><td>用来设置主键列，可以绑定名称以及修改自动生成类型，例如雪花算法，自增等</td></tr><tr><td>@TableField</td><td>用来设置非主键列，可以设置绑定名称以及自动填充等等</td></tr><tr><td>@Version</td><td>用来设置乐观锁，需要配合 <code>OptimisticLockerInterceptor</code> 类使用</td></tr><tr><td>@TableLogic</td><td>配置逻辑删除，需要在配置文件中添加逻辑删除列，删除和未删除对应的值</td></tr></tbody></table><h2 id="高级查询学习">高级查询学习</h2><h3 id="Page-分页查询">Page 分页查询</h3><p>我们在使用 mybatis 的时候使用的分页插件是第三方的 <code>PageHelper</code> 分页插件，而在 MP 中为我们内置了一个分页插件，我们只需要将它配置进来就可以使用了</p><p>测试分页查询首先要有足够的数据，这里我们通过 for 循环插入30条测试数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot09ApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao ud;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-type">UserEntity</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>();<br>            user.setName(<span class="hljs-string">&quot;伞兵&quot;</span> + i + <span class="hljs-string">&quot;号&quot;</span>);<br>            user.setAge(<span class="hljs-number">20</span>+i);<br>            user.setEmail(<span class="hljs-string">&quot;sanbing&quot;</span> + (i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;hao@163.com&quot;</span>);<br>            ud.insert(user);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>**1.**测试数据插入完毕后，我们开始练习分页查询，首先要引入 MP 的分页插件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>   <span class="hljs-comment">// 这些类似的配置官方文档都有，直接照搬即可</span><br><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title function_">paginationInterceptor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">PaginationInterceptor</span> <span class="hljs-variable">paginationInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInterceptor</span>();<br>    paginationInterceptor.setCountSqlParser(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JsqlParserCountOptimize</span>(<span class="hljs-literal">true</span>));<br>    <span class="hljs-keyword">return</span> paginationInterceptor;<br>&#125;<br></code></pre></td></tr></table></figure><p>**2.**配置已经完成了，接下来我们来查询测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot09ApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao ud;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 需要创建分页实例，参数为： 查询第2页，每页显示5条记录</span><br>        Page&lt;UserEntity&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 查询时使用selectPage进行查询，结果会返回给page实例</span><br>        ud.selectPage(page, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 然后在通过page实例获取相关分页信息</span><br>        System.out.println(<span class="hljs-string">&quot;======================== Page ========================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;当前第&quot;</span> + page.getCurrent() + <span class="hljs-string">&quot;页&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;总页码为&quot;</span> + page.getPages() + <span class="hljs-string">&quot;页&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;结果集为：&quot;</span> + page.getRecords());<br>        System.out.println(<span class="hljs-string">&quot;查询到&quot;</span> + page.getSize() + <span class="hljs-string">&quot;条记录&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;总记录数&quot;</span> + page.getTotal() + <span class="hljs-string">&quot;条&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;是否有上一页：&quot;</span> + page.hasPrevious());<br>        System.out.println(<span class="hljs-string">&quot;是否有下一页：&quot;</span> + page.hasNext());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来分页就测试完成了！</p><h3 id="Wrapper-条件构造器">Wrapper 条件构造器</h3><p>wrapper 条件构造器，它可以帮助我们完成 SQL 中的绝大多数操作，例如大于等于，小于，区间以及模糊查询，对应的条件构造器为 <code>QueryWrapper</code>，修改操作同样也有对应的条件构造器 <code>UpdateWrapper</code></p><p>接下来我们练习一下：</p><blockquote><p>查询年龄在25-35之间的用户</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;UserEntity&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">// 查询年龄在25-35之间的用户</span><br>    wrapper.between(<span class="hljs-string">&quot;AGE&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-number">35</span>);<br>    ud.selectList(wrapper).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>查询名称中包含 ‘伞兵’ 的用户</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;UserEntity&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    wrapper.like(<span class="hljs-string">&quot;NAME&quot;</span>, <span class="hljs-string">&quot;伞兵&quot;</span>);<br>    ud.selectList(wrapper).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>查询所有邮箱为 null 的用户</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;UserEntity&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    wrapper.isNull(<span class="hljs-string">&quot;EMAIL&quot;</span>);<br>    ud.selectList(wrapper).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>查询名称中不包含 ‘伞兵’ 且年龄大于 20 邮箱不为空的所有用户</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>QueryWrapper&lt;UserEntity&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    wrapper    <span class="hljs-comment">// 这里使用链式编程</span><br>        .notLike(<span class="hljs-string">&quot;NAME&quot;</span>, <span class="hljs-string">&quot;伞兵&quot;</span>)<br>        .gt(<span class="hljs-string">&quot;AGE&quot;</span>, <span class="hljs-number">20</span>)<br>        .isNotNull(<span class="hljs-string">&quot;EMAIL&quot;</span>);<br>    ud.selectList(wrapper).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="映射mapper-xml">映射mapper.xml</h2><p>开始的时候也说了，MP 是基于 mybatis 框架进行的增强，也就是说除了之前那些功能之外我们还是可以把它当成 mybatis 使用的，可以配置 mapper.xml 映射文件，接下来我们就来配置 xml 开发：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 把MP看做成Mybatis即可，所有的配置项都是相同的，只是换了个名字</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span><br>      <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">0</span><br>  <span class="hljs-comment"># 在这里配置mapper映射文件的位置</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mappers/*Mapper.xml</span><br></code></pre></td></tr></table></figure><p>然后在目标位置创建 mapper 文件绑定接口进行调用即可，和 mybatis 是一样的流程</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis-Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot学习笔记</title>
    <link href="/2021/07/13/SpringBoot%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/13/SpringBoot%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>SpringBoot学习笔记</h1><p>笔记基于 Springboot 2.4.0 进行记录</p><h2 id="第一个Springboot程序">第一个Springboot程序</h2><p>使用 idea 快速创建一个 boot 程序：</p><img src="/img/7.jpg" /><h3 id="目录结构介绍">目录结构介绍</h3><img src="/img/1.jpg" /><h3 id="pom-文件解析">pom 文件解析</h3><ul><li>项目元数据：创建时候输入的Project Metadata部分，也就是Maven项目的基本元素，包括：groupId、artifactId、version、name、description等</li><li>parent：继承<code>spring-boot-starter-parent</code>父工程，主要用于依赖管理、控制版本等内容</li><li>dependencies：项目具体依赖，这里包含了<code>spring-boot-starter-web</code>用于实现HTTP接口（该依赖中包含了Spring MVC）；<code>spring-boot-starter-test</code>用于编写单元测试的依赖包。更多功能模块的使用我们将在后面的教程中逐步展开。</li><li>build：构建配置部分。默认使用了<code>spring-boot-maven-plugin</code>，配合<code>spring-boot-starter-parent</code>就可以把Spring Boot应用打包成JAR来直接运行。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 继承目标父项目的依赖，控制统一版本号 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 项目元数据 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>site.hanzhe<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-01-start<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springboot-09-mybatis-plus<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>my frist springboot demo<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 项目具体依赖，各种启动器等等 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 构建配置部分 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="启动类介绍">启动类介绍</h3><p>springboot 的启动类和平时写 Java 时的 main 函数差不太多，需要注意的点有：</p><ol><li>启动类要加上 @SpringBootApplication 注解，标识这是一个启动类</li><li>在 main 函数中要调用 SpringApplication 的静态函数 run，并传入启动类的 class 和 args 参数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot10SwaggerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Springboot10SwaggerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>@SpringBootApplication</code> 注解中包含了自动配置的注解 <code>EnableAutoConfiguration</code> 和自动扫描包的注解 <code>@ComponentScan</code> 等等，为我们提供了全自动的初始化过程。</p><h3 id="springboot-启动小彩蛋">springboot 启动小彩蛋</h3><p>在 resources 目录下复制一个 banner.txt 的文件，他会以按照文件内的图案作为启动的 LOGO</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"> _________________<br><span class="hljs-variable">&lt;    W D N M D    &gt;</span><br> -----------------<br>        \   ^__^<br>         \  (oo)\_______<br>            (__)\       )\/\<br>                ||<span class="hljs-string">----w </span>|<br>                ||<span class="hljs-string">     </span>||<br></code></pre></td></tr></table></figure><h2 id="开发注意事项">开发注意事项</h2><p>boot 项目中含有启动类，位于 <code>site.hanzhe.**Application.java</code>，这里需要注意：我们在创建类或者接口以及包的时候要求<em>必须在启动类同级目录以及同级目录的子目录下</em>创建</p><p><font color="green">检测的到：</font> site.hanzhe.dao.Test.java<br><font color="red">检测不到：</font> site.example.dao.Test.java</p><p>如果我们不得不在其他位置创建类或者接口，如果想要被 Spring 发现的话，可以新建配置类使用以下方法：</p><ol><li>在配置类中使用 <code>@ComponentScan(&quot;指定包的位置&quot;)</code></li><li>在配置类或启动类下，通过 <code>@Bean()</code> 注解将实例放进 IOC 容器中</li></ol><h2 id="配置文件的使用">配置文件的使用</h2><p>springboot 中支持两种格式的配置文件，一个是创建项目时携带的 <code>properties</code> 文件，另一种是 <code>yml</code> 文件，配置文件名为 <code>application</code></p><h3 id="properties配置文件">properties配置文件</h3><p>properties 配置文件的书写格式是以 <code>.</code> 分隔符控制层级，而后用 <strong>=</strong> 进行赋值操作 ，例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 将tomcat启动端口号改为8008</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8008</span><br><span class="hljs-comment"># 配置MySQL的连接字符串信息</span><br><span class="hljs-attr">mysql.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">mysql.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/database</span><br><span class="hljs-attr">mysql.username</span>=<span class="hljs-string">zhang</span><br><span class="hljs-attr">mysql.password</span>=<span class="hljs-string">hanzhe</span><br></code></pre></td></tr></table></figure><p>如果赋值中包含 k-v 的键值对或者数组，集合赋值：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 键值对赋值</span><br><span class="hljs-attr">person.map.key1</span>=<span class="hljs-string">value1</span><br><span class="hljs-attr">person.map.key2</span>=<span class="hljs-string">value2</span><br><span class="hljs-comment"># 数组，集合赋值</span><br><span class="hljs-attr">person.list</span>=<span class="hljs-string">1,2,3,4,5</span><br></code></pre></td></tr></table></figure><h3 id="常见的一些配置项">常见的一些配置项</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Tomcat默认端口号</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8000</span><br><span class="hljs-comment"># 上下文访问路径</span><br><span class="hljs-attr">server.servlet.context-path</span>=<span class="hljs-string">/name</span><br><span class="hljs-comment"># 开启/关闭 SpringBoot默认图标</span><br><span class="hljs-attr">spring.mvc.favicon.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 是否开启Debug模式(用于查看组件注册状况)</span><br><span class="hljs-attr">debug</span>=<span class="hljs-string">false</span><br><span class="hljs-comment"># 修改时间格式化的字符串解析模式</span><br><span class="hljs-attr">spring.mvc.date-format</span>=<span class="hljs-string">yyyy-MM-dd</span><br><span class="hljs-comment"># 开启/关闭 Thymeleaf模板引擎的缓存</span><br><span class="hljs-attr">spring.thymeleaf.cache</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 静态资源访问路径</span><br><span class="hljs-attr">spring.mvc.static-path-pattern</span>=<span class="hljs-string">/resource/**</span><br><span class="hljs-comment"># 配置数据源</span><br><span class="hljs-attr">spring.datasource.type</span>=<span class="hljs-string">druid</span><br><span class="hljs-attr">spring.datasource...</span>=<span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><h3 id="yml-配置文件">yml 配置文件</h3><p>yml 配置的语法是利用 <strong>空格</strong> 控制缩进的方式编写文件，格式为 <code>key: value</code> 有些类似 JSON，value 前需要留有空格，多层级时用 <strong>回车+空格</strong> 来控制层级，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 将tomcat启动端口号改为8008</span><br><span class="hljs-attr">server:</span><br> <span class="hljs-attr">port:</span> <span class="hljs-number">8008</span><br> <span class="hljs-comment"># 配置MySQL的连接字符串信息</span><br><span class="hljs-attr">mysql:</span><br> <span class="hljs-attr">driver:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br> <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/database</span><br> <span class="hljs-attr">username:</span> <span class="hljs-string">zhang</span><br> <span class="hljs-attr">password:</span> <span class="hljs-string">hanzhe</span><br></code></pre></td></tr></table></figure><p>如果赋值中包含 k-v 的键值对或者数组，集合赋值：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 键值对赋值</span><br><span class="hljs-attr">person:</span><br> <span class="hljs-attr">key1:</span> <span class="hljs-string">value1</span><br> <span class="hljs-attr">key2:</span> <span class="hljs-string">value2</span><br><span class="hljs-comment"># 行内赋值</span><br><span class="hljs-attr">person:</span> &#123; <span class="hljs-attr">key1:</span> <span class="hljs-string">value1</span> , <span class="hljs-attr">key1:</span> <span class="hljs-string">value1</span> &#125;<br><span class="hljs-comment"># array,list.set赋值 减号+空格 就相当于一个元素</span><br><span class="hljs-attr">person:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-number">1</span><br> <span class="hljs-bullet">-</span> <span class="hljs-number">2</span><br> <span class="hljs-bullet">-</span> <span class="hljs-number">3</span><br><span class="hljs-comment"># array,list.set赋值 行内赋值</span><br><span class="hljs-attr">person:</span><br> <span class="hljs-string">list=&#123;1,2,3,4,5&#125;</span><br></code></pre></td></tr></table></figure><p><strong>关于字符串赋值的细节：</strong></p><ul><li>无引号：默认赋值字符串可以不适用引号，直接书写 value 即可，</li><li>单引号：单引号内的字符串支持特殊格式，例如 <code>'哈哈\n哈哈'</code>，那么输出到控制台之后可以发现字符串中间会有换行效果，四个哈哈之间有一个换行</li><li>双引号：双引号内的字符串就是字符串，不会发生任何改变，同样使用 <code>&quot;哈哈\n哈哈&quot;</code>，输出到控制台之后可以发现没有任何变化，控制台上原样输出了 \n 这个字符串</li></ul><h3 id="类的绑定配置-全局">类的绑定配置 ( 全局 )</h3><p>将某些固定的属性值放在配置文件中，然后在通过 bean 关联其中进行使用，配置文件如下所示：</p><p><strong>properties配置文件写法：</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">person.name</span>=<span class="hljs-string">张涵哲</span><br><span class="hljs-attr">person.age</span>=<span class="hljs-string">22</span><br><span class="hljs-attr">person.cat.name</span>=<span class="hljs-string">哈哈</span><br><span class="hljs-attr">person.cat.color</span>=<span class="hljs-string">白色</span><br></code></pre></td></tr></table></figure><p><strong>yml配置文件写法：</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">person:</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">22</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">张涵哲</span><br>  <span class="hljs-attr">cat:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">哈哈</span><br>    <span class="hljs-attr">color:</span> <span class="hljs-string">橘色</span><br></code></pre></td></tr></table></figure><hr /><p>书写与配置文件关联的 bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-comment">// 配置文件的key都是以person作为前缀的，所以这里要加上</span><br><span class="hljs-meta">@ConfigurationProperties(&quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">// 同事也可以属性中的属性进行赋值</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-comment">// 一堆的get-set-toString-代码省略掉了</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person类中的Cat属性对应的类</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(&quot;cat&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-comment">// 一堆的get-set-toString-代码省略掉了</span><br>&#125;<br></code></pre></td></tr></table></figure><hr />**测试类代码**，通过测试类可以查看到数据已经被封装上来了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@RunWith( SpringRunner.class )</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBoot02ConfigApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> Person person;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>配置文件关联的 bean 必须添加到 spring 的 ioc 容器中。</li><li>bean 必须提供 get set 方法，关联注入依靠的就是 get set 方法</li><li>如果两种类型的配置文件并存的情况下，properties 的优先级高于 yml</li></ul><h3 id="类绑定配置-指定">类绑定配置 ( 指定 )</h3><p>配置文件可以书写参数和 bean 关联在一起，但是如果把所有参数都放在 <code>application</code> 全局配置文件中，那么配置文件就显得太过臃肿，如果 bean 需要进行关联的话，建议新建一个 properties 文件单独存储，这个时候就需要使用到一个注解 <code>@PropertySource(&quot;classpath:&quot;)</code></p><p>书写一个JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(&quot;dog&quot;)</span><br><span class="hljs-comment">// 指定关联类路径下的dog.properties文件</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:dog.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; eat;<br>    <span class="hljs-comment">// 此处省略 get set toString 方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>书写dog.properties配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">dog.name</span>=<span class="hljs-string">忠犬</span><br><span class="hljs-attr">dog.eat</span>=<span class="hljs-string">狗粮,通用宠物狼,肉</span><br></code></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBoot02ConfigApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span> Dog dog;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(dog);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件绑定提示">配置文件绑定提示</h3><p>在我们通过类绑定到配置文件之后，就可以在配置文件中照着类的格式书写内容，这里可以使用 springboot 为我们提供的一个工具来开启配置文件中的代码提示：</p><blockquote><p>代码提示依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-rocessor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>依赖引入后在配置文件中就会有代码提示啦，但是这个依赖在负责我们在编码程序中使用，项目真正上线的时候就没有必要在留着他了，所以我们最好在项目打包前将这个依赖删除，或者让他不参与打包：</p><blockquote><p>配置依赖不参与打包</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-rocessor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Value注解获取值">@Value注解获取值</h3><p>当有些时候仅仅是想引用一下配置文件的值而不关联起来，这个时候需要用到@Value注解</p><blockquote><p>当@ConfigurationProperties和@Value同时使用时，@ConfigurationProperties权限高于@Value</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>  <span class="hljs-comment">// 注意，目标类必须是Spring的组件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;person.cat.name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 省略get、set方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试是否拿到了值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">SpringBootTest<br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBoot02ConfigApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span> Cat cat;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println( cat.getColor() );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件占位符">配置文件占位符</h3><p>无论是在 properties 还是 yml 中都有着 占位符 的存在，占位符的表现形式是 <font color="red"><strong>${  }</strong></font>，使用占位符可以实现在引用配置文件内的值，生成随机数的功能</p><p>首先一个JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(&quot;cat&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:cat.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String number;<br>    <span class="hljs-keyword">private</span> String Remarks;<br>    <span class="hljs-comment">// 省略的 get set toString 方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在cat.properties配置文件中使用占位符</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 直接赋值给猫起名字</span><br><span class="hljs-attr">cat.name</span>=<span class="hljs-string">猫爷</span><br><span class="hljs-comment"># 使用random生成1-10的随机年龄</span><br><span class="hljs-attr">cat.age</span>=<span class="hljs-string">$&#123;random.int(1,10))&#125;</span><br><span class="hljs-comment"># 给猫生成随机编号</span><br><span class="hljs-attr">cat.number</span>=<span class="hljs-string">$&#123;random.uuid&#125;</span><br><span class="hljs-comment"># 使用引用生成备注 name_age_sex ，如果引用无效则使用冒号后的默认值</span><br><span class="hljs-attr">cat.remarks</span>=<span class="hljs-string">$&#123;cat.name:匿名&#125;_$&#123;cat.age:0&#125;_$&#123;cat.sex:未知&#125;</span><br></code></pre></td></tr></table></figure><p>测试类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println( cat );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件存放位置">配置文件存放位置</h3><p>在SpringBoot中的配置文件只能放在指定的目录下才可以被识别，这里列举四个常用好记的存储位置，其中每个位置的配置文件之间分别有着优先级的概念</p><table><thead><tr><th>↑ <strong>项目根目录 / config</strong></th></tr></thead><tbody><tr><td>↑ <strong>项目根目录</strong></td></tr><tr><td>↓ <strong>resources / config</strong></td></tr><tr><td>↓ <strong>resources</strong></td></tr></tbody></table><p>以上四个存放配置文件目录的顺序是按照由高到低的优先级进行排序的，<font color="red">优先级高的配置文件会覆盖优先级低的配置文件</font>，但是只有在优先级高的配置文件中存在的配置信息才会被覆盖，而优先级高的配置文件中不存在的配置信息依然生效，这就诞生了<font color="red">互补配置</font>，一个新的概念，可以利用这一特点对配置进行调优</p><h3 id="Jar-命令行配置">Jar 命令行配置</h3><blockquote><p>修改某一项配置</p></blockquote><p>我们可以在通过 java -jar 执行某个 jar 包的时候，手动修改某个配置项，例如：</p><p><code>java -jar xxx.jar --server.port=8888</code></p><p><code>java -jar xxx.jar --spring.profiles.active=prod</code></p><blockquote><p>指定某个路径下的配置文件</p></blockquote><p>除开之前四个比较常用好记的存放位置之外，还需要了解这个配置，在项目打包为jar包之后，可以在运行的时候手动指定需要使用哪一个 配置/本地磁盘 文件，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar 项目名.jar --spring.config.location=文件路径<br></code></pre></td></tr></table></figure><p>通过 <strong>命令行</strong> 指定的配置文件是目前 springboot 中已知 <strong>优先级最高</strong> 的，一般在项目打包成功后突然发现了 BUG ，这个时候就可以利用这种方法进行修改，而不用去项目中改后在重新打包</p><h3 id="Profiles-模式">Profiles 模式</h3><p>在本地开发程序时会连接本地的数据库，程序上线运行后会连接真正懂得生产库，我们可以随时修改配置文件来决定连接的库的地址，可如果需要修改的不止是数据库地址那就非常麻烦了</p><p>这个时候就可以使用 <em>profile模式</em>，创建多个配置文件，每个配置文件代表一个环境，然后我们可以通过少量的修改实现在多个环境之间来回的切换</p><p>profile模式要求文件命名的规范为：<strong>application-{profile}.properties/yml</strong></p><h4 id="profiles多配置文件">profiles多配置文件</h4><p>假设有三个环境的配置文件：【 默认环境，开发环境，生产环境 】，如果没有刻意配置则以默认环境为主：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 默认环境 application.properties</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8080</span><br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开发环境 application-dev.properties</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8081</span><br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 生产环境 application-prod.properties</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">80</span><br></code></pre></td></tr></table></figure><p>当我们想要切换至开发环境或者生产环境的时候，只需要在默认配置文件上更改即可</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 默认 application.properties</span><br><span class="hljs-comment"># 指定使用dev环境的配置</span><br><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><h4 id="yml文档块格式">yml文档块格式</h4><p>除开 properties 和 yml 通用的这种多文件的形式，yml还单独存在一种多文档块模式，他使用三个减号将一个yml配置文件分割为若干份，每一份可代替一个环境</p><p>同之前的规则一样，三个文档快之间没有任何操作时，以默认环境为主</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 默认环境</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8008</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 开发环境，这种通过 --- 进行分割的环境，需要使用spring.profiles来指定当前环境标识</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 生产环境，这种通过 --- 进行分割的环境，需要使用spring.profiles来指定当前环境标识</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">prod</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>当我们想要切换至开发环境或者生产环境的时候，只需要在默认配置文件上更改即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 默认环境</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8008</span><br><span class="hljs-comment"># 指定使用dev环境的配置</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><h4 id="打包后动态修改环境">打包后动态修改环境</h4><p>我们将程序打为一个 jar 包之后，可以在运行该 jar 包的时候来指定通过什么环境运行，例如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">java -jar application.jar --spring.profiles.active=dev<br></code></pre></td></tr></table></figure><p>这种属于在运行 jar 包时动态添加参数进去，通过这种方式也可以设置端口号之类的：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">java -jar application.jar --server.port=<span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><h2 id="SpringBoot-Web-开发">SpringBoot Web 开发</h2><p>springboot 开发 WEB 应用程序需要在 pom.xml 中添加 WEB 的场景启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>静态资源存放位置</p></blockquote><p>在通常的 web 开发的项目中都有一个 webapp 的目录用来存放网页图片等静态资源，在 springboot 中可以发现在 resources 目录下有一个 static 文件夹，这个文件夹就类似 webapp 目录，可以存放静态资源</p><blockquote><p>优先级问题</p></blockquote><p>除开项目自带的 static 文件夹之外，springboot 还提供了其他的文件夹来存放资源，我们可以再 resources 目录下手动创建 [ public ] [ resources ]，优先级为：<code>resources &gt; static &gt; public</code>，当访问同名资源时，优先级高的会覆盖优先级低的</p><blockquote><p>首页设置</p></blockquote><p>在以上的资源目录中任意一个目录下有 index.html 命名的文件，就会被设置为默认首页，当有多个目录中存在 index.html 文件，默认优先级高的会被设置为首页</p><blockquote><p>自定义错误页</p></blockquote><p>当请求不存在的资源或者服务器异常时会显示报错页，可以再静态资源目录下创建 <code>error</code> 文件夹，以 <code>404.html</code> <code>500.html</code> 命名，springboot 会自动识别为自定义错误页</p><h2 id="Thymeleaf-模板引擎">Thymeleaf 模板引擎</h2><p>Thymeleaf 是 springboot 中的模板引擎，使用方法与 vue 有很多相似之处，可以获取域中的信息并在页面中显示，Thymeleaf 自带的视图解析器为 **resources目录下的 templates 文件夹，以 html 结尾</p><p>templates 目录下的 html 文件属于模板文件，不可以直接访问，必须通过视图解析器解析后才可以进行访问</p><h3 id="初体验-Thymeleaf">初体验 Thymeleaf</h3><p><strong>1. 引用：</strong> 使用 Thymeleaf 模板语言需要引入maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">建议Thymeleaf版本高于SpringBoot，例如：</span><br><span class="hljs-comment">SpringBoot 1 搭配 Thymeleaf 2</span><br><span class="hljs-comment">SpringBoot 2 搭配 Thymeleaf 3</span><br><span class="hljs-comment">在SpringBoot的parent的parent中可以查看版本</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-extras-java8time<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2. 传值：</strong> 在控制器类中通过加入Model参数，然后在跳转页面之前addAttribute添加参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test1&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test1</span><span class="hljs-params">(Model model)</span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;thymeleat传值&quot;</span>);<br>    <span class="hljs-comment">// 返回的 1 会被视Thymeleaf视图解析器解析为 templates/1.html</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 取值：</strong> 在html页面中进行取值操作</p><blockquote><p>使用 Thymeleaf 模板语言需要以 th: 为关键字开头，对参数进行操作</p></blockquote><blockquote><p>使用 th 关键字，需要在html标签之上添加 xmlns:th=“<a href="http://www.thymeleaf.org">http://www.thymeleaf.org</a>” 命名空间</p></blockquote><blockquote><p>读取值还可以使用 [ [  ] ] 来对值进行解析，类似Vue中的差值表达式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;msg1&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">&quot;$&#123;msg2&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;person : $&#123;persons&#125;&quot;</span>&gt;</span> [[$&#123;person&#125;]] <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Thymeleaf-视图解析器">Thymeleaf 视图解析器</h3><p>使用 Thymeleaf 模板书写的 html 页面必须要放在 templates 目录下，而 templates 目录下的文件不可以被直接访问，需要通过视图解析器进行目录解析后才可以进行访问</p><p><strong>自定义视图解析器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry regi)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         实现了WebMvcConfiguration接口后复写其中的addViewControllers方法</span><br><span class="hljs-comment">         通过方法内提供的参数进行视图解析，例如下面的代码：</span><br><span class="hljs-comment">         将/index.html请求解析为index请求</span><br><span class="hljs-comment">         被解析的index会自动找到templates目录下以html结尾的index</span><br><span class="hljs-comment">        */</span><br>        regi.addViewController(<span class="hljs-string">&quot;/index.html&quot;</span>).setViewName(<span class="hljs-string">&quot;index&quot;</span>);<br>        regi.addViewController(<span class="hljs-string">&quot;/main.html&quot;</span>).setViewName(<span class="hljs-string">&quot;dashboard&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转发与重定向的注意事项</p><ol><li>redirect 重定向的时候，<em>有 / 为重定向到根目录的资源，无 / 为重定向到当前目录下的资源</em></li><li>forward 转发，<em>无论是否有 / 都是指向根目录的资源</em></li></ol><h3 id="Thymeleaf-帮助">Thymeleaf 帮助</h3><p>指令</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">th</span>:text  以普通文本形式接收值<br><span class="hljs-selector-tag">th</span>:utext 接收值后可以解析为<span class="hljs-selector-tag">html</span><br><span class="hljs-selector-tag">th</span>:each  遍历接收到的容器，集合数组等 ( 变量 : $&#123;容器名&#125; )<br><br><span class="hljs-selector-tag">th</span>:fragment=<span class="hljs-string">&quot;name&quot;</span> 将当前标签及子标签内的所有元素封装为一个组件(不影响当前页)，可以在其他页面引用name<br><span class="hljs-selector-tag">th</span>:insert=<span class="hljs-string">&quot;&quot;</span> 引用的方式通过name使用其他页面封装的组件，一般作用在div中，然后组件会填充到div内部<br><span class="hljs-selector-tag">th</span>:replace=<span class="hljs-string">&quot;&quot;</span> 替换的方式通过name使用其他页面封装的组件，一般作用在div中，然后组件会将当前dib标签替换<br></code></pre></td></tr></table></figure><p>各种取值 – th 标识后才可以使用</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$&#123;</span>  &#125;  表达式语句，可以书写表达式，例如<span class="hljs-keyword">if</span>判断，三元运算，也可以获取传入的参数<br>@&#123;/ &#125;  表示超链接，在传参的时候不需要使用问好，需使用括号(key=<span class="hljs-string">&#x27;value&#x27;</span>)<br><span class="hljs-comment">#&#123;  &#125;  国际化消息表达式，用来获取properties配置文件中的信息</span><br>~&#123; :: &#125;  用来实现组件化信息，::的左侧用来填写组件所在页面，右侧填写组件的名称<br></code></pre></td></tr></table></figure><p>Thymleaf 的工具类 – #号开头</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">$&#123;#datas.format(<span class="hljs-built_in">date</span>,str)&#125; 时间格式化，按照指定格式输出<span class="hljs-built_in">data</span><br></code></pre></td></tr></table></figure><h3 id="Thymeleaf-的国际化">Thymeleaf 的国际化</h3><p>在其他大型网站上几乎都可以看到，页面上有个标识可以设置当前页面显示的语言，这里就是用到了国际化 (i18n) 的技术，国际化是在资源目录中创建 N 多个 properties 配置文件文件，将各国语言分别按照指定的格式进行存放，然后将配置文件中的字符提取到页面上来，便实现了国际化效果</p><img src="/img/3.jpg" /><p>在语言修改完成后在 application.properties 中设置国际化配置文件所在目录</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 指定信息转换目标</span><br><span class="hljs-attr">spring.messages.basename</span>=<span class="hljs-string">i18n.login</span><br></code></pre></td></tr></table></figure><p>自定义一个<strong>地址映射类</strong>，实现 LocaleResolver 接口，用来分析请求并设置当前页面显示的语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Language</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LocaleResolver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Locale <span class="hljs-title function_">resolveLocale</span><span class="hljs-params">(HttpServletRequest req)</span> &#123;<br>        <span class="hljs-comment">// 类似一个过滤器，通过页面的传值来判断是否对语言进行修改</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">language</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;language&quot;</span>);<br>        <span class="hljs-type">Locale</span> <span class="hljs-variable">locale</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Locale</span>(<span class="hljs-string">&quot;en&quot;</span>,<span class="hljs-string">&quot;US&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;[Debug] language=&quot;</span> + language);<br>        <span class="hljs-keyword">if</span>( language != <span class="hljs-literal">null</span> )<br>            locale = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Locale</span>(language.split(<span class="hljs-string">&quot;_&quot;</span>)[<span class="hljs-number">0</span>],language.split(<span class="hljs-string">&quot;_&quot;</span>)[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> locale;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLocale</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Locale locale)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后可以<strong>需要将地址映射类装配到 Ioc 容器中</strong>，需要注意的是 <font color="red">地址映射类的 name 必须是 localeResolver </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">// 标注配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Bean(&quot;localeResolver&quot;)</span><br>    <span class="hljs-keyword">public</span> Language <span class="hljs-title function_">language</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Language</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后只需要在页面中使用 Thymeleaf 模板来获取配置文件中的值并输出在页面上即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- th的命名空间必须要导入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 可以通过绑定text属性使用 #&#123; &#125; 获取值 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;login.msg&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 也可以使用括号的形式直接输出值 --&gt;</span><br>        [[ #&#123; login.msg &#125; ]]<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="SpringBoot-的拦截器">SpringBoot 的拦截器</h2><p>在 SpringBoot 中使用 MVC 的拦截器，同样需要实现 <code>HandlerInterceptor</code> 接口，同样也要复写其中的方法，通过逻辑代码判断该请求是否可以访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;拦截器开始工作&quot;</span>);<br>        <span class="hljs-keyword">if</span> ( req.getSession().getAttribute(<span class="hljs-string">&quot;user&quot;</span>) == <span class="hljs-literal">null</span> )&#123;<br>            System.out.println(<span class="hljs-string">&quot;拦截了一次请求&quot;</span>);<br>            req.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;请登录后在进行操作&quot;</span>);<br>            req.getRequestDispatcher(<span class="hljs-string">&quot;/index.html&quot;</span>).forward(req, resp);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后的注册拦截器，需要通过配置类复写 <code>addInterceptors</code> 方法进行注册，是否被拦截器排除，拦截器都会进行拦截，只不过满足条件的在被拦截器拦截后还是会正常工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">// 标注配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 添加拦截器</span><br>        <span class="hljs-type">InterceptorRegistration</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <br>                 registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>());<br>        <span class="hljs-comment">// 拦截全部请求</span><br>        interceptor = interceptor.addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>        <span class="hljs-comment">// 排除指定的几个请求</span><br>        interceptor.excludePathPatterns(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/index&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/user/login&quot;</span>,<br>                <span class="hljs-string">&quot;/asserts/**&quot;</span>, <span class="hljs-string">&quot;/1.html&quot;</span>, <span class="hljs-string">&quot;/2.html&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SpringBoot-中使用-AOP">SpringBoot 中使用 AOP</h2><p>在 SpringBoot 中使用 aop 面向切面编程需要引入对应的 starter 启动器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>这里默认使用的是 Java 的 JDK 动态代理模式，如果想使用 CGLIB 需要在配置文件中添加以下配置：</p></li><li><pre><code class="language-properties">spring.aop.proxy-target-class=true<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>现在就可以书写切面类了，因为 springboot 优于配置简化，所以这里使用注解的方式进行 aop 切入<br><br>&gt; 使用 `@Aspect` 注解来标识当前类是切面类，然后在使用 `@Component` 将切面类交给 Spring 进行管理即可<br><br>```java<br>@Aspect<br>@Component<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Aop1 &#123;<br>    @<span class="hljs-keyword">Before</span>(&quot;execution(public * site.hanzhe.service..*(..))&quot;)<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">before</span>(JoinPoint <span class="hljs-keyword">join</span>)&#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;[Debug] &quot;+<span class="hljs-keyword">join</span>.getSignature().getName()+&quot; 方法执行&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;[Debug] 执行时间：&quot; + <br>                           <span class="hljs-built_in">new</span> SimpleDateFormat().format(<span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>()));<br>    &#125;<br>&#125;<br>```<br><br>至此 aop 就可以正常使用了，如果发现 aop 不生效可以尝试在配置文件中添加如下配置：<br><br>&gt; 因为该选项是默认开启的，所以一般不需要去更改他，但是当aop无效的时候可以尝试手动开启他<br><br>~~~properties<br># 开启SpringBoot的aop功能<br>spring.aop.auto=<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h2 id="SpringBoot-的过滤器">SpringBoot 的过滤器</h2><p>在 SpringBoot 中创建过滤器类，那么该类首先要实现 Filter 接口，然后配合注解进行使用</p><blockquote><p>实现 Filter 接口，使用 <code>@WebFilter(&quot;/*&quot;)</code> 生命他是过滤器，然后配合 <code>@Order(1)</code> 来指定优先级</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 必须实现Filter接口，然后添加注解 <span class="hljs-doctag">@WebFilter</span> 注解</span><br><span class="hljs-comment"> *    1.1 urlPatterns 为设置的URL匹配规则</span><br><span class="hljs-comment"> *    1.2 filterName 为Filter的名称</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. <span class="hljs-doctag">@Order</span>() 注解，配合 <span class="hljs-doctag">@WebFilter</span> 注解使用，用于多个过滤器时定义执行顺序，值越小越先执行</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Order(1)</span><br><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, </span><br><span class="hljs-params">            ServletResponse servletResponse, </span><br><span class="hljs-params">            FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        filterChain.doFilter(servletRequest, servletResponse);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在配置好过滤器之后还要在启动类中使用 <code>@ServletComponentScan</code> 进行扫描，被扫描到的类才可以生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@ServletComponentScan(&quot;site.hanzhe.filter&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot03Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Springboot03Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>经典：处理跨域请求过滤器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span>&#123;<br><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(</span><br><span class="hljs-params">            ServletRequest request,</span><br><span class="hljs-params">            ServletResponse response, FilterChain chain)</span><br>   <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>  <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>  <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> (HttpServletResponse) response;<br>  resp.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, req.getHeader(<span class="hljs-string">&quot;origin&quot;</span>));<br>  resp.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br><span class="hljs-comment">//  resp.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);</span><br><span class="hljs-comment">//  resp.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br>  chain.doFilter(req, resp);<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SpringBoot-持久化">SpringBoot 持久化</h2><h3 id="整合-JDBC">整合 JDBC</h3><p>在 SpringBoot 中整合 JDBC 非常简单，省去了繁琐的 xml 配置文件</p><h4 id="简单配置-JDBC">简单配置 JDBC</h4><p><strong>1. 在创建 SpringBoot 时勾选 JDBC 和指定数据库驱动</strong></p><img src="/img/4.jpg" /><p><strong>2. 在配置文件中配置数据源相关信息</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-comment"># 高版本的SprignBoot会默认继承8版本以上的MySQL驱动，需要在url后面加上时区 serverTimezone=UTC</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mydb?serverTimezone=UTC</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">zhang</span><br><span class="hljs-comment"># 这里可以指定使用jdbc时选用的数据源 # 默认数据源为Hikari</span><br><span class="hljs-attr">spring.datasource.type</span>=<span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p><strong>3. 这样一来 JDBC 就已经配置完成，只需要进行测试即可</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMainTests</span> &#123;<br>    <span class="hljs-comment">// SpringBoot中都是配置好的，直接拿来用就可以</span><br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> DataSource ds;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        System.out.println(<span class="hljs-string">&quot;数据源：&quot;</span> + ds);<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> ds.getConnection();<br>        System.out.println(<span class="hljs-string">&quot;连接器：&quot;</span> + conn);<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> conn.prepareStatement(<span class="hljs-string">&quot;SELECT * FROM t_user&quot;</span>);<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pre.executeQuery();<br>        <span class="hljs-keyword">while</span> (result.next())&#123;<br>            System.out.print(<span class="hljs-string">&quot;ID = &quot;</span> + result.getInt(<span class="hljs-number">1</span>));<br>            System.out.print(<span class="hljs-string">&quot;, 姓名=&quot;</span> + result.getString(<span class="hljs-number">2</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="JdbcTemplate-模板">JdbcTemplate 模板</h4><p>SpringBoot 提供了预置好的jdbc模板，叫做 JdbcLate ，可以通过这个模板快速的对数据库进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMainTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> JdbcTemplate jt;<br> <span class="hljs-meta">@Test</span>   <span class="hljs-comment">// 查询</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        List&lt;Map&lt;String, Object&gt;&gt; list_map = jt.queryForList(<span class="hljs-string">&quot;select * from t_user&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Map map : list_map)<br>            System.out.println(map);<br>    &#125;<br>    <span class="hljs-meta">@Test</span>   <span class="hljs-comment">// 添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into t_user values (null, ?, ?, ?, ?, &#x27;guest&#x27;)&quot;</span>;<br>        String []arr = &#123;<span class="hljs-string">&quot;楚易&quot;</span>,<span class="hljs-string">&quot;46514&quot;</span>,<span class="hljs-string">&quot;sadlj&quot;</span>,<span class="hljs-string">&quot;30000&quot;</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> jt.update(sql, arr);<br>        System.out.println(i==<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;执行成功！&quot;</span> + i + <span class="hljs-string">&quot;行收到影响&quot;</span> : <span class="hljs-string">&quot;执行失败！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="整合-MyBatis">整合 MyBatis</h3><p>使用 SpringBoot 整合MyBatis 需要创建项目时勾选 mybatis 或者直接添加 maven 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>1. 在配置文件中定义数据库的配置信息，然后配置 mybatis 的整合</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 配置数据库连接信息</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///mydb</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">zhang</span><br><span class="hljs-comment"># 配置整合MyBatis</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">site.hanzhe.bean</span>  <span class="hljs-comment"># 别名</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*Mapper.xml</span> <span class="hljs-comment"># mapper映射路径</span><br>  <span class="hljs-attr">configuration:</span> <span class="hljs-comment"># setting 设置</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="hljs-comment"># 日志</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启驼峰命名</span><br></code></pre></td></tr></table></figure><p><strong>2. 对应数据表创建响应的 pojo</strong></p><blockquote><p>这里使用 Lombok 生成的 get set toString 等方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String userId;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> Integer rmb;<br>    <span class="hljs-keyword">private</span> String type;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 书写接口</strong></p><blockquote><p>接口需要使用 Mapper 注解来标识接口开发，同时要使用 Repository 注解将该接口交给 Spring 管理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findAllUser</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果在不适用 Mapper 注解的情况下，可以在启动类中使用 MapperScan 来批量扫描所有 mapper 接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;site.hanzhe.dao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ApplicationMain.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. 对应接口写 mapper 映射文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;site.hanzhe.dao.UserDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        select * from t_user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>5. 测试类</strong></p><blockquote><p>SpringBoot 自动完成了所有操作，只需要直接调用 dao 就可以完成</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMainTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> UserDao dao;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        List&lt;User&gt; list = dao.findAllUser();<br>        <span class="hljs-keyword">for</span> (User u : list)<br>            System.out.println(u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PageHelper-插件">PageHelper 插件</h3><p>在 springboot 中整合 mybatis 时同样也可以使用 PageHelper 进行分页，导入 springboot 的分页插件依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于 springboot 不需要书写 mybatis 的配置文件，所以有关分页的配置都在 properties 或 yml 中进行配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#标识是哪一种数据库</span><br><span class="hljs-attr">pagehelper.helperDialect</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment">#启用合理化，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页</span><br><span class="hljs-attr">pagehelper.reasonable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#为了支持startPage(Object params)方法，增加了该参数来配置参数映射</span><br><span class="hljs-attr">pagehelper.params</span>=<span class="hljs-string">count=countSql</span><br><span class="hljs-comment">#支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页</span><br><span class="hljs-attr">pagehelper.supportMethodsArguments</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#如果 pageSize=0 就会查询出全部的结果（相当于没有执行分页查询）</span><br><span class="hljs-attr">pagehelper.page-size-zero</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><p>这样 springboot 的 PageHelper 就配置完成了！关于 PageHelper 更多使用方法在 mybatis 中查看</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis笔记</title>
    <link href="/2021/05/23/MyBatis%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/05/23/MyBatis%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>MyBatis 笔记</h1><p>MyBatis 是基于 Java 语言的开源的持久层框架，利用实体类和数据表之间产生了关联，通过映射文件中的 sql 语句对数据库进行操作</p><p>使用 maven 创建工程需要导入 <code>mybatis</code> 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="简单实例演示">简单实例演示</h2><p>mybatis的持久层开发有两种方式，一种是原始的 dao 开发，比较繁琐，还有一种是基于接口的 JDK 动态代理开发，也是最普遍的一种开发模式</p><h3 id="原始dao开发模式">原始dao开发模式</h3><p><strong>使用原始 dao 开发模式，首先第一步： 创建 mybatis 的核心配置文件，一般取名为</strong> <code>mybatis-config.xml</code></p><blockquote><p>在dataSource标签中配置数据库连接，在mapper标签中配置xml映射文件目录，然后去书写xml映射文件</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///test&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zhang&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper/beanMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>第二步：在上面的映射文件目录对应的位置创建文件</strong></p><blockquote><p>mapper 标签的 namespace 属性自定义书写，select 标签的 id 不能与其他 id 重复，resultType 是和数据库表对应的实体类的全限定路径名，实体类仅仅只有和表中字段对应的属性及 get set toString 方法而已</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;club.hanzhe.bean.Bean&quot;</span>&gt;</span><br>        select * from test1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>第三步：创建dao类，通过dao接口类来操作 mapper 文件中的增删改查</strong></p><blockquote><p>dao类想要操作mapper文件需要使用工厂对象，工厂对象暂时就不在这里创建了，由调用者给他对象让他使用就行</p><p>操作mapper文件需要使用mapper文件的 ==namespace.标签id==，例如 ==test1.findAll==</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanDao</span> &#123;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BeanDao</span><span class="hljs-params">( SqlSessionFactory factory )</span>&#123;<br>        <span class="hljs-built_in">this</span>.factory = factory;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;Bean&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> factory.openSession();<br>        List&lt;Bean&gt; list = sqlSession.selectList(<span class="hljs-string">&quot;test1.findAll&quot;</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第四步：创建测试类，对写好的代码进行测试</strong></p><blockquote><p>因为调用一个dao都会使用一个工厂对象，所以这里就直接创建一个供所有dao使用，节省资源</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            is = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;获取配置文件失败！&quot;</span>);<br>        &#125;<br>        factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tes1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">BeanDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDao</span>(factory);<br>        List&lt;Bean&gt; list = dao.findAll();<br>        <span class="hljs-keyword">for</span> (Bean bean : list)<br>            System.out.println(bean);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于接口的动态代理开发">基于接口的动态代理开发</h3><p><strong>使用动态代理开发模式，首先第一步： 创建 mybatis 的核心配置文件，一般取名为 <code>mybatis-config.xml</code></strong></p><blockquote><p>这里和 dao 开发的配置文件一模一样，可以去上面 copy</p></blockquote><p><strong>第二步：在上面的映射文件目录对应的位置创建映射文件</strong></p><blockquote><p>这里和上面几乎一模一样，但是动态代理的 mapper 的 namespace 指向的必须是接口的全限定名称</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;club.hanzhe.dao.BeanDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;club.hanzhe.bean.Bean&quot;</span>&gt;</span><br>        select * from test1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>第三步：按照上面映射文件目录创建接口</strong></p><blockquote><p>这里和上面不同的是不需要太多繁琐的结构，只需要创建一个方法即可对应mapper中的增删改查，但是需要注意一点：==接口方法名必须和mapper的CRUD标签id一致，否则会报错==</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDao</span> &#123;<br>    List&lt;Bean&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第四步：创建测试类，对写好的代码进行测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            is = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;加载核心配置文件失败&quot;</span>);<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> factory.openSession();<br>        <span class="hljs-type">BeanDao</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BeanDao.class);<br>        List&lt;Bean&gt; list = mapper.findAll();<br>        <span class="hljs-keyword">for</span> (Bean bean : list)<br>            System.out.println(bean);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">注意：</font>在 openSession 的时候是可以传入一个 boolean 参数的，如果不传参数默认为 false，如果要执行 DML 语句进行增删改的话，一定要传入 true 做为参数，否则他不会自动提交 ( 你可以手动提交 )，查询无需提交所以不需要设置</p><h2 id="Mybatis-的核心配置文件">Mybatis 的核心配置文件</h2><p>mybatis 的核心配置文件，一般都起名为 <code>mybatis-config.xml</code> 或者是 <code>sqlMapConfig.xml</code> ，在核心配置文件中可以通过某些标签对 mybatis 进行一些配置</p><p>==注意：mybatis 的核心配置文件内不可以书写中文注释 (英文或数字可以)，否则报错==</p><p>mybatis 提供了很多标签进行配置，但是这些标签也有着先后顺序，如果标签不按顺序书写也是会报错的</p><ul><li>configuration（配置文件的根标签）<ul><li>properties（属性)</li><li>settings（设置)</li><li>typeAliases（类型别名)</li><li>typeHandlers（类型处理器)</li><li>objectFactory（对象工厂)</li><li>plugins（插件)</li><li>environments（环境配置）<ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li>databaseIdProvider（数据库厂商标识)</li><li>mappers（映射器）</li></ul></li></ul><p>上面来自 mybatis 官方文档，这里会挑常用的标签进行笔记</p><h3 id="Environments-环境配置">Environments 环境配置</h3><h4 id="1-环境的选择">1. 环境的选择</h4><p>在 mybatis 配置文件中使用 <code>environments</code> 标签配置环境，在他下面可以有一个或多个 <code>environment</code> 子标签，每个都代表一个环境，然后在 <code>environments</code> 标签中使用 default 属性对环境进行选择</p><blockquote><p>这里使用 default 对环境进行选择，目前选择的是MySQL的环境</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>        这是MySQL的环境<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;oracle&quot;</span>&gt;</span><br>        这是oracle的环境<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除开配置文件内的默认环境，也可以在打开<font color="red">打开会话工厂的时候传入指定环境的id进行选择环境</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is, <span class="hljs-string">&quot;mysql&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>注意： 尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p><h4 id="2-事务管理器">2. 事务管理器</h4><p>在每个 <code>environment</code> 子标签环境中有 <code>transactionManager</code> 标签的 type 属性可以对 SQL 进行事务控制管理，管理事务的管理器有两种：【 JDBC 】【 MANAGED 】</p><table><thead><tr><th>事务管理器</th><th>说明</th></tr></thead><tbody><tr><td>JDBC</td><td>直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</td></tr><tr><td>MANAGED</td><td>什么都不做，让容器来管理事务的整个生命周期，不建议使用</td></tr></tbody></table><p>建议使用 JDBC 来管理事务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-数据源">3. 数据源</h4><p>数据源是配置 mybatis 和数据库进行连接的相关配置，他由 <code>environment</code> 标签下的 <code>dataSource</code> 标签进行设置</p><p>通过 <code>dataSource</code> 标签的 type 属性可以选择数据源类型：</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>UNPOOLED</td><td>只是每次被请求时打开和关闭连接，反应较慢，适用于简单小型项目</td></tr><tr><td>POOLED</td><td>相对于UNPOOLED相比使用了 数据库连接池 的感念</td></tr><tr><td>JNDI</td><td>能在如 EJB 或应用服务器这类容器中使用</td></tr></tbody></table><p>数据源最基本的四个属性：</p><ul><li>【driver】 数据库连接驱动类</li><li>【url】 数据库链接地址</li><li>【username】 用户名</li><li>【password】 密码</li></ul><p><strong>最常见的 <code>environments</code> 标签配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///test&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;******&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Mappers-映射标签">Mappers 映射标签</h3><p>书写的 mapper 文件需要被映射到核心配置文件中，映射的标签就是 <code>mappers</code> ，他下面有两个子标签，分别是 <code>mapper</code> 和 <code>package</code> 映射方法如下：</p><p><strong>1. 映射的文件在resources目录下</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 映射单个文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;beanMapper.xml&quot;</span>/&gt;</span>&gt;<br>    <span class="hljs-comment">&lt;!-- 使用 * 通配符映射多个文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;*Mapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2. 映射的文件在dao包下</strong></p><blockquote><p>当 mapper 文件在 dao 包下的时，mapper 和接口必须是同名的，或者在 resources 目录下有着同级的目录</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 映射单个文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;club.hanzhe.dao.BeanDao&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 映射多个文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;club.hanzhe.dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>3. 接口注解开发</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;club.hanzhe.dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意！当mapper文件在dao包下的时候，需要在maven的pom文件中添加如下代码，否则xml文件可能不会被打包发布</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Properties-属性">Properties 属性</h3><p>我们在使用传统 JDBC 的时候都会把 driver，url 等等放在一个 propertis 后缀的文件中，这样可以降低代码的耦合性，方便环境切换，mybatis 中也支持这种做法，使用 <code>properties</code> 标签就可以实现</p><p><strong>1. 手写 properties 配置文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1/库名</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">*****</span><br></code></pre></td></tr></table></figure><p><strong>2. 使用 properties 标签将配置文件引入进来</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用该标签将配置文件引入进来，然后就可以使用 $&#123;&#125; 符号来调用配置文件内的值了 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 例如： --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="TypeAliases-别名">TypeAliases 别名</h3><p>在我们的 mapper 映射文件中，CRUD 标签中的参数，返回结果 resultType 通常都是全限定名，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;club.hanzhe.bean.Bean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个时候我们就可以使用 <code>typeAliases</code> 标签下的 <code>typeAlias</code> 子标签==配置类别名==，可以简化全限定名书写格式</p><blockquote><p>abc就是这个类的类别名，就可以在映射文件中使用了</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;club.hanzhe.bean.Bean&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;abc&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;abc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><code>typeAlias</code> 标签中的 alias 属性也可以忽略不写，默认已类名作为别名 (别名首字母小写即可)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;club.hanzhe.bean.Bean&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;bean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但如果是个较大的项目，表和实体类比较多，如果逐个实体类配置的话会很麻烦，这时可以使用 <code>package</code> 子标签</p><blockquote><p>将指定包下的所有类全部配置别名，别名为类本身名字 (首字母小写)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;club.hanzhe.bean&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;bean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Settings-全局设置">Settings 全局设置</h3><p>在 mybatis 中可以对全局进行一些设置，设置需要用 <code>settings</code> 下的 <code>setting</code> 子标签实现，格式体现为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;设置名称&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;对应参数值&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p>常用的设置有：</p><table><thead><tr><th>设置名</th><th>作用描述</th><th>参数</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>设置全局缓存的开启和关闭</td><td>boolean</td></tr><tr><td>defaultStatementTimeout</td><td>设置超时时间，它决定驱动等待数据库响应的秒数。</td><td>任意正整数</td></tr><tr><td>mapUnderscoreToCamelCase</td><td>是否开启驼峰命名规则</td><td>boolean</td></tr><tr><td>logImpl</td><td>配置日志信息，个人推荐使用 STDOUT_LOGGING 日志</td><td>@官方文档</td></tr></tbody></table><h2 id="Mapper-映射文件">Mapper 映射文件</h2><p>mapper 映射文件，用来负责和数据库交互的 sql 代码，主要是增删改查四个标签为主：</p><h3 id="增删改标签">增删改标签</h3><p>增删改标签是用来书写插入 sql 的标签，比较常用的几个属性如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span></span><br><span class="hljs-tag"> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addBean&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;club.hanzhe.bean&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>id</td><td>用来作为标签的标识符，使用id可以直接找到当前标签调用</td></tr><tr><td>parameterType</td><td>接受的参数的类型，如果参数类型是集合，那么就填集合内元素的类型</td></tr><tr><td>flushCache</td><td>增删改标签默认设置为true，只要语句被调用，就会清空本地和二级缓存</td></tr><tr><td>timeout</td><td>抛出异常之前，驱动程序等待响应的时间，默认为空值</td></tr></tbody></table><h3 id="查询标签">查询标签</h3><p>select 标签是用来专门书写查询语句的标签，比较常用的几个属性如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span></span><br><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPerson&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;hashmap&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;personResultMap&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;10&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">fetchSize</span>=<span class="hljs-string">&quot;256&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">resultSetType</span>=<span class="hljs-string">&quot;FORWARD_ONLY&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除开增删改相同的属性之外，查询有着自己的属性</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>resultType</td><td>用来设置查询返回的数据对应的实体类</td></tr><tr><td>resultMap</td><td>属于高级的parameterType，他可以手动配置实体类属性和数据库字段的映射</td></tr><tr><td>useCache</td><td>select 默认为 true，执行查询后将查询结果缓存在二级缓存中</td></tr></tbody></table><h3 id="添加时返回-ID">添加时返回 ID</h3><p>这里记一个十分好用的小功能，当我们执行 insert 之后，想要立刻操作这行记录，但是他的主键是自增的，我们想要操作他需要获取他的 ID，这个时候我们可以通过属性设置回显 ID</p><p>假设当前有一个 bean，属性为 userid，username，password</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- useGeneratedKeys=&quot;true&quot; 取出数据库内自动生成的主键 --&gt;</span><br><span class="hljs-comment">&lt;!-- keyProperty=&quot;userid&quot; 将主键设置在 bean 中的某个属性上 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span><span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;userid&quot;</span>&gt;</span><br> insert into t_user values(#&#123;username&#125;, #&#123;password&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setUsername(<span class="hljs-string">&quot;张&quot;</span>);<br>    user.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br>    userDao.addUser(user);<br>    <span class="hljs-comment">// 当我们执行插入语句后，如果正常运行，那么userid就会成功赋值</span><br>    System.out.println(user.getUserid());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SQL-代码片段">SQL 代码片段</h3><p>可以被用来定义可重用的 SQL 代码段，例如：</p><blockquote><p>定义了 id 为 t_user 的 sql 代码片段，在下面的增删改查中就可以使用 <code>include</code> 来调用了</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;t_user&quot;</span>&gt;</span>userid, username, usersex, usertel<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    SELECT <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;t_user&quot;</span> /&gt;</span> FROM t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="和-的区别">${ } 和 #{ } 的区别</h3><p>${ }和#{ }他们都是用来接收传入参数的，只不过有些细节需要留意，假设现在有一行SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> userid <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>其中作为查询条件的 1 是需要接收传入参数的，那么获取到传入参数有两种方法：</p><ul><li>${ }，拼接SQL字符串</li><li>#{ }，作为SQL占位符</li></ul><p>如果使用 ${} 的话，通过日志可以看到，它以拼接字符串的方式执行，这样的话就很容易收到SQL注入的攻击</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> userid <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>但是如果使用 #{} 的话，他是将 SQL 代码预处理之后在执行之前进行参数替换，传入的参数都将作为普通参数对待，通过执行日志就可以看到：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> userid <span class="hljs-operator">=</span> ? ;<br></code></pre></td></tr></table></figure><p>这是二者最明显的差距，通过占位符可以有效防止SQL注入攻击，推荐使用#{ }</p><h3 id="ResultMap-标签">ResultMap 标签</h3><p>一般使用 resultType 返回对象的时候，是数据库自动检测实体类中和字段匹配的属性进行封装，但是如果实体类中的属性和表中的字段截然不同的话，就需要手动配置他们之间的映射关系了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">  id：为当前标签的命名，会在select标签中的返回类型中用到</span><br><span class="hljs-comment">  type：为返回的主类的类型，Student中包含Score类型的变量，所以Sutdent是主类</span><br><span class="hljs-comment">  extends：继承，将指定的resultMap的id作为值放在这里，会继承之前书写的映射</span><br><span class="hljs-comment">  autoMapper：为其他属性自动匹配的开关，默认为false关闭状态</span><br><span class="hljs-comment">   为false时，只有手动配置的映射会匹配成功，未设置的为null值</span><br><span class="hljs-comment">   为true时，将按照手动配置的进行匹配，没有手动配置的会自动按照变量名匹配</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;map1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;club.hanzhe.pojo.U_T&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">       id标签为设置当前主类与数据表中对应表的主键的匹配</span><br><span class="hljs-comment">       column：数据表中的字段</span><br><span class="hljs-comment">       property：与该字段对应的本类中的属性</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rowNo&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;rowNo&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">   result标签为设置当前主类与数据表中对应表的其他字段的匹配</span><br><span class="hljs-comment">   column：数据表中的字段</span><br><span class="hljs-comment">   property：与该字段对应的本类中的属性</span><br><span class="hljs-comment">  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;u_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userid&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">   association标签为设置当前主类中映射的其他类</span><br><span class="hljs-comment">   property：类中的属性</span><br><span class="hljs-comment">   javaType：属性所对应的那个类的全限定名，可以使用别名</span><br><span class="hljs-comment">   autoMapping：自动匹配表中的其他字段和类中的属性</span><br><span class="hljs-comment">  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tel&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;club.hanzhe.pojo.Tel&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;t_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;telid&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">   collection用来映射集合，多用于一对多查询 </span><br><span class="hljs-comment">   与association的唯一差别就是javaType变成了ofType </span><br><span class="hljs-comment">  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tel&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;club.hanzhe.pojo.Tel&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;t_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;telid&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="动态-SQL">动态 SQL</h3><p>通过传入的参数对 sql 进行灵活化使用，类似 Java 一样，通过 判断循环 来控制 SQL 的最终执行</p><blockquote><p>if 判断标签</p></blockquote><p>如果接收的username参数不为空的话，就追加当前标签内的sql语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findBean&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;bean&quot;</span>&gt;</span><br>    select * from test<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null and id != &#x27;&#x27;&quot;</span>&gt;</span><br>        where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>where 过滤标签</p></blockquote><p>使用 where 标签之后，如果 where 内有符合 if 条件的会自动添加 where 关键字，如果没有符合的就不添加</p><p>如果有多个 if 符合条件，需要在前面加上 and 或者 or 等判断条件，如果是第一个成立的条件会默认省略前面的 and 或 or，后续的会添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    select * from t_user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userid != null&quot;</span>&gt;</span><br>            and userid = #&#123;userid &#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>            and username like #&#123;username &#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;usersex != null&quot;</span>&gt;</span><br>            and usersex = #&#123;usersex &#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;usertel!= null&quot;</span>&gt;</span><br>            and usertel = #&#123;usertel &#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>choose 标签</p></blockquote><p>choose 标签有着和 switch 类似的功能，他要求当前判断至少成立一个才可以结束，如果没有成立的会执行otherwise</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>set 标签</p></blockquote><p>使用 set 标签之后，如果 set 内有符合 if 条件的会自动添加 set 关键字，如果没有符合的就不添加，需要注意一点的是，==set → if 内的 sql 结尾一定要带上逗号==，系统会自动省略但不会自动追加。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span> &gt;</span><br>    update t_user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span><br>            username = #&#123;username &#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;usersex != null and usersex != &#x27;&#x27;&quot;</span>&gt;</span><br>            usersex = #&#123;usersex &#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;usertel != null and usertel != &#x27;&#x27;&quot;</span>&gt;</span><br>            usertel = #&#123;usertel &#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where userid = #&#123;userid &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>foreach 标签</p></blockquote><p>foreach 标签用来遍历传进来的集合或数组容器，多用于批量删除操作，里面的属性解释如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;find1&quot;</span>&gt;</span><br> delete from bean where id in<br> <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;, &quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;i&quot;</span>&gt;</span><br>  #&#123; i &#125;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>collection：传进来被遍历的那个容器的名字，可以是数组或集合</li><li>open：循环开始前需要添加的前缀</li><li>close：循环结束后需要添加的后置</li><li>separator：每循环一次时需要在中间添加的分隔符</li><li>item：被循环出来的每个字段，在标签内直接使用即可</li></ul><h3 id="cache-缓存标签">cache 缓存标签</h3><h5 id="一级缓存">一级缓存</h5><p>在 mybatis 中<font color="red">一级缓存</font>是默认开启的，在进行 openSession 的时候就自动打开了一级缓存，且对于一级缓存的操作，只能清空，不能禁用，<font color="red">一级缓存的作用范围是当前的 SqlSession 实例</font></p><blockquote><p>在同一个 SqlSession 实例中，两次同样的查询返回的结果是一致的，但是如果是两个SqlSession那么进行相同的查询结果就会不同，这里就不写了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.factory.openSession(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">BeanDao</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BeanDao.class);<br>    <span class="hljs-type">Bean</span> <span class="hljs-variable">bean1</span> <span class="hljs-operator">=</span> mapper.findById(<span class="hljs-number">7844</span>);<br>    <span class="hljs-type">Bean</span> <span class="hljs-variable">bean2</span> <span class="hljs-operator">=</span> mapper.findById(<span class="hljs-number">7844</span>);<br>    System.out.println(bean1 == bean2);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二级缓存">二级缓存</h5><p>二级缓存的范围是基于当前的 mapper.xml 配置文件的 mapper 标签，也就是当前的 namespace 下，一个二级缓存可以横跨多个一级缓存，而二级缓存默认是关闭的，开启二级缓存的方法就是==使用 cache标签==</p><blockquote><p>没错，只要在 mapper 下面加上这么一句代码，二级缓存就开启完成了，简单粗暴</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>在开启二级缓存后还不能立刻使用，会报错，==需要让该 mapper 相关的所有 bean 实现 Serializable 序列化接口==</p><h2 id="Mybatis-注解开发">Mybatis 注解开发</h2><h3 id="CRUD-注解">CRUD 注解</h3><p>在 mybatis 中也可以不使用 mapper 映射文件，改为使用注解开发，分别相对着增删改查四个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Insert(&quot;insert into t_user values(null,#&#123;name&#125;,#&#123;sex&#125;,#&#123;address&#125;)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(User user)</span>;<br><br><span class="hljs-meta">@Delete(&quot;DELETE FROM t_user WHERE u_id = #&#123;abc&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeUser</span><span class="hljs-params">(Integer id)</span>;<br><br><span class="hljs-meta">@Update(&quot;update t_user set u_address=#&#123;address&#125; where u_name = #&#123;name&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(User user)</span>;<br><br><span class="hljs-meta">@Select(&quot;select * from t_user where u_id = #&#123;abc&#125;&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span><span class="hljs-params">( Integer id )</span>;<br></code></pre></td></tr></table></figure><p>注意！使用 mapper 文件的时候需要扫描 mapper 文件所在位置，然后才可以使用，使用注解开发也需要扫描：</p><blockquote><p>将所有带有注解的接口都扫描</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;club.hanzhe.dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Result-注解">Result 注解</h3><p>使用 xml 开发时，会遇到字段与实体类属性名不匹配造成封装失败的情况，起别名解决是一种方法，但是一般都使用 resultMap 结果映射，将字段与属性匹配，注解开发也可以使用 resultMap，对应的注解是 <code>@Results</code></p><blockquote><p>使用注解的方式匹配字段与属性查询</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Results(</span><br><span class="hljs-meta">    id = &quot;r1&quot;, // id：给当前results起名字，像resultMap一样继承使用</span><br><span class="hljs-meta">    value = &#123; // value：配置多个映射</span><br><span class="hljs-meta">  /*</span><br><span class="hljs-meta">   *  @Result中的属性：</span><br><span class="hljs-meta">   *   id：表中的id列是否为主键，是为true，不写默认为false</span><br><span class="hljs-meta">   *   column：表中的字段</span><br><span class="hljs-meta">   *   property：表中字段对应的pojo中的属性</span><br><span class="hljs-meta">   *   只需要将不匹配的字段属性配上即可，匹配的可以省略不写</span><br><span class="hljs-meta">   */</span><br><span class="hljs-meta">        @Result( column = &quot;u_id&quot; , property = &quot;id&quot; ),</span><br><span class="hljs-meta">        @Result( column = &quot;u_name&quot; , property = &quot;name&quot; ),</span><br><span class="hljs-meta">        @Result( column = &quot;u_sex&quot; , property = &quot;sex&quot; ),</span><br><span class="hljs-meta">        @Result( column = &quot;u_address&quot; , property = &quot;address&quot; )</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span><span class="hljs-params">( Integer id )</span>;<br></code></pre></td></tr></table></figure><blockquote><p>如果有另一个查询与他的规则相同，那么可以引用之前写的Results的id属性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from t_user where u_name = #&#123;abc&#125;&quot;)</span><br><span class="hljs-meta">@ResultMap(&quot;r1&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserByName</span><span class="hljs-params">( String name )</span>;<br></code></pre></td></tr></table></figure><h2 id="扩展功能">扩展功能</h2><h3 id="Mybatis-逆向工程">Mybatis 逆向工程</h3><p>逆向工程是根据数据库中表的信息进行自动创建实体类，接口，映射文件的技术</p><h4 id="1-环境配置"><strong>1. 环境配置</strong></h4><p>使用逆向工程必须引入他的依赖或jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-逆向工程配置文件">2. 逆向工程配置文件</h4><p>你可以<font color="red">在任意位置 ( 包括项目外 ) </font>创建逆向工程所需要的配置文件，需要手动配置的地方有以下几点：</p><ul><li>properties 标签中的配置文件需要自己书写，也可以书写该标签及文件</li><li>jdbcConnection 标签需要修改，修改需参考上面的 properties 配置文件</li><li>javaModelGenerator 标签需要修改，他是实体类生成的目标包路径</li><li>sqlMapGenerator 标签需要修改，他是 mapper 映射文件生成的目标路径</li><li>javaClientGenerator 标签需要修改，他是接口生成的目标包路径</li><li>table 标签的 tableName 属性需要修改，他是逆向工程所参考的数据表<ul><li>如有多个表被参考就书写多个 table 标签，可以直接复制修改 tableName 属性</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testTables&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--是否去除自动生成的注释 true是：false 否--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库连接--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span> <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaTypeResolver</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;forceBigDecimals&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaTypeResolver</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--生成的实体类存放的位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;club.hanzhe.bean&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--enableSubPackages,是否让schema作为包的后缀--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!--从数据库返回的值被清除前后空格--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--mapper映射文件存放的位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/resources&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;mappers&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--targetPackage:mapper接口生成的位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;club.hanzhe.dao&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--tableName为逆向工程针对的表的表名，可以通配符匹配所有表，剩下的属性统统false--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;%&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">enableCountByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableUpdateByExample</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">enableDeleteByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableSelectByExample</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">selectByExampleQueryId</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-使用逆向工程">3. 使用逆向工程</h4><p>在环境配置完成后使用下面这段模板代码，运行后就会将实体类，接口，mapper文件自动生成</p><blockquote><p>需要在改代码中手动设置配置文件的文件名及位置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;<br><span class="hljs-keyword">import</span> org.mybatis.generator.config.Configuration;<br><span class="hljs-keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;<br><span class="hljs-keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generator</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; warnings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">overWriter</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 这里加载刚刚创建的逆向工程配置文件</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">configFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;文件位于磁盘的绝对路径&quot;</span>);<br>            <span class="hljs-type">ConfigurationParser</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigurationParser</span>(warnings);<br>            <span class="hljs-type">Configuration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> cp.parseConfiguration(configFile);<br>            <span class="hljs-type">DefaultShellCallback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultShellCallback</span>(overWriter);<br>            <span class="hljs-type">MyBatisGenerator</span> <span class="hljs-variable">myBatisGenerator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBatisGenerator</span>(config, callback, warnings);<br>            myBatisGenerator.generate(<span class="hljs-literal">null</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;操作失败！&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;==================================================&quot;</span>);<br>            System.out.println(e);<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PageHelper-分页插件">PageHelper 分页插件</h3><p>pageHelper 插件是针对 mybatis 设计的一款分页插件，通过拦截器对 sql 进行操作，使其拥有分页的能力</p><h4 id="1-环境配置-v2">1. 环境配置</h4><p>使用 pageHelper 分页插件需要导入他的 maven 依赖或者导入他的 jar 包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 可以官网查询最新版 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 maven 依赖添加完成后，还需要在 mybatis 的核心配置文件中使用 <code>plugins</code> 标签注册 pageHelper 插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-使用PageHelper">2. 使用PageHelper</h4><p>PageHelper 依赖引入后，在程序中就有了 PageHelper 类，调用它的 startPage 静态方法，后紧跟的第一条查询语句就是分页查询</p><blockquote><p>startPage 的静态方法需要两个参数，第一个是查询的页码，第二个是每页的查询数量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 查询第二页，每页5条记录</span><br>    PageHelper.startPage(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br>    List&lt;Bean&gt; list = mapper.findAll();<br>    <span class="hljs-keyword">for</span> (Bean bean : list)<br>        System.out.println(bean);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>分页除了 PageHelper 类，还有一个 PageInfo 可以使用，将查询的结果封装到 PageInfo 中，可以查询一些和分页相关的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> factory.openSession();<br>    <span class="hljs-type">BeanDao</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BeanDao.class);<br>    PageHelper.startPage(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-type">PageInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>(mapper.findAll());<br>    System.out.println(<span class="hljs-string">&quot;总页码：&quot;</span> + info.getPages());<br>    System.out.println(<span class="hljs-string">&quot;总记录数：&quot;</span> + info.getTotal());<br>    System.out.println(<span class="hljs-string">&quot;结果集：&quot;</span>);<br>    List&lt;Bean&gt; list = info.getList();<br>    <span class="hljs-keyword">for</span> (Bean bean : list)<br>        System.out.println(bean);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-PageInfo常用参数">3. PageInfo常用参数</h4><p>在将结果集封装到 PageInfo 中的时候，可以可选性的传入一个导航页码的参数，可以获取到和当前页相邻的页码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> factory.openSession();<br>    <span class="hljs-type">BeanDao</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BeanDao.class);<br>    PageHelper.startPage(<span class="hljs-number">201</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 在创建info对象的时候可以跟随一个int类型，这个值是当前页附近的页码的数量</span><br>    <span class="hljs-type">PageInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>(mapper.findAll(), <span class="hljs-number">7</span>);<br>    System.out.println(<span class="hljs-string">&quot;当前页：&quot;</span> + info.getPageNum());<br>    System.out.println(<span class="hljs-string">&quot;每页显示数量：&quot;</span> + info.getPageSize());<br>    System.out.println(<span class="hljs-string">&quot;当前页信息：&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Object obj : info.getList())<br>        System.out.println(obj);<br>    System.out.println(<span class="hljs-string">&quot;总页码：&quot;</span> + info.getPages());<br>    System.out.println(<span class="hljs-string">&quot;总记录数：&quot;</span> + info.getTotal());<br>    System.out.println(<span class="hljs-string">&quot;上一页：&quot;</span> + info.getPrePage());<br>    System.out.println(<span class="hljs-string">&quot;下一页：&quot;</span> + info.getNextPage());<br>    System.out.println(<span class="hljs-string">&quot;是否首页：&quot;</span> + info.isIsFirstPage());<br>    System.out.println(<span class="hljs-string">&quot;是否尾页：&quot;</span> + info.isIsLastPage());<br>    System.out.println(<span class="hljs-string">&quot;导航条页码:&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> page : info.getNavigatepageNums() )<br>        System.out.print( page + <span class="hljs-string">&quot;  &quot;</span> );<br>    System.out.println(<span class="hljs-string">&quot;\n导航条中首页&quot;</span> + info.getNavigateFirstPage());<br>    System.out.println(<span class="hljs-string">&quot;导航条中尾页&quot;</span> + info.getNavigateLastPage());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里需要注意！==每页显示数量是指分页是设置的数量==，例如设置每页只显示5条，获取到的就是5，而不是最后一页只显示三条就返回三，这是错误的</li></ul><h4 id="合理化查询">合理化查询</h4><p>在网页中往往有些人会钻空子乱改数据，例如只有20页数据，他修改了参数请求到了第50页，这种情况经常会发生，所以在注册 pageHelper 的时候可以添加一个参数使数据变得合理化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;reasonable&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Lombok-插件">Lombok 插件</h3><p>在我们进行查询的时候，需要将查询的结果封装到指定的实体类中，而对应的实例类需要书写响应的 get set 方法，构造方法及 toString 方法，这样比较麻烦，这是可以使用 lombok 插件进行自动生成功能</p><h4 id="1-环境配置-v3">1. 环境配置</h4><p>使用 lombok 需要引入他的 maven 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在依赖引入后还需要在编辑器中安装 lombok 的插件 ( IDEA 编辑器为例 ) <code>File → settings → plugins → install JetBrains plugin...</code> 在里面搜索 lombok 下载安装，而后在 <code>file → settings → build,Exe.. → Compiler → Annotation Pro...</code> 里面选中当前项目，在右面的 <code>Enable annotation processing</code> 选项打勾</p><h4 id="2-使用-Lombok-插件">2. 使用 Lombok 插件</h4><p>在目标实体类上，只需要书写好属性即可，无需书写其他多余方法，使用 lombok 提供的注解用来一键生成：</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Getter</td><td>一键生成所有 get 方法</td></tr><tr><td>@Setter</td><td>一键生成所有 set 方法</td></tr><tr><td>@ToString</td><td>一键生成 toString 方法</td></tr><tr><td>@Data</td><td>一键生成 get set toString 等方法</td></tr><tr><td>@NoArgsConstructor</td><td>生成无参构造方法</td></tr><tr><td>@AllArgsConstructor</td><td>生成有参构造方法</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 中的 IO 流</title>
    <link href="/2021/04/13/Java%E7%AC%94%E8%AE%B0/IO%E6%B5%81%E6%8A%80%E6%9C%AF/"/>
    <url>/2021/04/13/Java%E7%AC%94%E8%AE%B0/IO%E6%B5%81%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-IO">Java IO</h2><p>Java 中的 IO 流是我们通过程序对磁盘或网络中的某个文件进行某种操作的时候使用的技术</p><h3 id="File-文件类">File 文件类</h3><p>File 类是专门对文件进行操作的类，一个 File 实例代表硬盘中实际存在的一个文件或者目录，需要注意的是 <strong>它只能针对文件进行操作，并不能操作文件中的内容</strong></p><blockquote><p>创建 File 类的实例</p></blockquote><p>既然说 File 类是操作文件的，那么当然一个类对应的就是一个文件或者目录了，所以我们要在创建的时候就要告诉他代表的是什么，创建 File 类实例最常见的三种方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取File类的实例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFile1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 直接获取目标文件实例</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>);<br>        <span class="hljs-comment">// 获取某个目录下的文件实例</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/example/&quot;</span>, <span class="hljs-string">&quot;3.txt&quot;</span>);<br>        <span class="hljs-comment">// 获取某个File类实例(对应的是文件夹)下的某个文件实例</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/example/&quot;</span>), <span class="hljs-string">&quot;3.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>File 类的常用方法：判断方法</p></blockquote><p>File 类具体指向的是什么样的字符串我们不一定是都知道的，所以我们需要依靠一些判断的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// File类的判断方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFile1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;目标是否存在：&quot;</span> + file.exists());<br>        System.out.println(<span class="hljs-string">&quot;是否是文件：&quot;</span> + file.isFile());<br>        System.out.println(<span class="hljs-string">&quot;是否是文件夹：&quot;</span> + file.isDirectory());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>File 类的常用方法：获取方法</p></blockquote><p>我们想要通过 File 示例拿到相应的信息，就需要用到获取方法啦，方法多了点这里列了一个表格：</p><table><thead><tr><th>调用者</th><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>文件</td><td>getName()</td><td>获取文件 ( 夹 ) 名称</td></tr><tr><td>文件</td><td>getPath()</td><td>获取文件 ( 夹 ) 相对路径</td></tr><tr><td>文件</td><td>getAbsolutePath()</td><td>获取文件 ( 夹 ) 绝对路径</td></tr><tr><td>文件</td><td>length()</td><td>获取文件大小 ( 单位：字节 )</td></tr><tr><td>文件夹</td><td>list()</td><td>获取文件夹下所有文件 ( 夹 ) 的字符串数组</td></tr><tr><td>文件夹</td><td>listFiles()</td><td>获取文件夹下所有文件 ( 夹 ) 的 File 类数组</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// File类的获取方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFile1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;==文件类型=============================&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;文件名称：&quot;</span> + file.getName());<br>        <span class="hljs-comment">// 当我们用相对路径创建File对象的时候返回的就是相对路径</span><br>        System.out.println(<span class="hljs-string">&quot;相对路径：&quot;</span> + file.getPath());<br>        System.out.println(<span class="hljs-string">&quot;绝对路径：&quot;</span> + file.getAbsolutePath());<br>        System.out.println(<span class="hljs-string">&quot;文件大小：&quot;</span> + file.length() + <span class="hljs-string">&quot;字节&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;==文件夹类型===========================&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">folder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/example/&quot;</span>);<br>        <span class="hljs-comment">// 如果File对象指向的是一个文件夹的话返回值是位置的，测试结果是0</span><br>        System.out.println(<span class="hljs-string">&quot;文件大小：&quot;</span> + folder.length() + <span class="hljs-string">&quot;字节&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : folder.list())<br>            System.out.print( s + <span class="hljs-string">&quot;  &quot;</span> );<br>        System.out.println();<br>        <span class="hljs-keyword">for</span> (File f : folder.listFiles())<br>            System.out.print( f.getName() + <span class="hljs-string">&quot;  &quot;</span> );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【8位( Bit ) = 1字节( Byte ) 】–【1024字节( Byte ) = 1兆( M ) 】–【1024兆( M ) = 1G 】</li></ul><blockquote><p>File 类的常用方法：创建、重命名以及删除</p></blockquote><p>判断和获取已经了解的差不多了，接下来了解一下创建、重命名和删除函数，File 类基本也就差不多了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建、重命名以及删除</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFile1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 这个4.txt本身是不存在的</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/example/4.txt&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;创建文件：&quot;</span> + file.createNewFile());<br>        <span class="hljs-comment">// 这个test目录也是不存在的</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">folder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/example/test/&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;创建目录：&quot;</span> + folder.mkdir());<br>        System.out.println(<span class="hljs-string">&quot;创建多级目录：&quot;</span> + <br>                           <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/example/test/1/2/3/4/5/6/&quot;</span>).mkdirs());<br>        <span class="hljs-comment">// 重命名文件</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">newName</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/example/40.txt&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;文件重命名&quot;</span> + file.renameTo(newName));<br>        <span class="hljs-comment">// 删除函数，需要注意的是多级目录无法直接删除，这里写了一个递归删除的函数</span><br>        System.out.println(<span class="hljs-string">&quot;删除文件：&quot;</span> + newName.delete());<br>        System.out.println(<span class="hljs-string">&quot;删除文件夹：&quot;</span> + folder.delete());<br>        System.out.println(<span class="hljs-string">&quot;递归删除&quot;</span> + deletes(folder));<br>    &#125;<br>    <span class="hljs-comment">// 递归删除函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deletes</span><span class="hljs-params">( File file )</span>&#123;<br>        <span class="hljs-keyword">if</span> (file.isDirectory() &amp;&amp; file.list().length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (File f : file.listFiles())<br>                deletes(f);<br>            file.delete();<br>        &#125; <span class="hljs-keyword">else</span> file.delete();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小练习：递归遍历某个目录下的所有 文件/文件夹，最终删除名为【病毒.exe】的文件 ( 文件自己创建 )</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归遍历以及删除</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFile1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">marker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;|-&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/_Zhe/&quot;</span>);<br>        findAndDelete(root);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findAndDelete</span><span class="hljs-params">( File file )</span>&#123;<br>        <span class="hljs-keyword">if</span>( file.isDirectory() &amp;&amp; file.list().length &gt; <span class="hljs-number">0</span> )&#123;<br>            System.out.println(marker.toString() + file.getName());<br>            <span class="hljs-keyword">for</span> (File f : file.listFiles())&#123;<br>                marker.append(<span class="hljs-string">&quot;-&quot;</span>);<br>                findAndDelete(f);<br>                marker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(marker.substring(<span class="hljs-number">0</span>, marker.length()-<span class="hljs-number">1</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(marker.toString() + file.getName());<br>            <span class="hljs-keyword">if</span> ( file.getName().equals(<span class="hljs-string">&quot;病毒.exe&quot;</span>) ) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> file.getAbsolutePath();<br>                file.delete();<br>                System.out.println(<span class="hljs-string">&quot;**********************************************&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;已删除【病毒.exe】，位于&quot;</span> + path);<br>                System.out.println(<span class="hljs-string">&quot;**********************************************&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IO-流概念">IO 流概念</h3><p>IO 流，I 代表 input，O 代表 output，所以 IO 流就是输入输入的数据流</p><p>**流的分类：**Java 中的 IO 流有两大分类：以字节为单位的 <strong>字节流</strong> 以及以字符为单位 <strong>字符流</strong></p><p>**流的方向：**两大分类中每种流都有两个方向，以当前应用程序的内存为基准，将硬盘中的某个文件读入内存中叫做 <strong>输入流</strong>，将内存中的数据写到硬盘上的某个文件中，称为 <strong>输出流</strong></p><p>共两大分类四种类型，旗下又有多个实现类，类关系图如下所示：</p><p><img src="C:/Users/Administrator/Desktop/Markdown/img/JavaSenior-02.jpg" alt="IO类关系图-屈博老师"></p><blockquote><p>关于关流</p></blockquote><p>**1.**无论是输入流还是输出流，在我们 IO 流使用完成后一定要记得 <code>close()</code> 关流</p><p>**2.**如果输入输入同时使用的话，优先关闭输出流，再关闭输入流</p><p>**3.**如果流之前有一来关系 ( 例如字符流依赖字节流 )，需要先关闭后者，最后关闭前者</p><h3 id="字节输出流">字节输出流</h3><p><code>FileOutputStream</code> 为字节输出流，常用函数包含：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>close()</td><td>关闭流</td></tr><tr><td>flush()</td><td>刷新此输出流将数据都写出</td></tr><tr><td>write(int b)</td><td>将指定的字节输出</td></tr><tr><td>write(byte[] b)</td><td>输出整个字节数组</td></tr><tr><td>write(byte[] b, int off, int len)</td><td>基于 b 数组，从下标 off 开始写满 len 个字节</td></tr></tbody></table><p>想要使用字节输出流首先需要创建他的实例</p><blockquote><p>创建字节输出流实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建字节输出流的方法有两种，这里推荐直接使用第一种路径字符串</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileOutputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>));<br>        fos.close();<br>        fos2.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里需要注意，输出流在 new 对象的时候就已经在目标位置创建好文件了，如果文件已存在会进行覆盖。</li></ul><blockquote><p>向文件中输出数据</p></blockquote><p>之前的表格中有介绍输出的函数 write，这个函数重载了三次，我们来分别测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// write函数测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileOutputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 每次只写出一个字节</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>);<br>        fos.write(<span class="hljs-number">97</span>);<br>        fos.write(<span class="hljs-number">98</span>);<br>        fos.write(<span class="hljs-number">99</span>);<br>        fos.close();<br>        <span class="hljs-comment">// 写出整个字节数组</span><br>        fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/example/4.txt&quot;</span>);<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-string">&quot;You can kill me, but you can&#x27;t fuck me&quot;</span>.getBytes();<br>        fos.write(bytes);<br>        fos.close();<br>        <span class="hljs-comment">// 从指定位置开始，写满len个后结束 -- kill</span><br>        fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/example/5.txt&quot;</span>);<br>        fos.write(bytes, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>);<br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>字节输出流实现续写，换行</p></blockquote><p>流一旦关闭后再次创建写入数据就会把之前的数据都弄丢掉，这点就比较烦，这里我们通过在创建实例对象的时候传入一个 <code>true</code> 值来实现续写的功能：</p><ul><li><code>public FileOutputStream(String name, boolean append)</code>，name 文件路径，append 是否续写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 续写和换行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileOutputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 写入一行数据</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>);<br>        fos.write(<span class="hljs-string">&quot;You can kill me&quot;</span>.getBytes());<br>        fos.close();<br>        <span class="hljs-comment">// 进行续写</span><br>        fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>, <span class="hljs-literal">true</span>);<br>        fos.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());   <span class="hljs-comment">// 在Windows中：\r 回车符，\n 换行符</span><br>        fos.write(<span class="hljs-string">&quot;but you can&#x27;t fuck me!!!&quot;</span>.getBytes());<br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实现实时输出数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实时输出数据，exit结束输出</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileOutputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;写入数据：&quot;</span>);<br>        <span class="hljs-keyword">while</span> ( flag ) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.nextLine();<br>            <span class="hljs-keyword">if</span>( !str.equals(<span class="hljs-string">&quot;exit&quot;</span>) )<br>                fos.write((str+<span class="hljs-string">&quot;\r\n&quot;</span>).getBytes());<br>            <span class="hljs-keyword">else</span> flag = <span class="hljs-literal">false</span>;;<br>        &#125;<br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字节输入流">字节输入流</h3><p><code>FileOutputStream</code> 为输出流，常用函数如下：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>close()</td><td>关闭流</td></tr><tr><td>read()</td><td>刷新此输出流将数据都写出</td></tr><tr><td>read(byte[] b)</td><td>读取同数组长度的字节数量并存到数组中，读到末尾时返回 -1</td></tr><tr><td>read(byte[] b, int off, int len)</td><td>从下标 off 开始读入 len 个字节并存储到数组中，读到末尾时返回 -1</td></tr></tbody></table><p>和输出流一样有两种构造方法 ( 这里就不写了 )，同样我们直接采用路径字符串的形式进行实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileInputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 一次读取一个字节</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>);<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; (read = fis.read()) != -<span class="hljs-number">1</span>; )<br>            System.out.println((<span class="hljs-type">char</span>)read);<br>        System.out.println(fis.read());<br>        fis.close();<br>        <span class="hljs-comment">// 读取数组长度的字节存放进数组中</span><br>        fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>);<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">5</span>];<br>        fis.read(bytes);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>        <span class="hljs-comment">// 从off开始读取len个存到bytes中</span><br>        fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/example/3.txt&quot;</span>);<br>        bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; (read = fis.read(bytes, <span class="hljs-number">0</span>, bytes.length)) != -<span class="hljs-number">1</span>; )<br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我的 4.txt 文件中只有 abcde 五个英文字母，在读取的时候明显最后一个读到的是 d，原因：</p><p><img src="C:/Users/Administrator/Desktop/Markdown/img/JavaSenior-03.jpg" alt="https://www.cnblogs.com/xichji/p/11793464.html"></p><h3 id="字节流练习-文件复制">字节流练习-文件复制</h3><p>要求：复制某个图片到 D 盘盘根下重命名为 stream.jpg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字节流练习-复制文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamCopyFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;C:/Users/Administrator/Desktop/Markdown/img/1.jpg&quot;</span>;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/stream.jpg&quot;</span>);<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; (len = fis.read(bytes))!= -<span class="hljs-number">1</span>; )<br>            fos.write(bytes);<br>        System.out.println(<span class="hljs-string">&quot;图片复制成功！&quot;</span>);<br>        fos.close();<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字节流与码表">字节流与码表</h3><p>刚刚我们是先学习输出流，通过输出流向文本文件中写入数据，然后再用输入流读回来，如果我们先使用输入流读取文本文件会怎么样呢？我们创建一个 4.txt 来读取一下其中的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileInputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 内容：学习IO流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/example/4.txt&quot;</span>);<br>        <span class="hljs-type">byte</span>[] bs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span>];<br>        fis.read(bs);<br>        <span class="hljs-comment">// 打印：ѧϰIO��  </span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bs));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候我们发现打印出来的竟然是一堆乱码，刚刚练习的时候还是正常的，这是因为我们优先使用的输出流，如果我们没有开启续写的话，输出流默认会重新创建一个新的文件来替换掉之前的旧的文件，新文件就会基于 java 写入的内容来设置对应文件的码表：</p><p><img src="C:/Users/Administrator/Desktop/Markdown/img/JavaSenior-04.jpg" alt=""></p><p>我们读取了 ANSI 码表中的字节通过 <code>new String( bs )</code> 以 UTF-8 进行解码结果当然是乱码的，想要解决这个问题我们只需要在转换的时候为他指定码表就可以了，经测试文本文件的 ANSI 对应的是 GBK：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileInputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 内容：学习IO流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/example/4.txt&quot;</span>);<br>        <span class="hljs-type">byte</span>[] bs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span>];<br>        fis.read(bs);<br>        <span class="hljs-comment">// 打印：学习IO流</span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bs, <span class="hljs-string">&quot;GBK&quot;</span>));<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们已经可以将 ANSI 格式的字节读回 UTF-8 了，那么我们可不可以在输出的时候就输出 ANSI 呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileOutputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/example/4.txt&quot;</span>);<br>        <span class="hljs-comment">// 在获取字节数组的时候传入一个字符串作为码表，他就会按照码表的格式进行转换了</span><br>        fos.write(<span class="hljs-string">&quot;一日三餐想吃好，就吃老八秘制小汉堡&quot;</span>.getBytes(<span class="hljs-string">&quot;GBK&quot;</span>));<br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:/Users/Administrator/Desktop/Markdown/img/JavaSenior-05.jpg" alt=""></p><blockquote><p>字符流引言</p></blockquote><p>字节流以字节为单位适用于文件 ( 图片，音频，视频等 ) 传输等，而字符流偏向于文本 ( .txt，.md，.xml ) 传输等</p><p>在 GBK 码表中一个字母中占用一字节，中文占用两字节，在 UTF-8 中的中文要三个字节，所以就有了字符流，字符流只需要负责对数据进行操作即可，无需考虑占用几个字节的问题，<strong>字符流可以理解为字节流和码表的结合</strong></p><h3 id="字符输入流">字符输入流</h3><p><code>FileReader</code> 为字符输入流，使用默认的 ( 大多为 UTF-8 ) 码表，用的同样是那几个 read 函数，这里就不细说了</p><blockquote><p>使用字符输入流</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 字符输入流</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileReader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;D:/example/5.txt&quot;</span>);<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> read; (read = fr.read()) != -<span class="hljs-number">1</span>; )<br>            System.out.println((<span class="hljs-type">char</span>) read);<br>        fr.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符输出流">字符输出流</h3><p><code>FileWriter</code> 为字符输出流，使用默认的 ( 大多为 UTF-8 ) 码表，用的同样是那几个 write 函数，这里就不细说了</p><blockquote><p>使用字符输出流</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试字符输出流</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileWriter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;D:/example/6.txt&quot;</span>);<br>        fw.write(<span class="hljs-string">&quot;测试字符输出流：\r\n&quot;</span>);<br>        fw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>续写以及实时输出数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileWriter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;D:/example/6.txt&quot;</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;写入数据：&quot;</span>);<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; flag; )&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.nextLine();<br>            <span class="hljs-keyword">if</span>( !str.equals(<span class="hljs-string">&quot;exit&quot;</span>) )&#123;<br>                fw.write(str+<span class="hljs-string">&quot;\r\n&quot;</span>);<br>                fw.flush();<br>            &#125; <span class="hljs-keyword">else</span> flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>字符输出流的 write 函数是将字符写在了缓冲区中，只有在 close 关流的时候才会将缓冲区的字符写出，想要实现实时写出需要配合 flush 函数强制刷新并写出</li></ul><blockquote><p>缓冲流引言</p></blockquote><p>我们平时经常接触到的 IO 方面的操作，例如文件复制，我们可以用字节输入流读取数据然后用字节输出流进行写出，没有任何问题，但是文件偏大的时候就会有一个效率的概念，这个时候我们就可以使用缓冲流来解决</p><p>缓冲流，也叫做高效流，是针对开始提过的四种类型进行增强的流</p><h3 id="字节缓冲流">字节缓冲流</h3><p>字节输入流对应的缓冲流为：<code>BufferedInputStream(InputStrean in)</code></p><p>字节输出流对应的缓冲流为：<code>BufferedOutputStream(OutputStream out)</code></p><blockquote><p>通过大文件复制来测试字节流与缓冲流</p></blockquote><p>同样都是那几个读入写出以及刷新关流的函数，这里就不介绍了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字节流复制大文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBufferStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// IDEA社区版安装包--大小572M</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/Download/ideaIC-2020.2.1.exe&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/example/ideaIC.exe&quot;</span>);<br>        <span class="hljs-type">byte</span>[] bs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len; (len = fis.read(bs)) != -<span class="hljs-number">1</span>; )<br>            fos.write(bs, <span class="hljs-number">0</span>, len);<br>        <span class="hljs-comment">// 文件复制完成！花费7329ms</span><br>        System.out.println(<span class="hljs-string">&quot;文件复制完成！花费&quot;</span> + <br>                           (System.currentTimeMillis() - l) + <span class="hljs-string">&quot;ms&quot;</span>);<br>        fos.close();<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符流复制大文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBufferStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// IDEA社区版安装包--大小572M</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/Download/ideaIC-2020.2.1.exe&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/example/ideaIC.exe&quot;</span>);<br>        <span class="hljs-comment">// 缓冲流需要字节流作为参数</span><br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br>        <span class="hljs-type">byte</span>[] bs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len; (len = bis.read(bs)) != -<span class="hljs-number">1</span>; )<br>            bos.write(bs, <span class="hljs-number">0</span>, len);<br>        <span class="hljs-comment">// 文件复制完成！花费3327ms</span><br>        System.out.println(<span class="hljs-string">&quot;文件复制完成！花费&quot;</span> + <br>                           (System.currentTimeMillis() - l) + <span class="hljs-string">&quot;ms&quot;</span>);<br>        bos.close();<br>        bis.close();<br>        fos.close();<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符缓冲流">字符缓冲流</h3><p>字符输入流对应的缓冲流为：<code>public BufferedReader(Reader in)</code></p><p>字符输出流对应的缓冲流为：<code>public BufferedWriter(Writer out)</code></p><blockquote><p>文件内容复制练习</p></blockquote><p>相比之前学过的那些，字符缓冲流有着自己专属的函数：</p><table><thead><tr><th>调用者</th><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>BufferedReader</td><td>readLine()</td><td>只读取一行数据，读到最后返回 null</td></tr><tr><td>BufferedWriter</td><td>newLine()</td><td>创建一个换行符，会根据当前系统环境创建符合的换行符</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符缓冲流实现文件内容拷贝</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBufferChar</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 同样，缓冲流需要字符流作为参数</span><br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;D:/Download/34059.txt&quot;</span>);<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;D:/example/桃花源记.txt&quot;</span>);<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">readBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr);<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">writeBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(fw);<br>        <span class="hljs-comment">// 读取一行数据，读到返回给line，读不到返回null</span><br>        <span class="hljs-keyword">for</span> (String line; (line = readBuffer.readLine()) != <span class="hljs-literal">null</span>; ) &#123;<br>            writeBuffer.write(line);<br>            <span class="hljs-comment">/* 在这里创建了两个换行相当于在源文件基础上添加了一个换行，因为</span><br><span class="hljs-comment">            它是按行读的，不存在换行的概念，所以这里我们需要手动换行 */</span><br>            writeBuffer.newLine();<br>            writeBuffer.newLine();<br>        &#125;<br>        writeBuffer.close();<br>        readBuffer.close();<br>        fw.close();<br>        fr.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:/Users/Administrator/Desktop/Markdown/img/JavaSenior-06.jpg" alt=""></p><h3 id="字节字符转换流">字节字符转换流</h3><p>之前说过，我们在使用字节流处理字符的时候，由于一个中文可能对应两个或三个字节，不方便进行操作，所以有了字符流，但是字符流使用的是默认码表 ( 大多是 UTF8 )，也就意味着如果我有 GBK 字符集的文本他就无法处理了，这个时候我们可以通过转换流进行操作</p><p>顾名思义，转换流就是字节流和字符流之间的转换，我们可以在转换的过程中告诉他应该用什么类型的码表，这样一来就可以解决码表的问题了</p><p>转换流分为两种：</p><ul><li>字节转字符：<code>InputStreamReader</code>，将读入内存的字节转换成程序可处理的字符</li><li>字符转字节：<code>OutputStreamWriter</code>，将处理好的字符转换成字节写出</li></ul><blockquote><p>转换流练习</p></blockquote><p>之前我们学习字符流的时候只操作 UTF-8 类型的文本文件进行测试，因为使用其他编码的时候会乱乱码，现在我们来尝试一下其他的编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 转换流练习</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConversionStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 转换流顾名思义，需要我们提供字节流以及对应的码表来转换为字符流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/Download/73369.txt&quot;</span>);<br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis, <span class="hljs-string">&quot;GBK&quot;</span>);<br>        <span class="hljs-comment">// 获取GBK编码的文本转换成unicode类型的文本</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/example/冰灯.txt&quot;</span>);<br>        <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(fos, <span class="hljs-string">&quot;unicode&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> read; (read = isr.read()) != -<span class="hljs-number">1</span>;) &#123;<br>            osw.write((<span class="hljs-type">char</span>) read);<br>        &#125;<br>        osw.close();<br>        fos.close();<br>        isr.close();<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:/Users/Administrator/Desktop/Markdown/img/JavaSenior-07.jpg" alt=""></p><blockquote><p>【扩展】详细的 [ 编码表/字符集 ] 信息–原文地址：<a href="https://www.cnblogs.com/xichji/p/11793464.html#%E5%AD%97%E7%AC%A6%E9%9B%86">https://www.cnblogs.com/xichji/p/11793464.html#字符集</a></p></blockquote><ul><li>ASCII字符集：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li></ul></li><li>ISO-8859-1字符集：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li>GBxxx字符集：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的&quot;全角&quot;字符，而原来在127号以下的那些就叫&quot;半角&quot;字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li>Unicode字符集：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。</li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul></li></ul><h3 id="扩展-Properties">扩展 Properties</h3><p>properties 应该很熟悉了，springboot 的配置文件就是 properties 和 ymal 文件，properties 类严格来说不属于 IO 类，它其实位于 <code>java.util.Properties</code> 包下 继承 <code>Hashtable</code> 的一个键值对的集合类，只不过类中包含了和 IO 相关的操作</p><blockquote><p>简单了解 Properties 集合类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Properties集合类的使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProperties</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建实例</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">// 添加/修改值</span><br>        ps.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;zhang&quot;</span>);<br>        ps.setProperty(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;hanzhe&quot;</span>);<br>        ps.setProperty(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);<br>        <span class="hljs-comment">// 打印测试</span><br>        System.out.println(ps);<br>        <span class="hljs-comment">// 迭代遍历</span><br>        System.out.println(<span class="hljs-string">&quot;user--&quot;</span> + ps.getProperty(<span class="hljs-string">&quot;user&quot;</span>));<br>        <span class="hljs-keyword">for</span> (Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; iterator = ps.entrySet().iterator(); iterator.hasNext();)&#123;<br>            Map.Entry&lt;Object, Object&gt; entyr = iterator.next();<br>            System.out.println(entyr.getKey() + <span class="hljs-string">&quot;：&quot;</span> + entyr.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>配合IO流读取配置文件信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProperties</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建实例</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">// 加载properties配置文件</span><br>        ps.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/example/applitaion.properties&quot;</span>));<br>        System.out.println(ps);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK8新特性</title>
    <link href="/2021/04/13/Java%E7%AC%94%E8%AE%B0/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2021/04/13/Java%E7%AC%94%E8%AE%B0/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1>函数式接口</h1><p>函数式接口是1.8中的新特性，他不属于新语法，更像是一种规范</p><h2 id="面向对象接口复习">面向对象接口复习</h2><p>在这里先回顾一下面向对象的接口，创建接口的关键字为<code>interface</code>，这里创建一个日志接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LogService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>众所周知，Java中的接口是不能直接创建实例的，因为他的抽象方法没有得到实现：</p><p><img src="..//img/JDK8-01.png" alt=""></p><p>当我们想要创建接口实例的时候一般都通过实现类来获取实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LogService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;哈哈哈哈&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以通过实现来创建这个接口的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LogService</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogServiceImpl</span>();<br>        log.info();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对接口中的方法进行实现除了实现类之外，还可以通过匿名内部类的方式来创建接口的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LogService</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogService</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;嘿嘿嘿&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="什么是函数式接口">什么是函数式接口</h2><p><em>当一个接口只有一个抽象方法 ( 接口默认实现不算 ) 的时候这个接口就是函数式接口</em>，上面的<code>LogService</code>就属于函数式接口，还有学习线程时的<code>Runnable</code>接口也属于函数式接口</p><p>函数式接口还有一个注解为<code>@FunctionalInterface</code>，据我了解这个注解可有可无，它主要起到的是检查的作用，当接口中的抽象方法数量大于1的时候就会报错：</p><p><img src="..//img/JDK8-02.png" alt=""></p><h2 id="内置常用函数式接口">内置常用函数式接口</h2><p>Java中内置了一些常用的函数式接口，这里介绍其中的四种，不用刻意去记，用到就明白了</p><table><thead><tr><th>函数式接口</th><th>参数</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>Consumer<T></td><td>T</td><td>void</td><td>对类型为T的实例进行操作</td></tr><tr><td>Supplier<T></td><td>无</td><td>T</td><td>返回类型为T的实例</td></tr><tr><td>Function&lt;T, R&gt;</td><td>T</td><td>R</td><td>通过对T的操作返回R的实例</td></tr><tr><td>Predicate<T></td><td>T</td><td>boolean</td><td>通过对T的操作返回boolean值</td></tr></tbody></table><p>通过巧妙的运用函数式接口可以实现回调函数的功能</p><h1>Lambda表达式</h1><p>Lambda表达式是1.8中的新特性，<em>主要针对函数式接口的匿名内部类实现做了简化</em></p><h2 id="表达式基本语法">表达式基本语法</h2><p>找到上面匿名内部类创建<code>LogService</code>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LogService</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogService</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;嘿嘿嘿&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为创建的实例就是接口本身，所以<code>new</code>的部分就可以省略不写，接口中需要实现的抽象方法只有一个，那么也没有必要指定具体实现的方法名称，简写后如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LogService</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> ()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;哈哈哈哈&quot;</span>);<br>        &#125;;<br>        log.info();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lambda表达式前面的括号<code>( )</code>就代表参数列表，箭头<code>-&gt;</code>后面的代码块就代表着实现的具体方法体，如果<code>info</code>方法中有参数就可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LogService</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> (msg)-&gt;&#123;<br>            System.out.println(msg);<br>        &#125;;<br>        log.info(<span class="hljs-string">&quot;老八秘制小汉堡&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用Lambda表达式创建一个线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// Runnable为函数式接口，所以可以使用Lambda表达式</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;另一条线程&quot;</span>);<br>        &#125;).start();<br>        System.out.println(<span class="hljs-string">&quot;Main主线程&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="表达式的简写">表达式的简写</h2><p>使用Lambda表达式代替匿名内部类的写法非常简洁，但是在满足特定条件的情况下，它还可以更简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在参数列表只有一个参数的情况下，()可以省略不写</span><br><span class="hljs-comment">         * 当代码块中只有一句代码时&#123;&#125;可以省略不写</span><br><span class="hljs-comment">         * 当函数有返回值且代码块中只有一句代码时return可以省略不写</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">LogService</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> msg-&gt;System.out.println(msg);<br>        log.info(<span class="hljs-string">&quot;老八秘制小汉堡&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lambda表达式相比匿名内部类还有一个特点，当使用匿名内部类时会为匿名内部类生成一个class文件，而使用Lambda表达式时就不会额外生成class文件，这个不做重点</p><h1>方法引用</h1><p>方法引用是1.8中的新特性，配合Lambda表达式使用可以让代码更简洁</p><h2 id="方法引用初体验">方法引用初体验</h2><p>方法引用中需要的特殊符号为双冒号<code>::</code>，具体表现为以下形式：</p><table><thead><tr><th>表现形式</th><th>作用</th></tr></thead><tbody><tr><td>对象::实例方法</td><td>通过对象调用实例中的方法</td></tr><tr><td>类::实例方法</td><td>通过类调用实例中的方法</td></tr><tr><td>类::静态方法</td><td>通过类调用实例中的静态方法</td></tr><tr><td>类::new</td><td>创建该类的实例</td></tr></tbody></table><p><em>当Lambda表达式中只有一句函数调用代码，且调用的目标函数的参数列表和Lambda表达式接收的参数列表一致时就可以使用方法引用</em>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 代表的就是上面表格中表现形式的第一行  对象::实例方法</span><br>        <span class="hljs-type">LogService</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> System.out::println;<br>        log.info(<span class="hljs-string">&quot;老八秘制小汉堡&quot;</span>);<br>        <span class="hljs-comment">// forEach同样可以使用方法引用</span><br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        list.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="综合练习">综合练习</h2><p>针对上面的函数式接口，Lambda表达式以及方法引用做练习，代码会有些多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 综合练习</span><br><span class="hljs-comment"> *   函数式接口 + Lambda表达式 + 方法引用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 方法引用  对象::实例方法</span><br>        strToDate(<span class="hljs-string">&quot;2021-2-20 22:08:45&quot;</span>, System.out::println);<br>        <span class="hljs-comment">// 方法引用  类::new</span><br>        System.out.println(dateToStr(Date::<span class="hljs-keyword">new</span>));<br>        <span class="hljs-comment">// 回调函数：取最大值</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> strListToIntList(Arrays.asList(<span class="hljs-string">&quot;135&quot;</span>, <span class="hljs-string">&quot;541&quot;</span>, <span class="hljs-string">&quot;244&quot;</span>), list -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (Integer item : list) &#123;<br>                <span class="hljs-keyword">if</span> (item &gt; maxNumber) &#123;<br>                    maxNumber = item;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> maxNumber;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;最大值为：&quot;</span> + integer);<br>        <span class="hljs-comment">// 实现过滤器功能</span><br>        List&lt;Integer&gt; list = filter(Arrays.asList(<span class="hljs-number">800</span>, <span class="hljs-number">200</span>, <span class="hljs-number">1200</span>, <span class="hljs-number">600</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">2400</span>), item -&gt; item &gt; <span class="hljs-number">1000</span>);<br>        System.out.println(list);<br>    &#125;<br><br>    <span class="hljs-comment">// Consumer：通过时间字符串快速获取Date对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">strToDate</span><span class="hljs-params">(String date, Consumer&lt;Date&gt; consumer)</span> &#123;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">parse</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            parse = sdf.parse(date);<br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;转换失败！&quot;</span>);<br>        &#125;<br>        consumer.accept(parse);<br>    &#125;<br><br>    <span class="hljs-comment">// Supplier：通过Date对象快速获取到时间字符串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">dateToStr</span><span class="hljs-params">(Supplier&lt;Date&gt; supplier)</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> supplier.get();<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        <span class="hljs-keyword">return</span> sdf.format(date);<br>    &#125;<br><br>    <span class="hljs-comment">// Function：将String集合转换为Integer，后续操作交给调用者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">strListToIntList</span><span class="hljs-params">(List&lt;String&gt; list, Function&lt;List&lt;Integer&gt;, Integer&gt; function)</span> &#123;<br>        ArrayList&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext();) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> Integer.valueOf(next);<br>            integerList.add(integer);<br>        &#125;<br>        <span class="hljs-keyword">return</span> function.apply(integerList);<br>    &#125;<br><br>    <span class="hljs-comment">// predicate：返回大于1000的数字</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> &#123;<br>        ArrayList&lt;Integer&gt; target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Integer item : list) &#123;<br>            <span class="hljs-keyword">if</span> (predicate.test(item)) &#123;<br>                target.add(item);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1>流式编程</h1><p>流式编程是1.8中的新特性，基于常用的四种函数式接口以及Lambda表达式对集合类数据进行类似流水线一般的操作</p><p>流式编程分为大概三个步骤：<code>获取流 → 操作流 → 返回操作结果</code></p><h2 id="流的获取方式">流的获取方式</h2><p>这里先了解获取流的常用的两种方式，后面在进行流的操作</p><blockquote><p>集合中获取流</p></blockquote><p>众所周知Java中所有的集合都是<code>Collection</code>下的实现类，在<code>Collection</code>接口中就提供了获取流的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 获取流</span><br>        Stream&lt;Integer&gt; stream1 = list.stream();<br>        <span class="hljs-comment">// 获取流(多线程，大数据量下效率较高)</span><br>        Stream&lt;Integer&gt; stream2 = list.parallelStream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>数组中获取流</p></blockquote><p>针对数组Java中提供了一个<code>Arrays</code>工具类，我们可以将数组转换为集合在获取流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        List&lt;Integer&gt; list = Arrays.asList(arr);<br>        Stream&lt;Integer&gt; stream1 = list.stream();<br>        Stream&lt;Integer&gt; stream2 = list.parallelStream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者直接通过<code>Arrays</code>类获取到流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        Stream&lt;Integer&gt; stream = Arrays.stream(arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>流的获取方式 总结与补充</p></blockquote><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Collection.stream()</td><td>从集合中获取流</td></tr><tr><td>Collection.parallelStream()</td><td>从集合中获取流 ( 多线程 )</td></tr><tr><td>Arrays.stream(T[])</td><td>从数组中获取流</td></tr><tr><td>Stream.of(T… values)</td><td>直接传入多个元素返回一个流</td></tr><tr><td>Stream.generate(Supplier<T> s)</td><td>Lambda返回的每个实例都是流中的一个元素</td></tr><tr><td>Stream iterate(final T seed, final UnaryOperator<T> f)</td><td>Lambda接收参数一个参数，返回一个结果作为元素，每次返回的结果都将作为下一个Lambda的参数 ( 迭代 )</td></tr></tbody></table><h2 id="操作流中的数据">操作流中的数据</h2><h3 id="假数据模拟">假数据模拟</h3><p>知道了如何获取到流之后，就要开始学习操作流了，在练习之间先写一个假的接口来模拟数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口模拟数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;UserEntity&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">()</span> &#123;<br>        ArrayList&lt;UserEntity&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;老八&quot;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">8000</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;郭老师&quot;</span>, <span class="hljs-number">36</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">7000</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;卢本伟&quot;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">18000</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;张春德&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">2800</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;大司马&quot;</span>, <span class="hljs-number">34</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">12000</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;老八&quot;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">8000</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;贾玲&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">21000</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;周淑怡&quot;</span>, <span class="hljs-number">26</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">14800</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;PDD&quot;</span>, <span class="hljs-number">37</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">26300</span>));<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// UserEntity实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> gender;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> salary;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserEntity</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserEntity</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">char</span> gender, <span class="hljs-type">int</span> salary)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>        <span class="hljs-built_in">this</span>.salary = salary;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getGender</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> gender;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGender</span><span class="hljs-params">(<span class="hljs-type">char</span> gender)</span> &#123;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> salary)</span> &#123;<br>        <span class="hljs-built_in">this</span>.salary = salary;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">UserEntity</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> (UserEntity) o;<br>        <span class="hljs-keyword">return</span> getAge() == that.getAge() &amp;&amp;<br>                getGender() == that.getGender() &amp;&amp;<br>                getSalary() == that.getSalary() &amp;&amp;<br>                getName().equals(that.getName());<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(getName(), getAge(), getGender(), getSalary());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;姓名=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, 年龄=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, 性别=&quot;</span> + gender +<br>                <span class="hljs-string">&quot;, 薪水=&quot;</span> + salary +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数式接口复习">函数式接口复习</h3><p>在操作流式编程之前先来复习一下函数式接口，这里以实现集合的过滤器为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        <span class="hljs-comment">// 获取所有女性员工</span><br>        ArrayList&lt;UserEntity&gt; result = filter(list, item -&gt; item.getGender() == <span class="hljs-string">&#x27;女&#x27;</span>);<br>        result.forEach(System.out::println);<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义集合过滤器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;UserEntity&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(List&lt;UserEntity&gt; list, Predicate&lt;UserEntity&gt; predicate)</span> &#123;<br>        <span class="hljs-comment">// 创建一个结果集</span><br>        ArrayList&lt;UserEntity&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 空值校验</span><br>        <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.size()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 遍历传入的集合，根据调用者制定的过滤规则进行判断，符合条件就添加到结果集中</span><br>        <span class="hljs-keyword">for</span> (UserEntity entity : list) &#123;<br>            <span class="hljs-keyword">if</span> (predicate.test(entity)) &#123;<br>                result.add(entity);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就获取到了一个 ArrayList 集合的过滤器</p><h3 id="操作流的方法">操作流的方法</h3><p>流式编程操作流非常类似上面的代码，常用函数如下所示：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>filter()</td><td>循环集合中每个元素进行判断，返回false的元素会被过滤掉</td></tr><tr><td>limit()</td><td>截取方法，传入 int 类型的 n，从第一个元素开始只获取 n 个</td></tr><tr><td>skip()</td><td>跳过方法，传入 long 类型的 n，流将从第 n+1 个元素开始操作</td></tr><tr><td>distinct()</td><td>去重方法，去掉集合中重复的元素，只保留第一个</td></tr><tr><td>sorted()</td><td>排序方法，通过判断返回的 boolean 值作为参考进行排序</td></tr><tr><td>map()</td><td>这个方法比较特殊，后面用到会详细说明</td></tr></tbody></table><p><strong>使用流式编程需要了解他的特点：</strong></p><ol><li>我们通过流式编程操作集合是不会影响集合本身</li><li>流式编程的代码都是延迟执行的，只有在获取结果的时候才会执行</li></ol><blockquote><p>filter 过滤方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取到薪水大于10000的所有用户</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        list.stream()<br>                .filter(item-&gt;item.getSalary()&gt;<span class="hljs-number">10000</span>)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>limit 截取方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 只获取结果中的5条数据(从首个开始截取)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        list.stream()<br>                .limit(<span class="hljs-number">5</span>)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>skip 跳过方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里就跳过了2个元素，从&quot;卢本伟&quot;开始操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        list.stream()<br>                .skip(<span class="hljs-number">2</span>)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>distinct：去重方法</p></blockquote><p>这里需要提一嘴，<strong>使用<code>distinct</code>方法操作的实体类必须复写<code>equals</code>和<code>hashCode</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 去重操作，可以看到两个老八只剩下一个</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        list.stream()<br>                .distinct()<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>sorted ：排序方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过薪水对集合进行排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        list.stream()<br>                <span class="hljs-comment">// 排序需要传入一个Comparator比较器，这里通过Integer直接获取</span><br>                <span class="hljs-comment">// 通过调换item1和item2的顺序实现升序降序的调整</span><br>                .sorted((item1, item2)-&gt;Integer.compare(item1.getSalary(), item2.getSalary()))<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>map：生成新的数据</p></blockquote><p><code>map</code>同之前那几个稍微有些区别，类似<code>filter</code>或者<code>sorted</code>方法都是对集合进行编辑，而<code>map</code>可以将集合改变为一组新的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过map返回每个用户的姓名，将用户集合改变成了用户姓名集合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        list.stream()<br>                .map(UserEntity::getName)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="返回操作结果">返回操作结果</h2><p>返回操作结果是流式编程最后一步，也是最关键的一步，之前说过流式编程操作集合不会影响集合本身，那么想要获取结果就需要进行这最后一步，需要注意的是<em>流式编程只有在返回操作结果的时候才会执行操作代码</em></p><p>之前使用的<code>forEach</code>就属于返回结果的代码，如果只调用了<code>filter</code>方法而没有调用返回结果，那么<code>filter</code>方法是不会执行的，可以使用下面这段代码进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代码正常执行，如果将forEach移除就会发现filter中的打印语句同样没有执行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        list.stream()<br>                .filter(item-&gt;&#123;<br>                    System.out.println(<span class="hljs-string">&quot;过滤代码执行了&quot;</span>);<br>                    <span class="hljs-keyword">return</span> item.getSalary() &gt; <span class="hljs-number">10000</span>;<br>                &#125;).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>常用获取结果的方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>forEach()</td><td>对流中的数据进行遍历</td></tr><tr><td>min()</td><td>传入比较器获取最小值</td></tr><tr><td>max()</td><td>传入比较器获取最大值</td></tr><tr><td>count()</td><td>计算最终结果的数量</td></tr><tr><td>collect()</td><td>将操作结果转换为集合</td></tr></tbody></table><blockquote><p>forEach：循环遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// forEach是最简单的循环遍历，没什么好说的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        list.stream()<br>                .filter(item-&gt;item.getSalary() &gt; <span class="hljs-number">10000</span>)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>min：取最小值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        <span class="hljs-type">UserEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> list.stream()<br>                .filter(item -&gt; item.getSalary() &gt; <span class="hljs-number">10000</span>)<br>                <span class="hljs-comment">// 获取最小值需要传入Comparator比较器，直接从Comparator中取出Int类型比较器</span><br>                .mim(Comparator.comparingInt(UserEntity::getSalary))<br>                <span class="hljs-comment">// 这里并不会直接返回实体类，需要在get一下才能获取到</span><br>                .get();<br>        System.out.println(entity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>max：取最大值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        <span class="hljs-type">UserEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> list.stream()<br>                .filter(item -&gt; item.getSalary() &gt; <span class="hljs-number">10000</span>)<br>                <span class="hljs-comment">// max同min一致</span><br>                .max(Comparator.comparingInt(UserEntity::getSalary))<br>                .get();<br>        System.out.println(entity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>count：对结果进行计数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取月薪大于10000的人数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> list.stream()<br>                .filter(item -&gt; item.getSalary() &gt; <span class="hljs-number">10000</span>)<br>                .count();<br>        System.out.println(count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>collect：返回操作结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        List&lt;UserEntity&gt; collect = list.stream()<br>                .filter(item -&gt; item.getSalary() &gt; <span class="hljs-number">10000</span>)<br>                <span class="hljs-comment">// 直接调用collect方法，然后调用toList将结果转换为List集合</span><br>                .collect(Collectors.toList());<br>        System.out.println(collect);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="流式编程综合练习">流式编程综合练习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 流式编程+链式编程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        List&lt;UserEntity&gt; list = userService.selectList();<br>        List&lt;String&gt; result = list.stream()<br>                <span class="hljs-comment">// 找到所有男性员工</span><br>                .filter(item-&gt;item.getGender()==<span class="hljs-string">&#x27;男&#x27;</span>)<br>                <span class="hljs-comment">// 去除重复数据</span><br>                .distinct()<br>                <span class="hljs-comment">// 按照年龄进行排序</span><br>                .sorted(Comparator.comparingInt(UserEntity::getAge))<br>                <span class="hljs-comment">// 获取他们所有人的名字</span><br>                .map(UserEntity::getName)<br>                <span class="hljs-comment">// 最后转换为List集合</span><br>                .collect(Collectors.toList());<br>        <span class="hljs-comment">// 打印查看效果</span><br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java注解与反射</title>
    <link href="/2021/04/13/Java%E7%AC%94%E8%AE%B0/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <url>/2021/04/13/Java%E7%AC%94%E8%AE%B0/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1>Java注解</h1><p>在 java 中以 <code>@</code> 符号开头标在类上、函数上、属性等等上的就是 java 中的注解 ( Annotation )，他是在 JDK5 引进的技术，我们在初学 java 的时候就接触过注解，只是没有留意过罢了。</p><h2 id="常见的注解">常见的注解</h2><table><thead><tr><th>常见注解</th><th>作用描述</th></tr></thead><tbody><tr><td>@Override</td><td>表示该方法是复写父类/接口的方法</td></tr><tr><td>@Deprecated</td><td>表示该方法为过期方法</td></tr><tr><td>@SuppressWarnings</td><td>忽略代码警告</td></tr><tr><td>@FunctionalInterface</td><td>表示当前接口是函数式接口，JDK8开始支持</td></tr></tbody></table><blockquote><p>代码举例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">// 表示当前接口是函数式接口 JDK8</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Demo1Interfase</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Demo1Interfase</span> &#123;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 表示该方法是复写父类/接口的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;复写Demo1Interfase接口的方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Deprecated</span> <span class="hljs-comment">// 表示该方法为过期方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我已经过期了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(value = &quot;all&quot;)</span> <span class="hljs-comment">// 忽略全部警告</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">good</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 定义变量却没有使用</span><br>        System.out.println(<span class="hljs-string">&quot;good morning&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo1</span> <span class="hljs-variable">demo1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo1</span>();<br>        demo1.print();  <span class="hljs-comment">// 过期方法会有一道横线（IDEA）</span><br>        demo1.func();<br>        <span class="hljs-comment">// 使用lambda表达式来创建函数式接口实例</span><br>        <span class="hljs-type">Demo1Interfase</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span>()-&gt; System.out.println(<span class="hljs-string">&quot;函数式接口&quot;</span>);<br>        d.func();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="元注解介绍">元注解介绍</h2><p>如果说注解是为我们写的类、函数、属性提供的功能，那么 ==元注解就是为注解提供的功能==，他规定了注解的一些使用规则。</p><table><thead><tr><th>元注解名称</th><th>作用描述</th></tr></thead><tbody><tr><td>@Target</td><td>限制注解可以在什么位置使用，例如类，函数，属性等</td></tr><tr><td>@Retention</td><td>限制注解保存级别，例如运行时，编译时或者源码时</td></tr><tr><td>@Document</td><td>如果使用该元注解，可以被 javadoc 此类的工具文档化</td></tr><tr><td>@Inherited</td><td>可以让子类继承父类中的注解</td></tr><tr><td>@Repeatable</td><td>表示当前注解可以在同一个类，接口，函数中多次使用，JDK8 开始支持</td></tr></tbody></table><ul><li><code>@target</code> 的属性值是 <code>ElementType</code> 得枚举类型，用于约束作用范围：<ul><li><code>TYPE</code>： 可以作用在类，接口，注解，枚举类上</li><li><code>FIELD</code>：可以作用在类的属性上</li><li><code>METHOD</code>：可以作用在方法上</li><li><code>CONSTRUCTOR</code>：可以作用在构造方法中</li><li><code>PARAMETER</code>：可以作用在函数的参数列表中</li><li><code>LOCAL_VARIABLE</code>：可以作用在方法内的局部变量中</li><li><code>ANNOTATION_TYPE</code>：可以作用在注解上，<strong>TYPE中已经包含了</strong></li><li><code>PACKAGE</code>：可以作用在包上</li><li><code>TYPE_USE</code>：能标注任何类型上，<strong>JDK8 开始支持</strong></li></ul></li><li><code>@Retention</code> 可以限制注解的保存级别，值为 <code>RetentionPolicy</code> 的枚举类型：<ul><li><code>SOURCE</code>：可以保存在源代码中</li><li><code>CLASS</code>：可以在编译时保存在 class 文件中</li><li><code>RUNTIME</code>：在运行时保存，==一般情况下使用这个就好了==</li></ul></li></ul><h2 id="自定义注解">自定义注解</h2><p>好了，现在我们已经知道什么时注解了，并且知道了用于约束注解的元注解，接下来就来基于这些约束来创建自定义的注解</p><blockquote><p>创建自定义注解</p></blockquote><p>创建自定义注解其实很简单，首先我们先创建一个接口，然后在 <code>interfase</code> 关键字前面加上 <code>@</code> 符号，这样一个注解就创建好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 建议使用RUNTIME</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnno1 &#123; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnno1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br><br>    <span class="hljs-meta">@MyAnno1</span> <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张&quot;</span>;<br><br>    <span class="hljs-meta">@MyAnno1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-meta">@MyAnno1</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;涵哲&quot;</span>;<br>        System.out.println(<span class="hljs-built_in">this</span>.user + name +<span class="hljs-string">&quot;：func1 function run&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo2</span>().func1();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>基于元注解加一些约束</p></blockquote><p>可以看到，上面的注解已经创建成功了，接下来我们让注解只能在函数上生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span> <span class="hljs-comment">// 只在函数中生效</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnno1 &#123; &#125;<br></code></pre></td></tr></table></figure><p><img src="..//img/JavaSenior-01.jpg" alt=""></p><blockquote><p>注解参数</p></blockquote><p>现在我们的注解需要接收一些参数，在注解中添加参数列表也很简单，就像接口中书写方法一样就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnno1 &#123;<br>    String <span class="hljs-title function_">user</span><span class="hljs-params">()</span>;<br>    String[] name();<br>    String <span class="hljs-title function_">gender</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;男&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，在接口中定义参数列表后，使用该注解的时候必须将值填写完整，不然会报错，如果使用了 <code>dufault</code> 设置默认值的话可以不用传值，写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnno1(user = &quot;张&quot;, name = &#123;&quot;涵哲&quot;, &quot;哈哈&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>如果数组 name 只需要一个参数的话，那么花括号也可以省略不写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnno1(user = &quot;张&quot;, name = &quot;涵哲&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>如果注解中只有一个参数的话，建议变量名命名为 value，这样的话在传参的时候可以省略不写，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnno2 &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnno2(&quot;哈哈哈哈&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><blockquote><p>收尾工作</p></blockquote><p>目前来说注解就已经学完了，但是我们现在学的注解都是 “鸡肋”，都是 “空架子”，他光有注解的型但是没用功能，想要让我们的注解含有功能，我们需要依赖于反射技术。</p><h1>Java反射</h1><p>java 的反射机制允许程序在运行过程中获取任何类的完整结构信息 ( 注意，是类的信息，不是实例的信息 )，并可以操作其属性以及方法。</p><p>在 java 中针对反射机制也提供了一个类：<code>Class</code>，可以通过 class 实例进行相关操作</p><h2 id="获取Class实例">获取Class实例</h2><blockquote><p>获取到某个类的 class 实例，有大概四种方法，如下所示</p></blockquote><ol><li>通过实例的 <code>getClass()</code> 函数获取</li><li>通过目标类的 <code>class</code> 属性获取</li><li>通过Class类的静态函数 <code>forName()</code> 获取</li><li>如果是基本类型包装类可以用 <code>TYPE</code> 属性获取</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取class对象的4种方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 创建一个Person实例</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 演示四种方法获取class实例</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> p.getClass();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Person.class;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;site.hanzhe.entity.Person&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> Integer.TYPE;<br>        <span class="hljs-comment">// 打印测试</span><br>        System.out.println(c1);  System.out.println(c2);<br>        System.out.println(c3);  System.out.println(c4);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里需要注意的是，java 中每种类型只有一个 class 实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java中每一个类只有一个class实例，无论通过什么方法获取的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> p.getClass();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Person.class;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;site.hanzhe.entity.Person&quot;</span>);<br>        System.out.println(c1.hashCode());<br>        System.out.println(c2.hashCode());<br>        System.out.println(c3.hashCode());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>java 中几乎所有类型都可以获取到 class 实例对象</p></blockquote><ul><li>类，数组，枚举的 class 实例打印出来是以 class 开头的，且数组后面的 <code>[</code> 根据维度进行变化的</li><li>接口，注解打印的 class 实例打印出来是以 interface 开头的</li><li>void 就是 void</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java中几乎所有类型都可以获取到class实例对象，包括他本身</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span>  <span class="hljs-operator">=</span> Class.class;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span>  <span class="hljs-operator">=</span> Person.class;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span>  <span class="hljs-operator">=</span> Runnable.class;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c4</span>  <span class="hljs-operator">=</span> <span class="hljs-type">int</span>[].class;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c5</span>  <span class="hljs-operator">=</span> <span class="hljs-type">int</span>[][].class;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c6</span>  <span class="hljs-operator">=</span> Deprecated.class;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c7</span>  <span class="hljs-operator">=</span> ElementType.class;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c8</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">void</span>.class;<br>        System.out.println(c1);<br>        System.out.println(c2);<br>        System.out.println(c3);<br>        System.out.println(c4);<br>        System.out.println(c5);<br>        System.out.println(c6);<br>        System.out.println(c7);<br>        System.out.println(c8);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通过Class实例获取相关信息">通过Class实例获取相关信息</h2><p>我们可以通过以上四种方法获取到某个类的 class 实例，获取到 class 实例之后我们可以通过该实例获取到类中所有的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过class实例可以获取到类的任何信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到Person类的class实例</span><br>        Class&lt;?&gt; c1 = Class.forName(<span class="hljs-string">&quot;site.hanzhe.entity.Person&quot;</span>);<br>        <span class="hljs-comment">// 获取属性信息</span><br>        <span class="hljs-keyword">for</span> (Field field : c1.getFields())<br>            System.out.println(<span class="hljs-string">&quot;获取所有属性: &quot;</span> + field);<br>        <span class="hljs-keyword">for</span> (Field field : c1.getDeclaredFields())<br>            System.out.println(<span class="hljs-string">&quot;获取全部属性(含私有): &quot;</span> + field);<br>        System.out.println(<span class="hljs-string">&quot;获取指定属性&quot;</span> + c1.getField(<span class="hljs-string">&quot;name&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;获取指定属性(含私有)&quot;</span> + c1.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;------------------------------------------------------&quot;</span>);<br>        <span class="hljs-comment">// 获取函数信息</span><br>        <span class="hljs-keyword">for</span> (Method method : c1.getMethods())<br>            System.out.println(<span class="hljs-string">&quot;获取所有函数: &quot;</span> + method);<br>        <span class="hljs-keyword">for</span> (Method method : c1.getDeclaredMethods())<br>            System.out.println(<span class="hljs-string">&quot;获取所有函数(含私有): &quot;</span> + method);<br>        System.out.println(<span class="hljs-string">&quot;获取指定函数: &quot;</span> + c1.getMethod(<span class="hljs-string">&quot;getName&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;获取指定函数(带参数): &quot;</span> + <br>                           c1.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class));<br>        System.out.println(<span class="hljs-string">&quot;获取指定函数(含私有): &quot;</span> + c1.getDeclaredMethod(<span class="hljs-string">&quot;show&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;------------------------------------------------------&quot;</span>);<br>        <span class="hljs-comment">// 获取构造器信息</span><br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : c1.getConstructors())<br>            System.out.println(<span class="hljs-string">&quot;获取所有构造器: &quot;</span> + constructor);<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : c1.getDeclaredConstructors())<br>            System.out.println(<span class="hljs-string">&quot;获取所有构造器(含私有): &quot;</span> + constructor);<br>        System.out.println(<span class="hljs-string">&quot;获取指定函数(带参数): &quot;</span> + <br>                           c1.getConstructor(String.class, <span class="hljs-type">int</span>.class));<br>        System.out.println(<span class="hljs-string">&quot;获取指定函数(含私有): &quot;</span> + <br>                           c1.getDeclaredConstructor(<span class="hljs-type">int</span>.class));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>class.get***</code>：获取目标类 ( 包括父类 ) 的 字段/函数</p><p><code>class.getDeclared***</code>：获取目标类 ( 包含私有但不包含父类 ) 的 字段/函数</p><h2 id="动态创建执行">动态创建执行</h2><p>刚刚我们已经可以通过 class 实例获取到所有的函数和属性了，既然可以获取那么就一定可以调用了</p><blockquote><p>通过反射获取类的实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UseInstance</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;site.hanzhe.entity.Person&quot;</span>);<br>        <span class="hljs-comment">// 1. 通过class直接创建person对象，但是这样有个弊端，</span><br>        <span class="hljs-comment">// 只有在目标类提供了 public 的空参构造才可以获取到</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>        System.out.println(o);<br>        System.out.println(<span class="hljs-string">&quot;======================================================&quot;</span>);<br>        <span class="hljs-comment">// 2、先获取到class的构造方法，然后通过构造方法获取到实例对象</span><br>        <span class="hljs-comment">// 这种方法可以获取到任何参数的构造函数</span><br>        <span class="hljs-comment">// -- 获取具有两个String作为参数的构造函数</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <br>              clazz.getDeclaredConstructor(String.class, String.class);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;张&quot;</span>, <span class="hljs-string">&quot;涵哲&quot;</span>);<br>        System.out.println(o1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>invoke：获取到类中的函数并执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UseMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;site.hanzhe.entity.Person&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <br>              clazz.getDeclaredConstructor(String.class, String.class);<br>        <span class="hljs-comment">// 获取到类的实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;张&quot;</span>, <span class="hljs-string">&quot;涵哲&quot;</span>);<br>        <span class="hljs-comment">// 获取到类中的setName函数，需要一个String作为参数</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">setName</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>        <span class="hljs-comment">// 使用obj实例执行setName方法</span><br>        setName.invoke(obj, <span class="hljs-string">&quot;三&quot;</span>);<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>get-set：获取到类中的属性进行操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UseField</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;site.hanzhe.entity.Person&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(String.class, String.class);<br>        <span class="hljs-comment">// 获取到类的实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;张&quot;</span>, <span class="hljs-string">&quot;涵哲&quot;</span>);<br>        <span class="hljs-comment">// 获取类中名称为name的变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">// set修改obj的属性值</span><br>        name.set(obj, <span class="hljs-string">&quot;麻子&quot;</span>);<br>        <span class="hljs-comment">// get获取到obj实例中的属性值</span><br>        System.out.println(name.get(obj));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的代码是没有问题的，但是执行的时候却抛出了异常，我们来看一下异常信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.IllegalAccessException: Class site.hanzhe.reflect.UseField can not access a member of <span class="hljs-keyword">class</span> <span class="hljs-title class_">site</span>.hanzhe.entity.Person with modifiers <span class="hljs-string">&quot;private&quot;</span><br></code></pre></td></tr></table></figure><h2 id="获取访问权限">获取访问权限</h2><p>上面获取变量的时候抛出了 <code>IllegalAccessException</code> 异常，提示我们没有足够的权限操作 <code>private</code> 私有属性，这时我们可以通过 <em>取消权限检查</em> 来暴力获取到属性的权限</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>isAccessible()</td><td>获取到是否拥有访问权限的相关信息，返回一个boolean值</td></tr><tr><td>setAccessible( boolean flag)</td><td>设置访问权限，true 为可访问，false 为不可访问</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UseField</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;site.hanzhe.entity.Person&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <br>              clazz.getDeclaredConstructor(String.class, String.class);<br>        <span class="hljs-comment">// 获取到类的实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;张&quot;</span>, <span class="hljs-string">&quot;涵哲&quot;</span>);<br>        <span class="hljs-comment">// 获取类中名称为name的变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;是否具有权限操作：&quot;</span> + name.isAccessible());  <span class="hljs-comment">// false</span><br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        System.out.println(<span class="hljs-string">&quot;是否具有权限操作：&quot;</span> + name.isAccessible());  <span class="hljs-comment">// true</span><br>        name.set(obj, <span class="hljs-string">&quot;麻子&quot;</span>);<br>        System.out.println(name.get(obj));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>高级扩展</h1><h2 id="Java内存分析">Java内存分析</h2><p>当程序使用某个类的时候会去内存中检查，如果这个类还没有被加载到内存中，则系统会通过以下三个步骤对类进行初始化加载：</p><p><strong>1.【类的加载】</strong> 就是编译好的 .class 文件读入虚拟机</p><p>**2.【类的链接】**类的链接大概可以分为三个流程：</p><ol><li>**验证：**检查 class 是否符合 JVM 规范，检查安全问题防止破坏 JVM</li><li>**准备：**为该类中的 static 修饰的成员变量设置初始值 ( 例如 int 为0，String 为 null 之类的 )</li><li>**解析：**符号引用转换为直接引用，这个…以后在研究</li></ol><p>**3.【初始化】**这里会执行类构造器 <code>&lt;clinit&gt;</code>，他会自动收集类中所有变量的赋值动作和静态代码块融在一起产生的方法，会按照类中的编码的顺序从上到下的流程执行</p><h2 id="类加载器">类加载器</h2><p>上面简单学习了一下关于类加载的过程，知道了类想要使用必须要先加载到内存中，在 java 中类加载器就是负责将类加载到内存中的，java 中的类加载器分为三种：</p><p>**1.【系统类加载器】**系统类加载器是最常用的类加载器，负责加载 classpath 下的类或加载 <code>java.class.path</code> 所指的目录下的 jar 包装入，我们所写的 Person 类，User 类都是通过系统类加载器加载到内存中去的</p><p>**2.【扩展类加载器】**扩展类加载器加载的是 jre 目录下 lib/ext 下的 jar 包或 <code>java.ext.path</code> 目录下的 jar 包</p><p>**3.【引导类加载器】**主要负责加载核心的类，例如 String，Scanner 等等，处于这个状态下 java 是没法工作的，所以这个类加载器使用 C 编写的，也就意味着 java 获取不到这个类加载器</p><blockquote><p>获取类加载器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取类的三中加载器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 获取系统类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader1</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        System.out.println(loader1);<br>        <span class="hljs-comment">// 获取扩展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">extLoader</span> <span class="hljs-operator">=</span> loader1.getParent();<br>        System.out.println(extLoader);<br>        <span class="hljs-comment">// 获取引导类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bootstrapLoader</span> <span class="hljs-operator">=</span> extLoader.getParent();<br>        System.out.println(bootstrapLoader);<br>        System.out.println(<span class="hljs-string">&quot;---------------------------------------&quot;</span>);<br>        <span class="hljs-comment">// 查看自己创建的类是被那个加载器加载的</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;site.hanzhe.examle.Demo4&quot;</span>);<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> c1.getClassLoader();<br>        System.out.println(loader);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好啊</title>
    <link href="/2021/04/13/Java%E7%AC%94%E8%AE%B0/%E4%BD%A0%E5%A5%BD%E5%95%8A/"/>
    <url>/2021/04/13/Java%E7%AC%94%E8%AE%B0/%E4%BD%A0%E5%A5%BD%E5%95%8A/</url>
    
    <content type="html"><![CDATA[<h1>你好啊</h1><p>第一篇问扎根测</p><p><img src="./image-20240802223537135.png" alt="image-20240802223802185"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/2021/04/13/Java%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    <url>/2021/04/13/Java%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1>Java多线程</h1><blockquote><p>进程，线程以及多线程</p></blockquote><p>想学习线程首先要搞懂进程，进程指的就是我们正在运行的某个应用程序，例如 QQ，微信以及自己编写的 java 程序运行起来之后都属于一个进程</p><p>线程是最小的运算调度单位，一个进程要求至少拥有一个线程，在单核处理器的情况下多线程是以交替形式运行的，并不是同时运行，只是切换的速度比较快而已，多核处理器也是同理，每个处理器都可以调用线程，可以实现同时运行</p><p>我们用 java 书写的控制台程序，它本身就是一个进程，mian 函数就是主线程，我们所有的代码都是基于 mian 线程按照顺序往下跑的，有些时候有那种计算量比较大的函数就会很浪费时间，这个时候我们就可以在创建一个线程将这个函数丢给他调用，就不影响主函数的执行时间了，例如发送邮件的时间延迟，我们就可以通过多线程的异步特点来实现</p><blockquote><p>Thread 线程类常用方法</p></blockquote><table><thead><tr><th>类型</th><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>实例</td><td>start();</td><td>激活线程开始运行</td></tr><tr><td>实例</td><td>run();</td><td>线程类必须复写的函数，包含该线程需要完成的逻辑代码等</td></tr><tr><td>实例</td><td>setName(String name)</td><td>修改当前线程名称</td></tr><tr><td>实例</td><td>setPriority(int priority)</td><td>设置线程的优先级</td></tr><tr><td>实例</td><td>setDaemon(boolean on)</td><td>设置守护守护线程 ( true ) 和用户线程 ( fasse )</td></tr><tr><td>实例</td><td>String getName()</td><td>获取当前线程名称</td></tr><tr><td>实例</td><td>int getPriority()</td><td>获取线程的优先级</td></tr><tr><td>实例</td><td>join()</td><td>暂定当前线程，由调用者开始下一次执行</td></tr><tr><td>实例</td><td>isAlive()</td><td>检测线程是否处于活动状态</td></tr><tr><td>——</td><td>————————————</td><td>——————————————————————————</td></tr><tr><td>静态</td><td>yield()</td><td>礼让：停止当前正在运行的线程，调用者插队执行</td></tr><tr><td>静态</td><td>sleep(long time)</td><td>睡眠：当前线程暂停运行，time 毫秒后继续执行</td></tr><tr><td>静态</td><td>boolean holdsLock(Object x)</td><td>当前线程在指定的对象上保持监视锁时反会 true</td></tr><tr><td>静态</td><td>Thread currentThread()</td><td>返回当前正在执行的线程</td></tr></tbody></table><h2 id="线程的创建方式">线程的创建方式</h2><p>线程的创建有很多种，这里简单介绍常用的几种</p><blockquote><p>继承 Thread 类</p></blockquote><p>四部曲：继承 Thread 类 → 复写 run 方法 → 创建当前类对象 ( 多态：Thread 类型 ) → start 启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 多线程第一种实现方式：继承Thread类复写run函数，run函数内就是多线程执行的任务了。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread1</span>().start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;main 执行了&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;次&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;【多线程执行】&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;次&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实现 Runnable 接口</p></blockquote><p>四部曲：实现 Runnable 接口 → 复写 run 方法 → 创建线程类对象 ( 将当前类示例交给他 ) → start 启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;【多线程执行】&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;次&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread2</span>() ).start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;main 执行了&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;次&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码可以使用 Lambda 表达式快速创建线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( ()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;【多线程执行】执行了&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;次&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;main 执行了&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;次&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>继承 Thread 类和实现 Runnable 接口的区别</p></blockquote><p>我们来写一个卖票的小练习来了解一下两种线程创建的区别</p><p><strong>Runnable 接口实现的多线程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最终数据可能会出现些许偏差，之后在讲</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBuyTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyBuyTicket</span> <span class="hljs-variable">mb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBuyTicket</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mb);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mb);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mb);<br>        t1.setName(<span class="hljs-string">&quot;老八&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;卢本伟&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;菜虚鲲&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> ( ticketNum &gt; <span class="hljs-number">0</span> )&#123;<br>            ticketNum--;<br>            <span class="hljs-comment">// currentThread获取当前运行的线程，getName获取线程的名称</span><br>            System.out.println(<span class="hljs-string">&quot;【&quot;</span> + <br>                               Thread.currentThread().getName() + <span class="hljs-string">&quot;】抢到了一张票&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Thread 类实现的多线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBuyTicket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBuyTicket</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBuyTicket</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBuyTicket</span>();<br>        t1.setName(<span class="hljs-string">&quot;老八&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;卢本伟&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;菜虚鲲&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> ( ticketNum &gt; <span class="hljs-number">0</span> )&#123;<br>            ticketNum--;<br>            System.out.println(<span class="hljs-string">&quot;【&quot;</span> + <br>                               Thread.currentThread().getName() + <span class="hljs-string">&quot;】抢到了一张票&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过这个小练习我们可以看出，Thread 每创建一个线程相应的就必须创建一个对象，而 Runnable 可以实现多个线程操作同一个对象，共享对象内的数据，使用多线程的情况下，推荐优先使用 Runnable 接口</p><h2 id="线程的生命周期">线程的生命周期</h2><p>线程从创建到结束共分为大概五个生命周期：</p><ol><li>【新建】：线程被创建出来，也就是 <code>new Thread()</code></li><li>【就绪】：线程已经创建完毕并且启动了，也就是已经调用 <code>start()</code> 方法了，随时等待 CPU 的调度</li><li>【运行】：线程被 CPU 调度，正在执行 run 方法内的逻辑</li><li>【阻塞】：没有执行的资格和执行权利，例如 <code>sleep(long time)</code></li><li>【销毁】：线程任务已经完成，没有再次使用的地方，线程的对象变成垃圾，释放资源。</li></ol><p>正常线程的流程就是【新建】→【就绪】→【运行】→【可能会有阻塞】→【就绪】→【运行】…→【销毁】</p><blockquote><p>线程睡眠</p></blockquote><p>线程睡眠是指暂时让线程停止运行，在约定时间内不接收 CPU 的调度，用法：<code>Thread.sleep(long time)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过线程睡眠实现每秒打印一句话</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; time &lt;= <span class="hljs-number">10</span>; time++ )&#123;<br>            System.out.println( <span class="hljs-string">&quot;本站已不间断运行&quot;</span> + time + <span class="hljs-string">&quot;秒&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程停止失败！&quot;</span>);<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>结束运行</p></blockquote><p>让线程停止运行，JDK 提供了 stop 实例函数进行停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 练习线程停止</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-literal">true</span>; count++ )<br>            System.out.println(<span class="hljs-string">&quot;线程跑了&quot;</span> + count + <span class="hljs-string">&quot;次&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MyThread3</span> <span class="hljs-variable">mt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt);<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        t1.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经测试这样是可以停止线程的，但是官方并不建议我们这么使用，推荐自己定义一个标识在外部控制停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; flag; count++ )<br>            System.out.println(<span class="hljs-string">&quot;线程跑了&quot;</span> + count + <span class="hljs-string">&quot;次&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.flag = <span class="hljs-literal">false</span>;<br>        System.out.println(<span class="hljs-string">&quot;线程停止成功&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MyThread3</span> <span class="hljs-variable">mt3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt3).start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        mt3.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>线程礼让</p></blockquote><p>我们都知道线程是被 CPU 随机调度的，两个线程在一起的时候，如果想让另一个执行的多一点可以使用线程礼让，线程礼让属于阻塞的函数，需要注意的是，礼让仅仅是放弃当此调度，CPU 会重新从两个线程中再选出一个进行调度，选中的可能还是之前的线程，也就是说，线程礼让并不会 100% 成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程礼让</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++ )&#123;<br>            <span class="hljs-comment">// 老八助人为乐选择礼让</span><br>            <span class="hljs-keyword">if</span>( i &gt;= <span class="hljs-number">90</span> &amp;&amp; Thread.currentThread().getName().equals(<span class="hljs-string">&quot;老八&quot;</span>) )&#123;<br>                System.out.println(<span class="hljs-string">&quot;【老八选择礼让】&quot;</span>);<br>                Thread.<span class="hljs-keyword">yield</span>();<br>            &#125;<br>            System.out.println( <span class="hljs-string">&quot;【&quot;</span> + Thread.currentThread().getName() <br>                               + <span class="hljs-string">&quot;】运行了&quot;</span> + i + <span class="hljs-string">&quot;次&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread3</span> <span class="hljs-variable">mt3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt3);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt3);<br>        t1.setName(<span class="hljs-string">&quot;老八&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;菜虚鲲&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>线程等待</p></blockquote><p>正在运行的线程中如果调用了 join 函数就会停止，下一个运行的函数就是 join 的调用者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++ )&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println( <span class="hljs-string">&quot;【&quot;</span> + Thread.currentThread().getName()<br>                               + <span class="hljs-string">&quot;】运行了&quot;</span> + i + <span class="hljs-string">&quot;次&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>());<br>        t1.setName(<span class="hljs-string">&quot;老八&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;菜虚鲲&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">1</span>);<br>            System.out.println( <span class="hljs-string">&quot;【main线程】运行了&quot;</span> + i + <span class="hljs-string">&quot;次&quot;</span>);<br>            <span class="hljs-keyword">if</span> ( i == <span class="hljs-number">500</span> )&#123;<br>                System.out.println(<span class="hljs-string">&quot;main已经跑到500，T来插个队&quot;</span>);<br>                <span class="hljs-comment">// mian函数中调用了join，mian停止运行，调用者t1开始下次执行</span><br>                t1.join();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>线程优先级</p></blockquote><p>当我们创建了多个线程同时启动的时候，他们会被 CPU 随机调度，每次执行的顺序都不同，这里我们可以通过设置优先级来决定执行的先后顺序</p><p><code>setPriority(int priority)</code>：设置线程的优先级，需要 int 类型的值作为优先级参数，默认优先级为 5，取值范围为 1-10，数值越大对应的优先级越高，可以通过 <code>setPriority()</code> 来获取线程优先级，需要注意的是优先级高的线程会在调度时被给予优先，但这不代表启动后就会运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-keyword">public</span> String msg;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread3</span><span class="hljs-params">(String msg)</span> &#123; <span class="hljs-built_in">this</span>.msg = msg; &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.msg);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>(<span class="hljs-string">&quot;我想第1个执行&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>(<span class="hljs-string">&quot;我想第2个执行&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>(<span class="hljs-string">&quot;我想第3个执行&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>(<span class="hljs-string">&quot;我想第4个执行&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>(<span class="hljs-string">&quot;我想第5个执行&quot;</span>);<br>        t1.setPriority(<span class="hljs-number">5</span>);<br>        t2.setPriority(<span class="hljs-number">4</span>);<br>        t3.setPriority(<span class="hljs-number">3</span>);<br>        t4.setPriority(<span class="hljs-number">2</span>);<br>        t5.setPriority(<span class="hljs-number">1</span>);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        t4.start();<br>        t5.start();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>误区：并不是优先级高执行结束后在执行优先级低的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread3</span><span class="hljs-params">(String name)</span> &#123; <span class="hljs-built_in">super</span>(name); &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">1000</span>; count++)<br>            System.out.println(<span class="hljs-string">&quot;【&quot;</span> + <span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;】执行了&quot;</span> + count + <span class="hljs-string">&quot;次&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>(<span class="hljs-string">&quot;老八&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>(<span class="hljs-string">&quot;菜虚鲲&quot;</span>);<br>        t1.setPriority(<span class="hljs-number">6</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>用户线程和守护线程</p></blockquote><p>线程中包含了两种类型，为用户线程和守护线程，用户线程可以在任务未完成的情况下可以无休止的运行，而守护线程则是主线程 ( mian ) 运行结束后关机 JVM 虚拟机时就跟着停止运行了，我们创建的线程没有修改过的话默认都是用户线程，修改线程类型的函数为 <code>setDaemon()</code>，用户线程为 false，守护线程为 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试用户线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++)<br>            System.out.println(<span class="hljs-string">&quot;线程运行了&quot;</span> + i + <span class="hljs-string">&quot;次&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 创建的线程默认就属于用户线程，不需要修改什么东西</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread4</span>();<br>        t1.start();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试守护线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++)<br>            System.out.println(<span class="hljs-string">&quot;线程运行了&quot;</span> + i + <span class="hljs-string">&quot;次&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread4</span>();<br>        <span class="hljs-comment">// 这里将线程设置为守护类型</span><br>        t1.setDaemon(<span class="hljs-literal">true</span>);<br>        t1.start();<br>        <span class="hljs-comment">// 设置了500ms延时防止线程未执行</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>结果：用户线程等待 10w 条数据打印完成才结束程序，而守护线程打印到 4w 多的时候就结束了程序</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular脚手架</title>
    <link href="/2021/03/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Angular%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Angular%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>Angular 脚手架</h1><p>Angular 环境搭建</p><p>安装  angular8 需要 node 版本最低是 <code>10.13</code>，我的 node 是 <code>8.17.0</code>，那么就指定版本安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看版本，低于要求请跟新版本</span><br>node -v<br>npm -v<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装typescript，可跳过</span><br>npm install -g typescript<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 angular</span><br>npm install @angular/cli@7.3.6 -g<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用当前命令查看是否安装成功</span><br>ng v<br></code></pre></td></tr></table></figure><h2 id="创建一个程序">创建一个程序</h2><p>安装完成后创建一个angular 程序，使用 <code>ng new 项目名称</code>，创建项目时有两个步骤需要操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">是否安装Angular的路由组件</span><br>? Would you like to add Angular routing? (y/N)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">选择需要使用的样式表文件</span><br>Which stylesheet format would you like to use? (Use arrow keys)<br></code></pre></td></tr></table></figure><p>项目创建完成后，在控制台输入 <code>ng serve</code> 便可以运行 angular 程序，也可以使用 <code>npm start</code>，效果是一样的，angular 的默认端口号为 4200</p><h2 id="目录结构讲解">目录结构讲解</h2><p>在 angular 生成的目录结构中，有一些是比较重要的，一定要了解：</p><ul><li><code>e2e</code> 前端测试模块</li><li><code>node_modules</code> 类似 java 中的 lib，添加的所有组件都会存放在该文件夹下</li><li><code>src</code> 编写 angular 项目都在当前目录下进行操作<ul><li><code>app</code> 为组件目录，angular 中的所有组件都是放在 app 目录下进行存放的<ul><li><code>app.module.ts</code>  根模块，用来注册组件</li><li><code>app-routing.module.ts</code> 路由组件</li></ul></li><li><code>assets</code> 资源目录，需要引用的图片或字体文件等等可以放在该目录下</li><li><code>environments</code> 环境配置，可以针对各种环境编写不一样的配置文件</li><li><code>browserslist</code> 配置浏览器支持</li><li><code>index.html</code> Angular 依靠组件进行单页面开发，最终会挂在到 index.html 文件中</li><li><code>main.ts</code> 项目的入口文件</li><li><code>polyfills.ts</code> 填充库文件</li><li><code>styles.css</code> 引用全局性质的样式文件 ( 例如 bootstrap 的样式文件 )</li></ul></li></ul><h2 id="组件的创建及使用">组件的创建及使用</h2><p>在 vue 中，组件有三部分组成，分别是 html 部分，js 部分，css 部分，angular 中的组件也是同理，不过 vue 中的三种类型代码在同一个文件中编写，而 angular 的组件是分开编写的</p><blockquote><p>组件内部的html代码及css样式都是单独的文件进行组合而成的</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 引入angular核心功能</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">OnInit</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-comment">// 组合当前组件的html及css代码</span><br><span class="hljs-meta">@Component</span>(&#123;<br>  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;app-login&#x27;</span>, <span class="hljs-comment">// 使用组件的组件名称</span><br>  <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">&#x27;./login.component.html&#x27;</span>,  <span class="hljs-comment">// 引用的html代码</span><br>  <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">&#x27;../app.component.css&#x27;</span>]     <span class="hljs-comment">// 引用的css代码</span><br>&#125;)<br><span class="hljs-comment">// 将对象暴露出去</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OnInit</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;  <span class="hljs-comment">// 构造方法，执行优先级最高</span><br>  <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) &#123;&#125;     <span class="hljs-comment">// 生命周期函数，是OnInit中实现的接口方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>组件创建完成后需要在 <code>app.module.ts</code> 文件中使用 import 引用并在 declarations 中注册：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">LoginComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./login/login.component&#x27;</span>;<br><span class="hljs-meta">@NgModule</span>(&#123;<br>  省略...<br>  <span class="hljs-attr">declarations</span>: [<br>    <span class="hljs-title class_">LoginComponent</span><br>  ],<br>  省略...<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> &#123; &#125;<br></code></pre></td></tr></table></figure><hr />创建组件其实可以不需要引用多个文件，完全可以一个文件来书写组件，只不过有些麻烦：<blockquote><p>将外部的代码集成到该文件中，降低了可读性且不方便，不推荐使用</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">OnInit</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-meta">@Component</span>(&#123;<br>  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;app-login&#x27;</span>,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h1&gt;这里写html代码&lt;/h1&gt;`</span>,<br>  <span class="hljs-attr">style</span>: <span class="hljs-string">`这里写css代码`</span><br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OnInit</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr />这是最方便的创建组件的方法，在当前项目目录下，使用命令 `ng g component 组件名` 即可在 app 目录下创建一个以组件名命名的文件夹，里面的文件关联及 `app.module.ts` 的注册都自动配置成功，直接去使用即可！~<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在app目录下创建一个user组件</span><br>ng g component user<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在user组件下创建一个login组件</span><br>ng g component user/login<br></code></pre></td></tr></table></figure><h2 id="app-module-ts-配置文件">app.module.ts 配置文件</h2><p>正常在我们创建组件的时候会在该配置文件下进行注册以便使用，但是 <code>app.module.ts</code> 的功能远不止注册组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 引入浏览器的解析模块，用来解析组件</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/platform-browser&#x27;</span>;<br><span class="hljs-comment">// angular的核心组件，必须引用</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NgModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><br><span class="hljs-comment">// 注册组件之前需要将被注册的组件引用到当前文件中</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AppRoutingModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app-routing.module&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AppComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.component&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">LoginComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./login/login.component&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RegisterComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./register/register.component&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">GetComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./get/get.component&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HttpClientModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/common/http&#x27;</span>;<br><br><span class="hljs-meta">@NgModule</span>(&#123;<br>  <span class="hljs-comment">// 注册组件-自己创建的组件</span><br>  <span class="hljs-attr">declarations</span>: [<br>    <span class="hljs-title class_">AppComponent</span>,<br>    <span class="hljs-title class_">LoginComponent</span>,<br>    <span class="hljs-title class_">RegisterComponent</span>,<br>    <span class="hljs-title class_">GetComponent</span>,<br>  ],<br>  <span class="hljs-comment">// 注册模块-Angular提供的功能模块，默认是不使用的，需要引用后在这里注册</span><br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">BrowserModule</span>,<br>    <span class="hljs-title class_">AppRoutingModule</span>,<br>    <span class="hljs-title class_">HttpClientModule</span><br>  ],<br>  <span class="hljs-comment">// 配置项目中需要开启的服务</span><br>  <span class="hljs-attr">providers</span>: [],<br>  <span class="hljs-attr">bootstrap</span>: [<span class="hljs-title class_">AppComponent</span>]<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h2 id="组件模板的书写">组件模板的书写</h2><p>angular 的组件主要是一个 typescript 组件，在组件内可以定义变量及函数，定义变量时需要携带修饰符及类型：</p><p>修饰符：【public】【private】【protected】</p><p>类型分为以下几种：</p><ul><li>布尔类型 boolean</li><li>数字类型 number</li><li>字符串类型 string</li><li>对象类型 object</li><li>数组类型 array</li><li>元祖类型 tuple</li><li>枚举类型： enum</li><li>任意类型 any</li><li>空类型 null undefined void never</li></ul><p>定义一个标准的变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginComponent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;张涵哲&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-attr">list</span>:<span class="hljs-built_in">any</span>[] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据绑定指令">数据绑定指令</h3><p>一般在 html 中会使用一些在 ts 中定义好的变量，可以直接使用 <code>&#123;&#123;&#125;&#125;</code> 来进行调用，针对标签中的属性也可以使用花括号传值，但是除开这个方法之外还可以使用 <strong>[ 属性 ] 数据绑定</strong> 来实现目标效果</p><blockquote><p>例如有一个变量为 msg=‘我是一个title’</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 数据调用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 绑定数据到属性中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">title</span>]=<span class="hljs-string">&quot;msg&quot;</span> &gt;</span>这是一个div标签<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 将数据解析为html标记语言 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">innerHTML</span>]=<span class="hljs-string">&quot;msg&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="流程控制指令">流程控制指令</h3><p><strong>流程控制指令分为循环和判断</strong></p><blockquote><p>*ngFor 循环指令</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let item of list; let key=index&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>*ngIf 判断指令</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let item of list; let key=index&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">&quot;key%2==1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">&quot;key%2==0&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue;&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>ngSwitch 分支语句</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngSwitch</span>]=<span class="hljs-string">&quot;state&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;&#x27;1&#x27;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blueviolet&quot;</span>&gt;</span>星期1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blueviolet&quot;</span>&gt;</span>星期2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;&#x27;3&#x27;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blueviolet&quot;</span>&gt;</span>星期3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;&#x27;4&#x27;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blueviolet&quot;</span>&gt;</span>星期4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;&#x27;5&#x27;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blueviolet&quot;</span>&gt;</span>星期5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchDefault</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blueviolet&quot;</span>&gt;</span>今天放假！<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="动态改变样式">动态改变样式</h3><p><strong>动态操作class</strong></p><blockquote><p>这里定义了 boolean 类型的 flag，可以通过操作 flag 属性动态修改 class 属性，class 属性需要单引号</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngClass</span>]=<span class="hljs-string">&quot;&#123;&#x27;color-red&#x27;: flag, &#x27;color-blue&#x27;: !flag&#125;&quot;</span>&gt;</span>这是一个div标签<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>动态操作 style</strong></p><blockquote><p>和 class 类似，在 ngStyle 中可以直接为属性赋值，也可以使用变量赋值实现动态效果</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">&quot;&#123;&#x27;color&#x27;: &#x27;red&#x27;, &#x27;background-color&#x27;: cor&#125;&quot;</span>&gt;</span>这是一个div标签<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Angular-管道">Angular 管道</h3><p>管道，就相当于 vue 中的过滤器，当使用管道后原本输出的内容会被管道进行处理，显示的是处理后的内容</p><p><strong>常用管道：</strong></p><table><thead><tr><th>管道</th><th>作用</th></tr></thead><tbody><tr><td>uppercase</td><td>将所有字母转换为大写字母</td></tr><tr><td>lowercase</td><td>将所有字母转换为小写字母</td></tr><tr><td>date:‘yyyy-MM-dd HH:mm:ss’</td><td>将data时间进行格式化，后面跟上格式化的样式</td></tr><tr><td>number:‘1.2-4’</td><td>小数格式化，最小有一个整数位，小数位至少2个，最多4个</td></tr><tr><td>json</td><td>将 object 对象解析为 json 字符串</td></tr></tbody></table><p><strong>使用管道：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>管道处理打印的date对象：&#123;&#123;time | date:&#x27;yyyy-MM-dd HH:mm:ss&#x27;&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>自定义管道：</strong></p><h3 id="表单事件">表单事件</h3><p>在使用表单事件之前需要先掌握普通事件如何调用：</p><blockquote><p>==使用括号 ( ) 将事件名称括起来==，然后在指定事件触发后执行的代码即可</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">func1</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是点击事件&quot;</span>)   &#125;<br><span class="hljs-title function_">func2</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是滑过事件&quot;</span>)   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;func1()&quot;</span>&gt;</span>点击事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">mousemove</span>)=<span class="hljs-string">&quot;func2()&quot;</span>&gt;</span>滑过事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>表单事件</strong></p><blockquote><p>在键盘按下时传入了一个 $event 参数，通过这个参数可以获取到表单相关的信息</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">down</span>(<span class="hljs-params"> e </span>)&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( e );  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">监听键盘按下事件<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> (<span class="hljs-attr">keydown</span>)=<span class="hljs-string">&quot;down($event)&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="双向数据绑定">双向数据绑定</h3><p><font color="red">在 angular 中想要使用双向绑定，必须要在 <code>app.module.ts</code> 中引用模块：</font></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">FormsModule</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@angular/forms&quot;</span>;<br><span class="hljs-attr">imports</span>: [ <span class="hljs-title class_">FormsModule</span> ]<br></code></pre></td></tr></table></figure><p>在引入了双向绑定的模块之后就可以进行使用了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Angular 的双向绑定<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>单向绑定测试 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">&quot;msg1&quot;</span>&gt;</span> &#123;&#123;msg1&#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>双向绑定测试 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;msg2&quot;</span>&gt;</span> &#123;&#123;msg2&#125;&#125;<br></code></pre></td></tr></table></figure><hr />**表单双向绑定实例：**<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">public</span> <span class="hljs-attr">model</span>:<span class="hljs-built_in">object</span> = &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">likes</span>: [<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>],<br>    <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">birthday</span>: <span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>表单&amp;angular交互联系<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    姓名:<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;model.username&quot;</span>&gt;</span> <br>    &#123;&#123;model.username&#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    性别：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;model.sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sex1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;sex1&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;model.sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sex2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;sex2&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> --- &#123;&#123;model.sex&#125;&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    爱好：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;model.likes[0]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;运动&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;like1&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;like1&quot;</span>&gt;</span>运动<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;model.likes[1]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;游戏&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;like2&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;like2&quot;</span>&gt;</span>游戏<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;model.likes[2]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;编程&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;like3&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;like3&quot;</span>&gt;</span>编程<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    &#123;&#123;model.likes | json&#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    住址：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;model.address&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;沈阳&quot;</span>&gt;</span>沈阳<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;青岛&quot;</span>&gt;</span>青岛<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;大连&quot;</span>&gt;</span>大连<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    --- &#123;&#123;model.address&#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    生日：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;model.birthday&quot;</span> &gt;</span><br>    -- &#123;&#123;model.birthday&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="red">双向绑定在 form 表单内无效</font></p><h3 id="静态资源调用问题">静态资源调用问题</h3><p>在 angular 的组件模板中调用静态资源文件，例如图片字体等等，首先要知道静态资源存放目录是 <code>assets</code> 目录下，引用也无需使用 <code>./ 或者 ../</code> 之类，直接访问该目录即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 无视目录，直接使用assetc即可访问目标文件夹  --&gt;</span><br>&lt;/img src=&quot;assets/google.jpg&quot; title=&quot;这是一张图片&quot;&gt;<br></code></pre></td></tr></table></figure><h2 id="服务的创建和使用">服务的创建和使用</h2><p>在 angular 有服务这样一个概念，可以在服务中存放属性或方法，可以在各个组件对其进行调用，我姑且把它理解为 angular 版的 vuex</p><p>服务同组件一样，需要先创建他，创建服务的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ng g service 服务名<br></code></pre></td></tr></table></figure><p>这样在 app 目录下就会生成两个服务文件，创建完成后还不能立即使用，需要到 <code>app.module.ts</code> 文件中 import 引用并在 providers 处注册服务，这样才可以使用该服务</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">GetService</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./service/get/get.service&#x27;</span>;<br><span class="hljs-attr">providers</span>: [<span class="hljs-title class_">GetService</span>],<br></code></pre></td></tr></table></figure><p><strong>使用服务</strong></p><p>在组件中使用服务，同样也要使用 import 引用该服务，然后可以直接 new 将服务实例化使用</p><blockquote><p>实例化要再和 import 同级位置进行实例化</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Component</span>, <span class="hljs-title class_">OnInit</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">GetService</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../service/get/get.service&quot;</span>;<br><br><span class="hljs-keyword">var</span> get = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetService</span>();<br><br><span class="hljs-meta">@Component</span>(&#123;<br>    <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;app-model02&#x27;</span>,<br>    <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">&#x27;./model02.component.html&#x27;</span>,<br>    <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">&#x27;./model02.component.css&#x27;</span>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Model02Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(get.<span class="hljs-property">msg</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就通过实例化对象的方法使用了服务，但是 angular 并不推荐这么使用，所以正常应该这样：</p><blockquote><p>在方法内使用 get 属性来代替 GetService 实例化的过程</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> get:GetService</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(get.<span class="hljs-property">msg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在构造方法中声明的属性，在当前实例中任何位置都可以调用</li><li>get 服务可以在多个组件同时生效，在第一个组件对服务内的属性进行修改，那么第二个组件会看到第一个组件修改后的参数，可以当成 vue 中的状态管理进行使用</li></ul><p><strong>服务的调用问题：</strong></p><ul><li><p>组件于服务之间是单向通信，也就是组件可以调用服务的方法及属性，但是服务不能调用组件</p></li><li><p>但是服务和服务之间是双向通信，也就是服务于服务之间可以互相调用</p></li></ul><h2 id="DOM操作及生命周期函数">DOM操作及生命周期函数</h2><h3 id="OnInit-函数">OnInit 函数</h3><p>在使用命令创建一个 angular 组件的时候，ts 文件中的 class 会默认的实现一个接口：<code>OnInit</code>，且复写了其中的ngOnInit 做为生命周期方法</p><blockquote><p>ngOninit 方法的执行时机是在原生 dom 加载完毕后：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>这是第一个p标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span> [<span class="hljs-attr">innerText</span>]=<span class="hljs-string">&quot;str&quot;</span>&gt;</span>这是第二个p标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">public</span> <span class="hljs-attr">str</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;我是angular中的值&quot;</span>;<br><span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 使用dom操作p1</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">p1</span>:<span class="hljs-built_in">any</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p1&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">innerText</span>)<br><br>    <span class="hljs-comment">// 使用dom操作p2</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">p2</span>:<span class="hljs-built_in">any</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p2&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">innerText</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，在 ngOnInit 方法中获取的两个 dom 节点的内容，都是原生的内容，使用 angular 对 p2 进行的赋值并没有被 dom 获取到，所以一般不建议在 ngOnInit 方法中操作 dom</p><h3 id="ngAfterViewInit-函数">ngAfterViewInit 函数</h3><p>那么除开 ngOnInit 函数之外，还有一个生命周期函数就是 <code>ngAfterViewInit</code>，他并不是从接口中复写而来的，而是当前 class 默认自带的生命周期函数</p><blockquote><p>ngAfterViewInit 执行时机是当前dom加载完毕且于angular结合后</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>这是第一个p标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span> [<span class="hljs-attr">innerText</span>]=<span class="hljs-string">&quot;str&quot;</span>&gt;</span>这是第二个p标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">public</span> <span class="hljs-attr">str</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;我是angular中的值&quot;</span>;<br>ngAfterViewInit () &#123;<br>    <span class="hljs-comment">// 使用dom操作p1</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">p1</span>:<span class="hljs-built_in">any</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p1&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">innerText</span>)<br><br>    <span class="hljs-comment">// 使用dom操作p2</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">p2</span>:<span class="hljs-built_in">any</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p2&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">innerText</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，如果在当前生命周期函数下操作 dom，获取到的 p2 的值是经过 angular 处理过的值，所以如果在程序中要对 dom 进行操作的话建议在当前方法下进行操作</p><h3 id="ViewChild-操作-DOM">ViewChild 操作 DOM</h3><p>在 angular 中操作 dom，除开使用原生的 js 代码之外，还可以使用 angular 提供的 <code>ViewChild</code> 进行操作</p><blockquote><p>angular 的组件中默认时不支持使用 ViewChild 的，需要先添加他的引用才可以使用，添加引用的方法是：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Component</span>, <span class="hljs-title class_">OnInit</span>, <span class="hljs-title class_">ViewChild</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>引用添加完成后，对要获取 dom 对象的标签使用 # 进行标识</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> #<span class="hljs-attr">ps</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span> [<span class="hljs-attr">innerText</span>]=<span class="hljs-string">&quot;str&quot;</span>&gt;</span>我是一个p标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>而后在组件中获取当前节点的 dom 对象，获取到之后就可以对他进行正常的 dom 操作了</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">public</span> <span class="hljs-attr">flag</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;我是angular中的值&quot;</span>;<br><span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">&quot;ps&quot;</span>) <span class="hljs-attr">ps</span>:<span class="hljs-built_in">any</span>;<br><br><span class="hljs-title function_">ngAfterViewInit</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">ps</span>.<span class="hljs-property">nativeElement</span>.<span class="hljs-property">innerText</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>ViewChild 将 dom 对象封装在了自身的 nativeElement 属性中，操作 dom 需要先调用他</li><li><font color="red">无论是原生 js 操作 dom 还是 ViewChild 操作dom，都要在 ngAfterViewInit 函数中，原因是一样的</font></li></ol><h3 id="所有生命周期函数">所有生命周期函数</h3><p>上面只介绍了 ngOnInit 和 ngAfterViewInit 两个生命周期函数，也是最为常用的生命周期函数，在 Angular 中的生命周期函数远不止这两个，这里就要详细演示一下所有的生命周期函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LifeComponent</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-attr">msg</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;组件中的msg&quot;</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1-构造函数---除了使用简单的值对局部变量进行初始化之外，什么都不应该做&#x27;</span>)<br>    &#125;<br>    <br>    <span class="hljs-title function_">ngOnChanges</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2-ngOnChages--- 当父组件向子组件传值 或被传入到子组件的值发生变化时执行&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3-ngOnInit--- 一般将初始化时的Ajax写在这里&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">ngDoCheck</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4-ngDoCheck--- 检测作用，当前实例中的某个属性被改变时执行&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">ngAfterContentInit</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5-ngAfterContentInit--- 当把内容投影进组件之后调用&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">ngAfterContentChecked</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;6-ngAfterContentChecked执行了--- 每次完成被投影组件内容的变更检测之后调用&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">ngAfterViewInit</span>(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;7-ngAfterViewInit---- 组件，视图及子视图加载完毕执行，一般在这里操作DOM&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">ngAfterViewChecked</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;8-ngAfterViewChecked---- 每次做完组件视图和子视图的变更检测之后调用&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">ngOnDestroy</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;9-ngOnDestroy执行了····&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//自定义方法</span><br>    <span class="hljs-title function_">changeMsg</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span> = <span class="hljs-string">&quot;数据改变了&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Angular-组件通信">Angular 组件通信</h2><p>组件通信，因为 angular 属于单页面开发，页面中的每个功能都是使用组件进行显示的，但是每个组件之间的数据不同，有时候又难免需要其他组件传来数据来执行本组件的逻辑，这个时候就需要用到组件通信了</p><p>所谓的父子组件，假如当前程序中有三个组件，分别是 Home，Header，Main，负责显示的组件是 Home，在Home 组件中分别引用并显示了 Header，Main，这时 Home 就是 Header，Main 的父组件， Header，Main 也是 Home 的子组件</p><h3 id="父组件获取子组件数据">父组件获取子组件数据</h3><p>在父组件中获取子组件中的属性或者函数，需要用到一个之前就学习过的知识：<code>ViewChild</code> 模块，他可以在父组件中主动的去获取子组件中的属性及函数</p><blockquote><p>获取子组件中的属性及函数</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件在引用子组件的时候，为他添加一个ViewChild标识 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">app-header</span> #<span class="hljs-attr">son</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-header</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// son代表的就是子组件的实例，然后在父组件中就可以使用子组件中的内容了</span><br><span class="hljs-comment">// 其中的good，logA都是在子组件中事先定义好的属性及方法</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;父组件的参数&quot;</span>;<br><span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">&quot;son&quot;</span>) <span class="hljs-attr">son</span>:<span class="hljs-built_in">any</span>;<br><span class="hljs-title function_">getGood</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">son</span>.<span class="hljs-property">good</span>)<br>&#125;<br><span class="hljs-title function_">getLogA</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">son</span>.<span class="hljs-title function_">logA</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子组件获取父组件中的数据">子组件获取父组件中的数据</h3><p>子组件获取父组件需要在子组件中引用一个 <code>Input</code> 模块，这样就可以接受父组件传来的参数了</p><blockquote><p>获取父组件中的属性及函数</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在父组件中使用单向绑定将自己传入给子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">app-header</span> [<span class="hljs-attr">super</span>]=<span class="hljs-string">&quot;this&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-header</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在子组件中使用Input获取到父组件传入的对象并使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-attr">title</span>:<span class="hljs-built_in">string</span>=<span class="hljs-string">&quot;undefined&quot;</span>;<br><span class="hljs-meta">@Input</span>() <span class="hljs-attr">super</span>:<span class="hljs-built_in">any</span>;<br><br><span class="hljs-comment">// 获取父组件信息的方法</span><br><span class="hljs-title function_">getTitle</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">super</span>.<span class="hljs-property">title</span>;<br>&#125;<br><span class="hljs-title function_">getLogB</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">super</span>.<span class="hljs-title function_">logB</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件的HTML代码 --&gt;</span><br>我是Header组件: &#123;&#123;title&#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;getTitle()&quot;</span>&gt;</span>获取父组件的title属性<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;getLogB()&quot;</span>&gt;</span>获取父组件的logB函数<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="HTTP-服务">HTTP 服务</h2><p>在 angular 中内置了 HTTP 服务可以发起请求，想要使用它必须要在 <code>app.module.ts</code> 文件中引用并注册</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HttpClientModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/common/http&#x27;</span>;<br><span class="hljs-attr">imports</span>: [ ... <span class="hljs-title class_">HttpClientModule</span> ... ],<br></code></pre></td></tr></table></figure><blockquote><p>发起请求示例：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">HttpClient</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@angular/common/http&quot;</span>;<br><br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> http: HttpClient</span>) &#123; &#125;<br><span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRequest</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">postRequest</span>();<br>&#125;<br><span class="hljs-comment">// 发起Get请求</span><br><span class="hljs-title function_">getRequest</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> url = <span class="hljs-string">&quot;请求的目标地址&quot;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">http</span>.<span class="hljs-title function_">get</span>(url).<span class="hljs-title function_">toPromise</span>().<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    &#125;).<span class="hljs-title function_">catch</span>( <span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[Error] 请求失败！ 异常信息如下：&quot;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;)<br>&#125;<br><span class="hljs-comment">// 发起Post请求</span><br><span class="hljs-title function_">postRequest</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> url = <span class="hljs-string">&quot;请求的目标地址&quot;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">http</span>.<span class="hljs-title function_">post</span>(url).<span class="hljs-title function_">toPromise</span>().<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    &#125;).<span class="hljs-title function_">catch</span>( <span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[Error] 请求失败！ 异常信息如下：&quot;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>封装HTTP服务</p></blockquote><p>关于 HTTP 请求这里就不详细记笔记了，封装一个通用服务来简化传值，cookie 等设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 封装好的HTTP服务</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpService</span> &#123;<br><br>    public <span class="hljs-attr">baseUrl</span>: string = <span class="hljs-string">&quot;http://localhost:8080&quot;</span>;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private http: HttpClient</span>) &#123; &#125;<br><br> <span class="hljs-comment">// path为请求的路径，和baseUrl拼接后形成完成的请求URL</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">path: string, data: any = <span class="hljs-literal">null</span></span>)&#123;<br>        <span class="hljs-comment">// withCredentials：允许携带Cookie，保持sessionid一致</span><br>        <span class="hljs-comment">// params：请求时需要携带的参数</span><br>        <span class="hljs-keyword">let</span> param = &#123;<span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">params</span>: data&#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">http</span>.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">baseUrl</span> + path, param).<span class="hljs-title function_">toPromise</span>();<br>    &#125;<br><br>    <span class="hljs-title function_">post</span>(<span class="hljs-params">path: string, data: any = <span class="hljs-literal">null</span></span>)&#123;<br>        <span class="hljs-comment">// withCredentials：允许携带Cookie，保持sessionid一致</span><br>        <span class="hljs-comment">// params：请求时需要携带的参数</span><br>        <span class="hljs-keyword">let</span> param = &#123;<span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">params</span>: data&#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">http</span>.<span class="hljs-title function_">post</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">baseUrl</span> + path, <span class="hljs-literal">null</span>, param).<span class="hljs-title function_">toPromise</span>();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用方法：</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomePage</span> &#123;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private http: HttpService</span>) &#123; &#125;<br><br>    <span class="hljs-title function_">login</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">http</span>.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/login&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res&quot;</span>, res);<br>        &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err&quot;</span>, err);<br>        &#125;)<br>    &#125;<br>    <br>    <span class="hljs-title function_">logout</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">http</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/logout&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res&quot;</span>, res);<br>        &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err&quot;</span>, err);<br>        &#125;)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Angular-的路由">Angular 的路由</h2>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery学习笔记</title>
    <link href="/2021/03/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/jQuery%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/jQuery%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>jQuery学习笔记</h1><p>jQuery 是一个快速、简洁的 JS 框架，它封装 JS 中常用的功能代码，提供一种简便使用方式，优化HTML文档操作、事件处理、动画设计和 AJAX 请求</p><p>想要在页面上使用 jQuery 需要添加引用：<code>https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js</code></p><blockquote><p>jQuery初体验</p></blockquote><ol><li>页面加载完成后执行 JS</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 我们在页面上想要在页面加载完成后执行 JS 代码，需要使用window的onload</span></span><br><span class="language-javascript">    <span class="hljs-comment">/* window.onload = function()&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">        console.log(123);</span></span><br><span class="hljs-comment"><span class="language-javascript">    &#125; */</span></span><br><span class="language-javascript">    <span class="hljs-comment">// jQuery中也可以实现相同的功能：</span></span><br><span class="language-javascript">    <span class="hljs-title function_">jQuery</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>jQuery 的简化写法</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 我们每次使用jQuery的时候都需要写一长串的单词，让人不爽</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 这里jQuery为我们提供了简化的写法，就是美元符号：$</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 使用 $ 符可以代替jQuery这个单词进行使用，以后也会使用这个符号进行练习</span></span><br><span class="language-javascript">    $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>替换 $ 符号</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 在之后，我们可能会引入多个JS文件，$符可能会与其他JS文件产生冲突</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 这里我们可以选择重新定义一个变量JQ来代替jQuery这个单词，首先我们先来看看jQuery是什么</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jQuery);</span><br><span class="language-javascript">    <span class="hljs-comment">// 通过打印得知jQuery变量其实是一个全局的函数，想要更名的话只需要在定义一个变量赋值这个引用即可</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">JQ</span> = jQuery;</span><br><span class="language-javascript">    <span class="hljs-comment">// 通过新的变量来代替jQuery进行操作</span></span><br><span class="language-javascript">    <span class="hljs-title function_">JQ</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 上面那种方法经测试可行，但是网上更流行的是种写法，同样也是可行的</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">JQ</span> = jQuery.<span class="hljs-title function_">noConflict</span>();</span><br><span class="language-javascript">    <span class="hljs-title function_">JQ</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="选择器练习">选择器练习</h2><blockquote><p>认识选择器</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>P标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 上面有一个p标签id为p1，我们想要获取到他的dom对象需要使用如下方法：</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> p1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p1&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是这样写起来代码太长了，jQuery 为我们提供了强大的选择器，我们可以用过选择器来获取 DOM 节点</p><h3 id="基本选择器">基本选择器</h3><blockquote><p>三大基本选择器</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>p标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> div标签 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sp&quot;</span>&gt;</span>span标签1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sp&quot;</span>&gt;</span>span标签2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> p1 = $(<span class="hljs-string">&quot;#p1&quot;</span>);     <span class="hljs-comment">// ID选择器</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> div = $(<span class="hljs-string">&quot;div&quot;</span>);    <span class="hljs-comment">// 标签选择器</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> span = $(<span class="hljs-string">&quot;.sp&quot;</span>);   <span class="hljs-comment">// class选择器</span></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>编程式选择器</p></blockquote><p>这里只简单写了几个常用的选择器，之后有用到的随时百度查</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p4&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 这里要频繁使用p4这个jQuery对象，这里就暂时存起来了</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> p = $(<span class="hljs-string">&quot;#p4&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> p1 = p.<span class="hljs-title function_">next</span>(<span class="hljs-string">&quot;p&quot;</span>);     <span class="hljs-comment">// 获取下一个同级的p</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> p2 = p.<span class="hljs-title function_">nextAll</span>(<span class="hljs-string">&quot;p&quot;</span>);  <span class="hljs-comment">// 获取后面所有同级的p</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> p3 = p.<span class="hljs-title function_">prev</span>(<span class="hljs-string">&quot;p&quot;</span>);     <span class="hljs-comment">// 获取上一个同级的p</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> p4 = p.<span class="hljs-title function_">prevAll</span>(<span class="hljs-string">&quot;p&quot;</span>);  <span class="hljs-comment">// 获取所有同级的p</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> p5 = p.<span class="hljs-title function_">siblings</span>(<span class="hljs-string">&quot;p&quot;</span>); <span class="hljs-comment">// 获取同级所有的p</span></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="层级选择器">层级选择器</h3><p>jQuery 的选择器也支持层级关系，我们可以通过层级关系获取指定的目标元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span><br>        div3<br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>            span2<br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span2-1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span2-2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> ojb1 = $(<span class="hljs-string">&quot;#div&gt;span&quot;</span>);  <span class="hljs-comment">// 子选择器</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> ojb2 = $(<span class="hljs-string">&quot;#div span&quot;</span>);  <span class="hljs-comment">// 后代选择器</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> ojb3 = $(<span class="hljs-string">&quot;#div+div&quot;</span>);  <span class="hljs-comment">// 兄弟选择器</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> ojb4 = $(<span class="hljs-string">&quot;#div~div&quot;</span>);  <span class="hljs-comment">// 兄弟选择器</span></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>obj1：子选择器：选择当前标签的<em>下一级标签</em>中所有符合条件的标签</li><li>ojb2：后代选择器：选择当前标签下<em>所有标签</em>中符合条件的标签</li><li>ojb3：兄弟选择器：+ 表示选择同级后面<em>第一个</em>符合条件的标签</li><li>ojb3：兄弟选择器：~ 表示选择同级后面<em>所有</em>符合调钱的标签</li></ul><h3 id="常用的过滤选择器">常用的过滤选择器</h3><p>当我们无法精准的获取到目标元素的时候，就可以使用过滤器进行操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>12<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>34<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>56<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>78<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 直接获取li会返回多个li，通过 :first来获取数组中第一个li元素</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> obj1 = $(<span class="hljs-string">&quot;li:first&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 同 :first想法，:last用于获取最后一个元素</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> obj2 = $(<span class="hljs-string">&quot;li:last&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 返回所有li中索引为偶数的元素，0也算作为偶数</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> obj3 = $(<span class="hljs-string">&quot;li:even&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 同:even相反，:odd用于取基数 (可以利用奇偶数来做隔行变色的说)</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> obj4 = $(<span class="hljs-string">&quot;li:odd&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 获取索引大于2的li</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> obj5 = $(<span class="hljs-string">&quot;li:gt(2)&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 获取索引小于2的li</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> obj6 = $(<span class="hljs-string">&quot;li:lt(2)&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 通过下标获取执行li</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> obj7 = $(<span class="hljs-string">&quot;li:eq(2)&quot;</span>);</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="更多选择器">更多选择器</h3><p>更多选择器我是记不过来了，这里只记录了几个比较常用的选择器，需要使用更多随时查询</p><p><code>https://blog.csdn.net/pseudonym_/article/details/76093261</code></p><h2 id="元素操作">元素操作</h2><p>和 JS 一样，我们可以通过 jQuery 对象获取到这个标签的所有信息，而且比 JS 操作要便捷的多</p><h3 id="一般元素操作">一般元素操作</h3><p>以这段 HTML 代码为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;d1&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;我是title&quot;</span>&gt;</span>哎呦不错哦<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;d2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>获取操作</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 获取d1的属性title的值</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> title = $(<span class="hljs-string">&quot;#d1&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;title&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 获取d1标签内的内容(仅文本)</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> text = $(<span class="hljs-string">&quot;#d1&quot;</span>).<span class="hljs-title function_">text</span>();</span><br><span class="language-javascript">        <span class="hljs-comment">// 获取d1标签内的内容(HTML也会以文本方式读取)</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> text = $(<span class="hljs-string">&quot;#d1&quot;</span>).<span class="hljs-title function_">html</span>();</span><br><span class="language-javascript">        <span class="hljs-comment">// 获取d2标签内的所有子标签</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> children = $(<span class="hljs-string">&quot;#d2&quot;</span>).<span class="hljs-title function_">children</span>();</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">/* 这里针对children数组，可以用jQuery的each函数进行遍历 */</span></span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-comment">// 在匿名函数中this代表的就是数组中的每个元素</span></span><br><span class="language-javascript">        children.<span class="hljs-title function_">each</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">        <span class="hljs-comment">// 但是如果使用的是箭头函数，this的指向就会发生改变，不过我们还是可以通过参数列表获取信息</span></span><br><span class="language-javascript">        children.<span class="hljs-title function_">each</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">index, item</span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 第一个是下标，第二个对应着数组内的元素</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index, item);</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>修改操作</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 修改d1的属性title的值</span></span><br><span class="language-javascript">        $(<span class="hljs-string">&quot;#d1&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;哎呦不错哦&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 修改d1标签内的文本(不会被渲染为HTML)</span></span><br><span class="language-javascript">        $(<span class="hljs-string">&quot;#d1&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;&lt;font color=&#x27;red&#x27;&gt;font标签/font&gt;&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 修改d1标签内的文本(会被渲染为HTML)</span></span><br><span class="language-javascript">        $(<span class="hljs-string">&quot;#d1&quot;</span>).<span class="hljs-title function_">html</span>(<span class="hljs-string">&quot;&lt;font color=&#x27;red&#x27;&gt;font标签/font&gt;&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 修改d2标签下第二个span下的第一个img的src属性</span></span><br><span class="language-javascript">        $(<span class="hljs-string">&quot;#d2&quot;</span>)</span><br><span class="language-javascript">            .<span class="hljs-title function_">children</span>().<span class="hljs-title function_">eq</span>(<span class="hljs-number">1</span>)</span><br><span class="language-javascript">         .<span class="hljs-title function_">children</span>().<span class="hljs-title function_">eq</span>(<span class="hljs-number">0</span>)</span><br><span class="language-javascript">         <span class="hljs-comment">// 除开attr，prop也可以操作标签的属性</span></span><br><span class="language-javascript">         .<span class="hljs-title function_">prop</span>(<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;/img/hello.jpg&quot;</span>);</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>删除操作</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 删除了d1的title，还可以删除removeClass</span></span><br><span class="language-javascript">        $(<span class="hljs-string">&quot;#d1&quot;</span>).<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">&quot;title&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 删除了d2标签内第二个span下的第一个img标签</span></span><br><span class="language-javascript">        $(<span class="hljs-string">&quot;#d2&quot;</span>).<span class="hljs-title function_">children</span>().<span class="hljs-title function_">eq</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">children</span>().<span class="hljs-title function_">eq</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">remove</span>();</span><br><span class="language-javascript">        <span class="hljs-comment">// 清空d2下所有的标签以及文本</span></span><br><span class="language-javascript">        $(<span class="hljs-string">&quot;#d2&quot;</span>).<span class="hljs-title function_">empty</span>();</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>添加操作</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这里皮一下</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">JQ</span> = jQuery;</span><br><span class="language-javascript">    <span class="hljs-comment">// jQuery只是需要一个匿名函数而已，这里传一个箭头函数也是可以的</span></span><br><span class="language-javascript">    <span class="hljs-title function_">JQ</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">JQ</span>(<span class="hljs-string">&quot;#d1&quot;</span>).<span class="hljs-title function_">remove</span>();</span><br><span class="language-javascript">        <span class="hljs-comment">// 获取到d2下的第一个span</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> span = <span class="hljs-title function_">JQ</span>(<span class="hljs-string">&quot;#d2&quot;</span>).<span class="hljs-title function_">children</span>().<span class="hljs-title function_">eq</span>(<span class="hljs-number">0</span>);</span><br><span class="language-javascript">        span.<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;【原始的span】&quot;</span>);</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-comment">// 添加到内部(追加在原有内容后面)</span></span><br><span class="language-javascript">        span.<span class="hljs-title function_">append</span>(<span class="hljs-title function_">JQ</span>(<span class="hljs-string">&quot;&lt;button&gt;追加到span内部&lt;/button&gt;&quot;</span>));</span><br><span class="language-javascript">        <span class="hljs-title function_">JQ</span>(<span class="hljs-string">&quot;&lt;button&gt;被追加到span内部&lt;/button&gt;&quot;</span>).<span class="hljs-title function_">appendTo</span>(span);</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-comment">// 添加到内部(添加在原有内容的前面)</span></span><br><span class="language-javascript">        span.<span class="hljs-title function_">prepend</span>(<span class="hljs-title function_">JQ</span>(<span class="hljs-string">&quot;&lt;button&gt;从前面添加到内部&lt;/button&gt;&quot;</span>));</span><br><span class="language-javascript">        <span class="hljs-title function_">JQ</span>(<span class="hljs-string">&quot;&lt;button&gt;从前面被添加到内部&lt;/button&gt;&quot;</span>).<span class="hljs-title function_">prependTo</span>(span);</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-comment">// 追加到span后面</span></span><br><span class="language-javascript">        span.<span class="hljs-title function_">after</span>(<span class="hljs-title function_">JQ</span>(<span class="hljs-string">&quot;&lt;p&gt;追加到span后面&lt;/p&gt;&quot;</span>));</span><br><span class="language-javascript">        <span class="hljs-title function_">JQ</span>(<span class="hljs-string">&quot;&lt;p&gt;被追加到span后面&lt;/p&gt;&quot;</span>).<span class="hljs-title function_">insertAfter</span>(span);</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-comment">// 添加到span前面</span></span><br><span class="language-javascript">        span.<span class="hljs-title function_">before</span>(<span class="hljs-title function_">JQ</span>(<span class="hljs-string">&quot;&lt;p&gt;添加到span前面&lt;/p&gt;&quot;</span>));</span><br><span class="language-javascript">        <span class="hljs-title function_">JQ</span>(<span class="hljs-string">&quot;&lt;p&gt;被添加到span前面&lt;/p&gt;&quot;</span>).<span class="hljs-title function_">insertBefore</span>(span);</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里需要注意的是，添加到内部和添加到同级的方法，他们的顺序是相反的</p><blockquote><p>样式操作</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    $(()=&gt;&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> d1 = $(<span class="hljs-string">&quot;#d1&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 设置样式、获取样式的值</span></span><br><span class="language-javascript">        d1.<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d1.<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;color&quot;</span>));</span><br><span class="language-javascript">        <span class="hljs-comment">// 获取目标标签的宽高</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;width&quot;</span>, d1.<span class="hljs-title function_">width</span>());</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;height&quot;</span>, d1.<span class="hljs-title function_">height</span>());</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除开这种方式我们还可以通过 jQuery 的 <code>attr</code> 或者 <code>prop</code> 函数来动态修改标签的 class 来达到修改样式的目的</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>$(“#id”).attr(“class”, “样式”)</td><td>为该标签重新设置样式</td></tr><tr><td>$(“#id”).addClass(“样式”)</td><td>在原有的 class 基础上追加新的 class</td></tr><tr><td>$(“#id”).removeClass(“样式”)</td><td>在原有的 class 基础上移除指定的 class</td></tr><tr><td>$(“#id”).removeClass()</td><td>该方法在不写参数的情况下将移除所有 class</td></tr><tr><td>$(“#id”).hasClass(“样式”)</td><td>该标签是否包含指定的 class 样式</td></tr></tbody></table><blockquote><p>其他操作</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 复制与替换 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    $(()=&gt;&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> d1 = $(<span class="hljs-string">&quot;#d1&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// clone复制该节点</span></span><br><span class="language-javascript">        d1.<span class="hljs-title function_">after</span>(d1.<span class="hljs-title function_">clone</span>());</span><br><span class="language-javascript">        <span class="hljs-comment">// clone复制该节点(连同事件一起复制)</span></span><br><span class="language-javascript">        d1.<span class="hljs-title function_">after</span>(d1.<span class="hljs-title function_">clone</span>(<span class="hljs-literal">true</span>));</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> d2 = $(<span class="hljs-string">&quot;#d2&quot;</span>);</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-comment">// 被替换的标签调用函数</span></span><br><span class="language-javascript">        d2.<span class="hljs-title function_">replaceWith</span>($(<span class="hljs-string">&quot;&lt;font id=&#x27;font&#x27; color=&#x27;blue&#x27;&gt;我来替换这个标签&lt;/font&gt;&quot;</span>));</span><br><span class="language-javascript">        <span class="hljs-comment">// 替换后的标签调用函数</span></span><br><span class="language-javascript">        $(<span class="hljs-string">&quot;&lt;font color=&#x27;red&#x27;&gt;这里在替换一次&lt;/font&gt;&quot;</span>).<span class="hljs-title function_">replaceAll</span>($(<span class="hljs-string">&quot;#font&quot;</span>))</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表单元素操作">表单元素操作</h3><p>之前联系了普通标签的一些操作，然后来练习一下基于 form 表单中的标签的操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这个是表单代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><br>        姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>        账号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;account&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br>        性别：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>/&gt;</span> 男<br>        <span class="hljs-symbol">&amp;nbsp;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>/&gt;</span> 女<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>        爱好：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;likes&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;游泳&quot;</span> /&gt;</span> 游泳<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;likes&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;健身&quot;</span> /&gt;</span> 健身<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;likes&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;卡拉OK&quot;</span> /&gt;</span> 卡拉OK<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;likes&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;大保健&quot;</span> /&gt;</span> 大保健<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>        住址：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>广东<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这个是jQuery代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    $(()=&gt;&#123;</span><br><span class="language-javascript">  <span class="hljs-comment">// 动态设置表单的提交参数</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> form = $(<span class="hljs-string">&quot;#form&quot;</span>);</span><br><span class="language-javascript">        form.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;action&quot;</span>, <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="language-javascript">        form.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;method&quot;</span>, <span class="hljs-string">&quot;post&quot;</span>);</span><br><span class="language-javascript">  <span class="hljs-comment">// 尝试获取了表单中的值，然后提交了表单</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> button = $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">0</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 动态绑定单击事件，提交表单</span></span><br><span class="language-javascript">        button.<span class="hljs-title function_">click</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> id = $(<span class="hljs-string">&quot;#form input[type=&#x27;hidden&#x27;]&quot;</span>).<span class="hljs-title function_">val</span>();</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> name = $(<span class="hljs-string">&quot;#form input[type=&#x27;text&#x27;]&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">val</span>();</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> accunt = $(<span class="hljs-string">&quot;#form input[type=&#x27;text&#x27;]&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">val</span>();</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> password = $(<span class="hljs-string">&quot;#form input[name=&#x27;password&#x27;]&quot;</span>).<span class="hljs-title function_">val</span>();</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> gender = $(<span class="hljs-string">&quot;#form input[name=&#x27;gender&#x27;]:checked&quot;</span>).<span class="hljs-title function_">val</span>();</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> address = $(<span class="hljs-string">&quot;#form select&gt;option:selected&quot;</span>).<span class="hljs-title function_">val</span>();</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> likes = [];</span><br><span class="language-javascript">            $(<span class="hljs-string">&quot;#form input[name=&#x27;likes&#x27;]:checked&quot;</span>)</span><br><span class="language-javascript">                 .<span class="hljs-title function_">each</span>(<span class="hljs-function">(<span class="hljs-params">index, item</span>)=&gt;</span>likes.<span class="hljs-title function_">push</span>($(item).<span class="hljs-title function_">val</span>()));</span><br><span class="language-javascript">            form.<span class="hljs-title function_">submit</span>();</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="事件函数">事件函数</h2><h2 id="特效和动画">特效和动画</h2><h2 id="DOM遍历">DOM遍历</h2><h2 id="AJAX请求">AJAX请求</h2>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC学习笔记</title>
    <link href="/0202/06/13/SpringMVC%E7%AC%94%E8%AE%B0/"/>
    <url>/0202/06/13/SpringMVC%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>SpringMVC 笔记</h1><p>SpringMVC是基于MVC处理模式的web框架，分离了 控制器 - 模型对象 - 过滤器 以及处理程序对象</p><p>SpringMVC的工作流程:</p><ol><li>客户端通过浏览器发出请求，通过web.xml的配置调用DispatcherServlet ( 核心处理器 ) 接收请求，并将请求交给处理器映射器处理</li><li>映射器 ( BeanNameUrlHandlerMapping ) 通过请求的url地址解析出映射关系，查找是否有符合规则的Bean，然后将映射关系返还给核心处理器，由核心处理器将映射关系交给映射器<br>3. 适配器 ( SimpleControllerHandlerAdapter ) 核心处理器，底层使用了instanceOf技术，主要是判断对应映射关系的Bean是否继承了Controller接口，符合则调用对应的Bean执行对应逻辑，并将结果返还给适配器，然后返还给核心处理器</li><li>核心处理器调用视图解析器（ViewResolver）适配器返还的结果进行解析，解析为View返还给处理器</li><li>核心处理器调用View将模型数据渲染为视图</li><li>核心处理器向客户端做出响应</li></ol><blockquote><p>在使用 springmvc 之前需要在 maven 中引入目标依赖：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>笔记将基于 springmvc 5.1.5 记录</p><h2 id="MVC的两种实现方式">MVC的两种实现方式</h2><h3 id="XML配置MVC">XML配置MVC</h3><blockquote><p>配置 web.xml</p></blockquote><p>在 web.xml 中配置 mvc 的 DispatcherServlet 的映射路径为 <strong>/</strong> ( 所有请求 )，让所有请求都交给 mvc 核心控制器进行处理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- init-param标签用来指定mvc所需要的配置文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在配置 web.xml 的时候可以不用配置 init-param ，他会默认的去 WEB-INF 目录下找配置文件，这时候文件名必须是 <code>servlet-name</code> 标签内的值，且后面必须加上-servlet，例如 springmvc-servlet.xml</p><blockquote><p>配置 springmvc</p></blockquote><p>定义了映射器及适配器，将自己书写的实现了Controller的控制器类装配在Bean中，映射器和适配器是可以省略不写的，他有自己的默认配置，如果写了其中的一个，那么建议另一个一定要写上</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--处理映射关系--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--适配器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>编写控制器类</p></blockquote><p>控制器就是 mvc 为我们封装好的 web 中的 servlet 类，他可以接收客户端发来的请求，省去了我们在 web 开发中较为麻烦的 web.xml 配置等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(HttpServletRequest request,                                   HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">model</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>    System.out.println(<span class="hljs-string">&quot;控制器被成功执行&quot;</span>);<br>    model.addObject(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;con1 goto index.jsp&quot;</span>);<br>    model.setViewName(<span class="hljs-string">&quot;index.jsp&quot;</span>);<br>    <span class="hljs-keyword">return</span> model;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ModelAndView 类：<ul><li>用来负责 mvc 中主要的逻辑，其中 setViewName 方法经过视图解析器后就是转发的目标路径</li><li>addObject 方法就类似 request 中的 setAttribute 方法</li></ul></li></ul><h3 id="注解配置MVC">注解配置MVC</h3><p>注解配置 springmvc 相比配置文件来说更为简单，建议重新开个项目来写</p><blockquote><p>重写配置文件</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开启注解配置mvc --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><span class="hljs-comment">&lt;!-- scan扫描注解所在的包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;club.hanzhe.web&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>控制器类代码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Con1</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/main&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;mvc function run&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>使用了 <code>@Controller</code> 注解，表明当前类是控制器类。</li><li>每个方法上都可以使用 <code>@RequestMapping</code> 来指定目标访问路径</li></ol><h2 id="MVC-的视图解析器">MVC 的视图解析器</h2><p>在每个控制器中会返回 ModelAndView 的实例，这些返回的实例会被视图解析器接受并解析处理，setViewName 会被解析为路径拼接到视图解析器中，addObject 中的数据会被封装到目标路径的 request 域中</p><p>视图解析器配置中的配置及最常用的两个属性</p><ul><li>prefix：是解析视图名称后拼接在前面的前缀，<strong>/</strong> 代表目标视图在根目录</li><li>suffix：是解析视图名称后拼接在后面的后缀，.jsp 代表解析后为 jsp 视图</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="请求参数绑定">请求参数绑定</h2><h3 id="简单类型绑定">简单类型绑定</h3><p>想要什么名字，什么类型的参数，直接写在处理请求的方法的参数列表中即可，需要注意的是，变量名要与请求参数表单的 name 值相同</p><p>例如：localhost:8080/Day01/1.action?user=abc</p><p>这时表单传来的数据中 name 为 user，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;1&quot;)</span> <span class="hljs-comment">// 简单参数绑定，变量名需要与表单的name相同</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">( String user )</span> &#123;<br>    <span class="hljs-comment">// 打印测试</span><br>    System.out.println(<span class="hljs-string">&quot;user = &quot;</span> + user);<br>&#125;   <br></code></pre></td></tr></table></figure><p>如果参数列表和提交的表单的 name 不同，需要使用注解获取指定 name 的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 请求地址： localhost:8080/username=zhang</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">( <span class="hljs-meta">@RequestParam(&quot;username&quot;)</span>String name )</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;获取到的值：&quot;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pojo类型绑定">pojo类型绑定</h3><p>同简单类型绑定一致，直接写在参数列表中即可，请求参数中会对应指定pojo中属性的变量名，但是如果想要赋值成功，需要pojo对其中每个变量提供正确的Set方法</p><p>例如：localhost:8080/Day01/1.action?name=zhang&amp;pwd=hanzhe&amp;age=123</p><p>表单中传来的数据，其中name和pwd是pojo中的属性，而age是参数列表中的属性，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;1&quot;)</span> <span class="hljs-comment">// pojo类型参数绑定，需要pojo中有对应的属性，且有set方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">( User user , Integer age )</span> &#123;<br>    System.out.println(user);<br>    System.out.println(<span class="hljs-string">&quot;测试数据 = &quot;</span> + age);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Date类型绑定">Date类型绑定</h3><p>Date时间类型在绑定的时候需要添加一个注解：【@DateTimeFromat( pattren = “” ) Date d】，这样就可以让字符串类型的时间按照指定的类型转换为Date对象</p><p>例如：localhost:8080/Day01/1.action?date=2012-12-25</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;1&quot;)</span> <span class="hljs-comment">// date类型数据绑定</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">( <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date )</span> &#123;<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>().format(date));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RequestMapping">@RequestMapping</h2><p>用来定义映射路径，可以定义在方法上，让请求仅对当前方法有效，也可以定义在类上，做为方法的上级路径</p><p>@RequestMapping有很多属性，可以筛选高级请求：</p><ol><li>value属性：代表访问的路径地址，在没有第二个属性存在的情况下，可省略不写</li><li>paht属性：作用等同于value，value和path属性不允许同时出现同一个RequestMapping中</li><li>method属性：是个字符串数组，可以对请求方法进行拦截，例如只允许 get post 请求才可以访问</li><li>params属性：是个字符串数组，可以对请求参数进行约束，例如访问该请求必须携带 name pwd 参数，</li></ol><h4 id="常见的三种请求方法">常见的三种请求方法</h4><ol><li><p>含有占位符【?】访问路径</p><p>​ 书写方式：paht = “**?**o”</p><p>​ 访问方式：localhost:8080/Day01/**?**o.action</p><p>​ 注意：？代表的是单个占位符，o.action前面不能留空，必须有一个字符</p></li><li><p>含有通配符【*】访问路径</p><p>​    书写方式：path = “*****o”</p><p>​    访问方式：localhost:8080/Day01/*****o.action</p><p>​    注意：* 代表0个或多个任意字符，o.action或15416516o.action都可以访问的到</p></li><li><p>参数访问路径：{ }</p><p>​    以参数列表做为路径，每个参数需要用{ }括起来</p><p>​    书写方式：path = “{name}/{pwd}/{age}”</p><p>​ 访问方式：localhost:8080/Day01/zhang/hanzhe/20.action</p><ol><li>想要获取到传入的值需要在参数列表中添加注解@PathVariable**，<strong>例如：public void test(</strong>@PathVariable**(“name”)String name , ……)</li></ol></li><li><p>在使用参数访问路径的同时也可以获取表单的值，使用**@RequestParam**注解就可以获取，且该注解可以省略不写</p></li></ol><h3 id="转发与重定向">转发与重定向</h3><p>在 SpringMVC 中通过视图解析器拼接的字符串可以做为路径访问实现网页跳转功能，基于视图解析器的网页跳转使用的是转发的机制，想要实现重定向的方法有两种方法</p><p><strong>1. 通过请求与响应</strong></p><p>可以在处理器方法的参数列表中自行添加 HttpServletRequest 和 HttpServletResponse 参数进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Model model)</span> <br>       <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 携带参数</span><br>    model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;携带的转发参数&quot;</span>);<br>    <span class="hljs-comment">// 转发到指定页面</span><br>    req.getRequestDispatcher(<span class="hljs-string">&quot;list.jsp&quot;</span>).forward(req, resp);<br>    <span class="hljs-comment">// 重定向到指定页面</span><br>    resp.sendRedirect(<span class="hljs-string">&quot;list.jsp&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 通过 MVC 的 String 返回值</strong></p><p>在当处理器方法为 String 类型的时候，可以控制页面跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/tiao2&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 返回list字符串，经过视图解析器后拼接路径，为转发效果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;list&quot;</span>;<br>    <span class="hljs-comment">// 加上forward前缀，指定页面跳转为转发形式</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:list.jsp&quot;</span>;<br>    <span class="hljs-comment">// 加上redirect前缀，指定页面跳转为重定向形式</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:list.jsp&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="响应数据的方法">响应数据的方法</h2><p><strong>1. 请求参数的响应路径设置：</strong></p><p>在通过注解进行处理请求，我们自定义的方法的时候可以指定返回值类型为String类型，通过视图解析器将字符串拼接为资源名</p><p><strong>2. 请求参数的默认默认路径：</strong></p><p>但是在并没有指定他跳转到某一个资源的时候，通过配置视图解析器会默认指定一个资源，就是以当前路径为基础的jsp文件</p><p>例如请求：<code>localhost:8080/Day02/demo2/1.do</code>时，他会默认跳转到<code>localhost:8080/Day02/demo2/1.jsp</code>资源下，且利用的时转发的技术</p><p>在他转发进行转发的时候，就可以携带一些参数</p><h3 id="绑定Web参数">绑定Web参数</h3><p>可以在处理请求的方法上直接书写请求和相应对应的对象，就像doGet和doPost一样</p><ol><li><p>要使用Request或Response对象，直接在参数列表中书写即可，类似doGet或者doPost</p></li><li><p>使用Cookie的话，可以在参数列表中使用@CookieValue的注解，后面跟上Object o用来存储他对应的Value，他有三个主要的属性：</p><ol><li>name：cookie的name值，通过name可以获取到对应的value值</li><li>required：是个boolean值，如果为true，则代表当前name是必备条件，false则是可有可无的条件</li><li>defaultValue：没有获取到当前Cookie的情况下设置的默认值，可以避免因为required所产生的异常</li></ol></li><li><p>Cookie同时也可以通过request对象获取，config，context，session等都是如此</p></li></ol><h3 id="响应数据对象">响应数据对象</h3><p><strong>1. Map集合方式响应数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;1&quot;)</span> <span class="hljs-comment">// Map集合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">( Map&lt;String , String&gt; map )</span> &#123;<br>    map.put(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;Map响应的数据&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. Model模型响应数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;2&quot;)</span> <span class="hljs-comment">// Model模型</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">( Model model )</span> &#123;<br>    model.addAttribute(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;Model响应的数据&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;demo3/1&quot;</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>3. ModelMap响应数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;3&quot;)</span> <span class="hljs-comment">// Map集合</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test3</span><span class="hljs-params">( ModelMap mm )</span> &#123;<br>    mm.addAttribute(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;ModelMap响应的数据&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;demo3/1&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. ModelAndView响应数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;4&quot;)</span> <span class="hljs-comment">// Map集合</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;demo3/1&quot;</span>);<br>    mod.addObject(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;ModelAndView响应的数据&quot;</span>);<br>    <span class="hljs-comment">// mod.setViewName(&quot;demo3/1&quot;);</span><br>    <span class="hljs-keyword">return</span> mod;<br>&#125;<br></code></pre></td></tr></table></figure><p>小细节：</p><ol><li>之前三个响应数据的方式都是通过返回String类型来指定路径</li><li>ModelAndView使用他本身设置跳转资源路径，设置的方式有两种<ol><li>通过构造方法：<strong>new</strong> ModelAndView(“demo3/1”);</li><li>调用set方法：mod.setViewName(“demo3/1”);</li></ol></li></ol><h2 id="SpringMVC-拦截器">SpringMVC 拦截器</h2><p>springmvc 中的拦截器和过滤器有些类似，他的作用是扫描指定的请求并对其进行拦截，可以在拦截前和拦截后对请求进行一些操作，符合请求要求的会被放行，不符合的则会被拦截</p><p>拦截的目标仅限于请求，不包含 JSP 等。</p><blockquote><p>1.编写拦截器</p></blockquote><p>springmvc 中为我们提供的拦截器接口为 <code>HandlerInterceptor</code>，我们需要实现这个接口并复写其中的函数，复写的函数包括：</p><p><code>preHandle</code>：返回一个 boolean 值，==true 为通过，false 为拦截==</p><p><code>postHandle</code>：拦截请求后需要执行的逻辑在这里书写。</p><p><code>afterCompletion</code>：拦截器工作完成后的善后逻辑写在这里。</p><p>实现接口有一个特点，就是强制要求复写其中全部的方法，有时候我可能只需要一个方法，这时就被强迫实现三个方法，所以 mvc 中提供了一个 <strong>拦截器适配器</strong> <code>HandlerInterceptorAdapter</code> 来做这个过渡</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HandlerInterceptorAdapter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;拦截器执行第&quot;</span> + count + <span class="hljs-string">&quot; 次，拦截请求目标为&quot;</span>);<br>        System.out.println(req.getRequestURL().toString());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>2.注册拦截器</p></blockquote><p>在拦截器类书写完毕之后去 SpringMVC 的配置文件中进行配置拦截器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- s 结尾是复数，代表着可以配置多个拦截器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 制定拦截的路径和处理拦截逻辑的拦截器 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- 需要注意的是 mvc:mapping标签要在上面，否则可能会报错 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/*&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;club.hanzhe.config.MyInterceptor&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="上传和下载">上传和下载</h2><blockquote><p>添加maven依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- jstl核心标签库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Apache的上传组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>单文件上传</p></blockquote><p>在开始之前我们需要知道，文件上传是需要依靠 file 类型表单完成的，并且 <strong>表单的提交方式必须是post，且需要修改属性<code>enctype=&quot;multipart/form-data&quot;</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.servletContext.contextPath&#125;/uploadFile&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点击上传&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当提交表单后，会访问后端 uploadFile 控制器负责处理文件上传的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/uploadFile&quot;)</span>     <span class="hljs-comment">// 单文件上传</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile file, ModelAndView mv)</span> &#123;<br> mv.setViewName(<span class="hljs-built_in">this</span>.upload(file));<br> <span class="hljs-keyword">return</span> mv;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数列表中的MultipartFile就代表被接收的文件，file变量要对应表单中input的name属性</li></ul><blockquote><p>该函数为上面代码中调用的函数，封装改代码用于等下多文件上传时复用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// file 代表需要上传的文件</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">( MultipartFile file )</span> &#123;<br>    <span class="hljs-keyword">if</span> (!file.isEmpty()) &#123;<br>        <span class="hljs-comment">// 获取上传文件的名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br>        <span class="hljs-keyword">try</span> &#123;<br>   <span class="hljs-comment">// 将当前文件保存到指定的路径</span><br>            file.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\Download&quot;</span> + File.separator + System.currentTimeMillis() + filename ));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;代码发生异常了&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error.jsp&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success.jsp&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>File.separator 代表文件分隔符，即为Windows系统中<code>E:\Download</code>中的斜杠，因为Windows于Linux的文件分隔符不同，所以这里我就使用了File类中的分隔符</p></li><li><p>System.currentTimeMillis( ) 时间戳</p></li></ul><h2 id="文件下载">文件下载</h2><p>文件上传在之前已经书写完毕，打开之前设置好的目录可以发现文件已经可以正常上传了，接下来就需要实现文件的下载功能。</p><p>想要实现文件的下载功能，首先需要知道有多少可以被下载的文件，所以这里需要让用户优先访问控制器，经过处理后在跳转到下载页面中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/downFile&quot;)</span>    <span class="hljs-comment">// 文件遍历及下载</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">downFile</span><span class="hljs-params">(ModelAndView mv)</span> &#123;<br> <span class="hljs-comment">// 将上传目录封装为对象</span><br> <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\Download&quot;</span>);<br> String[] list = file.list();<br> <span class="hljs-comment">// 将携带着文件名的集合存到request域中发送到jsp页面上</span><br> mv.addObject(<span class="hljs-string">&quot;list&quot;</span>, list);<br> mv.setViewName(<span class="hljs-string">&quot;download.jsp&quot;</span>);<br> <span class="hljs-keyword">return</span> mv;<br>&#125;<br></code></pre></td></tr></table></figure><p>跳转到下载页面后，此时的request域中已经封装了所有文件的信息，这里就使用jstl标签库的each进行循环遍历即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1px dashed black&quot;</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;5px&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0px&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">c:forEach</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;$&#123;list&#125;&quot;</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">varStatus</span>=<span class="hljs-string">&quot;status&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;status.index+3&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;file&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.servletContext.contextPath&#125;/down?name=$&#123;file&#125;&quot;</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">c:forEach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当点击下载的时候会访问指定的控制器，并携带想要下载的文件的文件名，这时就可以通过Java来进行下载了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/down&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(String name, HttpServletResponse resp)</span> &#123;<br>    <span class="hljs-comment">// 获取下载的文件对象</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\Download&quot;</span> + File.separator + name);<br>    <span class="hljs-comment">// 修改请求头</span><br>    resp.setHeader(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;application/octet-stream&quot;</span>);<br>    <span class="hljs-comment">// 设置下载的文件名</span><br>    resp.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span>+name );<br>    <span class="hljs-comment">// 创建缓存区，大小为8192字节</span><br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8192</span>];<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建输入流，读取到指定文件的信息</span><br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file));<br>        <span class="hljs-comment">// 创建输出流，用于下载文件</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>        <span class="hljs-comment">// 当 i 为 -1 的时候，就代表文件输出完毕了，可以停止循环代码了</span><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bis.read(buffer); i != -<span class="hljs-number">1</span>; ) &#123;<br>            os.write(buffer, <span class="hljs-number">0</span>, i);<br>            i = bis.read(buffer);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;出错了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里由于之前下载的 a 标签使用了 target=“_blank”，所以这里的浏览器会新建页面进行下载，发起下载后当前页面也会自动关闭，不会影响你的正常操作 ( 这里我还没不为什么页面会自动关闭，应该是请求头设置的问题吧 )，这样一来文件的下载也就完成了！</p><h2 id="多文件上传">多文件上传</h2><p>多文件上传这里，前端页面并没有什么改变，只不过input从一个变成了两个 ( 注意name属性不要重名)，Java代码如下所示：</p><blockquote><p>这里的参数列表由 <code>Multipart</code> 改为了 <code>MultipartHttpServletRequest</code>，这样一来就可以获取多个文件的信息了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/uploadFiles&quot;)</span>     <span class="hljs-comment">// 多文件上传</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">uploads</span><span class="hljs-params">(MultipartHttpServletRequest files, ModelAndView mv)</span> &#123;<br> <span class="hljs-comment">// 获取所有上传的文件名</span><br>    Iterator&lt;String&gt; names = files.getFileNames();<br> <span class="hljs-comment">// 循环保存每一个文件</span><br>    <span class="hljs-keyword">while</span> (names.hasNext())<br>        <span class="hljs-built_in">this</span>.upload( files.getFile(names.next()) );<br>    mv.setViewName(<span class="hljs-string">&quot;success.jsp&quot;</span>);<br>    <span class="hljs-keyword">return</span> mv;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RestFul-风格">RestFul 风格</h2><p>RestFul 只是一种风格，基于这个风格设计的程序可以更简洁，有层次，更易于实现缓存等机制,  他实现了请求相同的路径而产生不同的逻辑的效果,  实现了 URL 复用</p><p>一般基于数据增删改查发出的请求，是通过==区分不同的路径==达到 CRUD 的效果，例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">localhost</span>:<span class="hljs-number">8080</span>/dropUser?id=<span class="hljs-number">1</span>  删除用户<br><span class="hljs-attribute">localhost</span>:<span class="hljs-number">8080</span>/finduser?id=<span class="hljs-number">1</span>  查询用户<br></code></pre></td></tr></table></figure><p>而 RestFul 是通过==区分请求的方法==达到 CRUD 的效果，例如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">localhost</span>:<span class="hljs-number">8080</span>/user?id=<span class="hljs-number">1</span> 删除用户 发出DELETE请求<br><span class="hljs-attribute">localhost</span>:<span class="hljs-number">8080</span>/user?id=<span class="hljs-number">1</span> 查询用户 发出GET请求<br></code></pre></td></tr></table></figure><p>在 RestFul 中针对增删改查分别对应着四种请求方法</p><p><strong>［ 添加: POST ］［ 删除: DELETE ］［ 修改: PUT ］［ 查询: GET ］</strong></p><p>针对区分四种请求的方法有两种手段：</p><ol><li><p>通过 RequestMapping 中的 method 属性进行区分请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 仅接收以post方法发出的请求</span><br><span class="hljs-meta">@RequestMapping(value=&quot;/user&quot;, method = RequestMethod.POST)</span><br></code></pre></td></tr></table></figure></li><li><p>通过每个方法对应的注解进行区分</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@PostMapping</span><br><span class="hljs-variable">@DeleteMapping</span><br><span class="hljs-variable">@PutMapping</span><br><span class="hljs-variable">@GetMapping</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="导出Excel表格">导出Excel表格</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
